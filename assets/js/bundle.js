/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/completion.js":
/*!***************************!*\
  !*** ./src/completion.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGenerator: () => (/* binding */ createGenerator),\n/* harmony export */   handleSse: () => (/* binding */ handleSse)\n/* harmony export */ });\nclass PromptTemplate {\n    constructor(template) {\n        this.template = template;\n    }\n\n    // Methode 1: Template Literals (moderne ES6+ Syntax)\n    formatWithTemplateString(variables) {\n        return new Function(...Object.keys(variables), `return \\`${this.template}\\`;`)(...Object.values(variables));\n    }\n\n    // Methode 2: Named Parameters mit {{name}}\n    formatWithNamedParams(variables) {\n        return this.template.replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => variables[key] || \"\");\n    }\n}\n\nclass AbstractLlmApi {\n    async generate() {\n        throw new Error(\"Not implemented\");\n    }\n\n    setSystemPrompt(systemPrompt) {\n        this.systemPrompt = systemPrompt; \n    }\n\n    getSystemPrompt() {\n        return this.systemPrompt;\n    }\n\n    attachMessage(role, content) {\n        if(!this.messages) {\n            this.reset();\n        }\n        this.messages.push({ role, content });\n    }\n\n    attachMessageAsAssistant(content) {\n        this.attachMessage(this.getAssistantRole(), content);\n    }\n\n    attachMessageAsUser(content) {\n        this.attachMessage(this.getUserRole(), content);\n    }\n\n    reset() {\n        this.messages = [];\n    }\n\n    extractMessages(line) {\n        throw new Error(\"Not implemented\");\n    }\n\n    getAssistantRole() {\n        return \"assistant\";\n    }\n    getUserRole() {\n        return \"user\";\n    }\n    getDetails() {\n        return {\"type\": \"unknown\"};\n    }\n}\n\nclass ClaudeApi extends AbstractLlmApi {\n    constructor(apiKey, model) {\n        super();\n        this.apiKey = apiKey;\n        this.model = model;\n    }\n\n    getDetails() {\n        return {\"type\": \"claude\", \"model\": this.model};\n    }\n\n    async generate() {\n        try {\n            const body = JSON.stringify({\n                model: this.model || \"claude-3-5-sonnet-20241022\",\n                max_tokens: 1024,\n                stream: true,\n                system: [{\n                    type: \"text\",\n                    cache_control: {\"type\": \"ephemeral\"},\n                    text: this.systemPrompt\n                }],\n                messages: this.messages\n            });\n\n            const response = await fetch('https://api.anthropic.com/v1/messages', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'x-api-key': this.apiKey,\n                    'anthropic-version': '2023-06-01',\n                    'anthropic-dangerous-direct-browser-access': 'true'\n                },\n                body\n            });\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(`API error: ${response.status} ${response.statusText}\\nDetails: ${errorText}`);\n            }\n\n            return response.body;\n        } catch (error) {\n            throw new Error(`Failed to generate alternative: ${error.message}`);\n        }\n    }\n\n    extractMessages(line) {\n        if (!line || line.trim() === '') {\n            return '';\n        }\n        //console.log(`Message: ${line}`);\n        const parsedData = JSON.parse(line);\n\n        // We got a valid JSON message, but it might be an error\n        if (parsedData.type === \"error\") {\n            const error = new Error(`Stream error: ${parsedData.error?.type} - ${parsedData.error?.message}`);\n            error.isStreamError = true;\n            error.errorData = parsedData.error;\n            throw error;\n        }\n\n        // We got a valid JSON message and it looks like a delta\n        if (parsedData.delta && parsedData.delta.text) {\n            return parsedData.delta.text;\n        }\n        \n        return '';\n    }\n}\n\nclass OpenAiApi extends AbstractLlmApi {\n    constructor(apiKey, model) {\n        super();\n        this.apiKey = apiKey;\n        this.model = model;\n    }\n\n    getDetails() {\n        return {\"type\": \"openai\", \"model\": this.model};\n    }\n\n    reset() {\n        this.messages = [];\n        if (this.systemPrompt) {\n            this.attachMessage(\"system\", this.systemPrompt);\n        }\n    }\n\n    async generate() {\n        try {\n            const body = JSON.stringify({\n                model: this.model || \"gpt-4-turbo-preview\",\n                messages: this.messages,\n                max_tokens: 1024,\n                temperature: 0.7,\n                stream: true\n            });\n\n            const response = await fetch('https://api.openai.com/v1/chat/completions', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${this.apiKey}`\n                },\n                body\n            });\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(`API error: ${response.status} ${response.statusText}\\nDetails: ${errorText}`);\n            }\n\n            return response.body;\n        } catch (error) {\n            throw new Error(`Failed to generate alternative: ${error.message}`);\n        }\n    }\n\n    extractMessages(line) {\n        const parsedData = JSON.parse(line);\n        const token = parsedData.choices[0].delta.content || '';\n        return token;\n    }\n}\n\nclass CustomBasedOnOpenAiApi extends AbstractLlmApi {\n    constructor(apiKey, model, url) {\n        super();\n        this.apiKey = apiKey;\n        this.model = model;\n        this.url = url.endsWith('/') ? url.slice(0, -1) : url;\n    }\n\n    getDetails() {\n        return {\"type\": \"custom\", \"model\": this.model, \"url\": this.url};\n    }\n\n    reset() {\n        this.messages = [];\n        if (this.systemPrompt) {\n            this.attachMessage(\"system\", this.systemPrompt);\n        }\n    }\n\n    async generate() {\n        const body = JSON.stringify({\n            model: this.model || \"\",\n            messages: this.messages,\n            max_tokens: 1024,\n            temperature: 0.7,\n            stream: true\n        });\n\n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        if (this.apiKey) {\n            headers['Authorization'] = `Bearer ${this.apiKey}`;\n        }\n        let response;\n        const url = `${this.url}/v1/chat/completions`;\n        try {\n            response = await fetch(url, {\n                method: 'POST',\n                headers,\n                body\n            });\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(`API error: ${response.status} ${response.statusText}\\nDetails: ${errorText}`);\n            }\n\n            return response.body;\n        } catch (error) {\n            throw new Error(`Failed to generate alternative: ${error.message}\\nRequest Details: ${JSON.stringify({ url, body, headers, response }, null, 2)}`);\n        }\n    }\n\n    extractMessages(line) {\n        const parsedData = JSON.parse(line);\n        const token = parsedData.choices[0].delta.content || '';\n        return token;\n    }\n}\n\nclass Generator {\n    constructor(api, systemPrompt, promptPrefix, variables) {\n        this.api = api;\n        this.systemPrompt = systemPrompt;\n        this.promptPrefix = promptPrefix;\n        this.variables = variables;\n\n        this.reset();\n    }\n\n    getApiDetails() {\n        return this.api.getDetails();\n    }\n\n    reset() {\n        // Create prompt templates to replace them with information from variables\n        const systemPromptTemplate = new PromptTemplate(this.systemPrompt);\n\n        // Set current system prompt\n        this.api.setSystemPrompt(systemPromptTemplate.formatWithNamedParams(this.variables));\n\n        // Reset message history, some providers might require to add this to the message list\n        this.api.reset();\n    }\n\n    attachMessageAsAssistant(text) {\n        this.api.attachMessageAsAssistant(text);\n    }\n\n    attachMessageAsUser(text) {\n        this.api.attachMessageAsUser(text);\n    }\n\n    attachMessageAsUserUsingPrefix(variables) {\n        const codePromptTemplate = new PromptTemplate(this.promptPrefix);\n        this.api.attachMessageAsUser(codePromptTemplate.formatWithNamedParams(variables));\n    }\n\n    async generate() {\n        return await this.api.generate();\n    }\n\n    extractMessages(line) {\n        return this.api.extractMessages(line);\n    }\n\n    getMessages() {\n        return this.api.messages.map(el => {\n            let role = el.role;\n            if(el.role === this.api.getUserRole()) {\n                role = \"user\";\n            } else if(el.role === this.api.getAssistantRole()) {\n                role = \"assistant\";\n            }\n            return {\n                role,\n                content: el.content\n            }\n        });\n    }\n\n    restoreMessages(messages) {\n        this.api.messages = messages.map(el => {\n            let role = el.role;\n            if (el.role === \"user\") {\n                role = this.api.getUserRole();\n            } else if (el.role === \"assistant\") {\n                role = this.api.getAssistantRole();\n            }\n            return {\n                role,\n                content: el.content\n            };\n        });\n    }\n\n    getSystemPrompt() {\n        return this.api.getSystemPrompt();\n    }\n}\n\nfunction createGenerator(variables, systemPrompt = \"\", promptPrefix = \"\", options = {}) {\n    const llmType = options.llmType;\n    const llmModel = options.llmModel;\n    const llmApiKey = options.llmApiKey;\n\n    let api;\n    if (llmType === 'claude') {\n        api = new ClaudeApi(llmApiKey, llmModel);\n    } else if (llmType === 'openai') {\n        api = new OpenAiApi(llmApiKey, llmModel);\n    } else if (llmType === 'custom') {\n        const llmUrl = options.llmUrl;\n        api = new CustomBasedOnOpenAiApi(llmApiKey, llmModel, llmUrl);\n    } else {\n        throw new Error(`Unknown LLM type: ${llmType}`);\n    }\n\n    return new Generator(api, systemPrompt, promptPrefix, variables);\n}\n\nasync function handleSse(generator, callback) {\n    const stream = await generator.generate();\n    const reader = stream.getReader();\n    const decoder = new TextDecoder();\n\n    let result = '';\n    let buffer = '';\n    \n    try {\n        reading: while (true) {\n            const { done, value } = await reader.read();\n\n            if (done) {\n                break;\n            }\n\n            // Decodiere den Chunk und füge ihn zum Buffer hinzu\n            buffer += decoder.decode(value, { stream: true });\n\n            let pos;\n            while ((pos = buffer.indexOf('\\n\\n')) >= 0) {\n                const event = buffer.substring(0, pos);\n                buffer = buffer.substring(pos + 2);\n\n                const lines = event.split('\\n');\n                let data = '';\n                \n                for (const line of lines) {\n                    if (line.startsWith('data:')) {\n                        data += line.substring(5).trim();\n                    }\n                }\n\n                if (data === '[DONE]') {\n                    break reading;\n                }\n\n                if (data) {\n                    try {\n                        const token = generator.extractMessages(data);\n                        result += token;\n                        if (callback) {\n                            callback(undefined, token);\n                        }\n                    } catch (error) {\n                        if (error.isStreamError) {\n                            console.error(`Stream error: ${error.message}`);\n                            if (callback) {\n                                callback(JSON.stringify({\n                                    error: true,\n                                    type: error.errorData?.type,\n                                    message: error.errorData?.message\n                                }));\n                            }\n                            break reading;\n                        }\n                        console.error('Failed to parse JSON:', error);\n                    }\n                }\n            }\n        }\n    } catch (error) {\n        console.error('Stream processing error:', error);\n    }\n    \n    return result;\n}\n\n//# sourceURL=webpack://infravis/./src/completion.js?");

/***/ }),

/***/ "./src/data-loader.js":
/*!****************************!*\
  !*** ./src/data-loader.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   downloadSystemData: () => (/* binding */ downloadSystemData),\n/* harmony export */   uploadSystemData: () => (/* binding */ uploadSystemData),\n/* harmony export */   validateSystemData: () => (/* binding */ validateSystemData)\n/* harmony export */ });\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities.js */ \"./src/utilities.js\");\n\n\n/**\n * Opens a file dialog for the user to upload a YAML file containing system data.\n * Parses and validates the selected YAML file, updates the DataManager with the new data,\n * refreshes the visualization, and displays notifications based on the outcome.\n *\n * Utilizes a hidden file input element to trigger the file selection dialog.\n * Supports files with .yaml or .yml extensions.\n *\n * @function\n * @returns {void}\n */\nfunction uploadSystemData(dataManager) {\n    // Erstelle ein verstecktes Datei-Input-Element\n    const fileInput = document.createElement('input');\n    fileInput.type = 'file';\n    fileInput.accept = '.yaml,.yml';\n    fileInput.style.display = 'none';\n    document.body.appendChild(fileInput);\n    \n    // Klick auf das versteckte Input-Element simulieren\n    fileInput.click();\n    \n    // Event-Listener für die Dateiauswahl\n    fileInput.addEventListener('change', function(event) {\n        const file = event.target.files[0];\n        if (!file) return;\n        \n        const reader = new FileReader();\n        reader.onload = async function(e) {\n            try {\n                const yamlContent = e.target.result;\n                const parsedData = jsyaml.load(yamlContent);\n                \n                // Validiere die Datenstruktur\n                if (!validateSystemData(parsedData)) {\n                    (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Ungültiges Datenformat', 'danger');\n                    return;\n                }\n                \n                // Daten im DataManager aktualisieren\n                dataManager.setData(parsedData);\n                \n                (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Daten erfolgreich geladen', 'success');\n            } catch (error) {\n                console.error('Fehler beim Parsen der YAML-Datei:', error);\n                (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Ungültiges YAML-Format', 'danger');\n            }\n        };\n        \n        reader.readAsText(file);\n        \n        // Entferne das temporäre Input-Element\n        document.body.removeChild(fileInput);\n    });\n}\n\n/**\n * Validiert die hochgeladene Datenstruktur\n * @param {Object} data - Die zu validierende Datenstruktur\n * @returns {boolean} True, wenn die Daten valide sind\n */\nfunction validateSystemData(data) {\n    // Überprüfe, ob die Grundstruktur vorhanden ist\n    if (!data || !Array.isArray(data.systems) || !Array.isArray(data.dependencies)) {\n        return false;\n    }\n    \n    // Überprüfe, ob alle Systeme eine ID haben\n    const allSystemsHaveId = data.systems.every(system => !!system.id);\n    if (!allSystemsHaveId) {\n        return false;\n    }\n    \n    // Überprüfe, ob alle Abhängigkeiten gültige source und target haben\n    const allDependenciesValid = data.dependencies.every(dep => \n        !!dep.source && !!dep.target && \n        data.systems.some(sys => sys.id === dep.source) && \n        data.systems.some(sys => sys.id === dep.target)\n    );\n    \n    return allDependenciesValid;\n}\n\n/**\n * Lädt die aktuellen Systemdaten als YAML-Datei herunter\n */\nfunction downloadSystemData(dataManager) {\n    const currentData = dataManager.getData();\n    \n    if (!currentData || !currentData.systems || currentData.systems.length === 0) {\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Keine Daten zum Herunterladen verfügbar', 'warning');\n        return;\n    }\n    \n    try {\n        // Konvertiere das JS-Objekt zu YAML\n        const yamlString = jsyaml.dump(currentData);\n        \n        // Erstelle einen Blob und einen Download-Link\n        const blob = new Blob([yamlString], { type: 'application/x-yaml' });\n        const url = URL.createObjectURL(blob);\n        \n        const a = document.createElement('a');\n        a.href = url;\n        a.download = 'systems_export.yaml';\n        document.body.appendChild(a);\n        a.click();\n        \n        // Räume auf\n        setTimeout(() => {\n            document.body.removeChild(a);\n            URL.revokeObjectURL(url);\n        }, 100);\n        \n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Daten erfolgreich heruntergeladen', 'success');\n    } catch (error) {\n        console.error('Fehler beim Herunterladen der Daten:', error);\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Fehler beim Herunterladen', 'danger');\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/data-loader.js?");

/***/ }),

/***/ "./src/data-manager.js":
/*!*****************************!*\
  !*** ./src/data-manager.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataManager: () => (/* binding */ DataManager)\n/* harmony export */ });\n/* harmony import */ var _event_emitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-emitter.js */ \"./src/event-emitter.js\");\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utilities.js */ \"./src/utilities.js\");\n\n\n\n/**\n * Loads the system data from the YAML file\n * @returns {Promise<Object>} The parsed data object\n */\nfunction loadSystemData() {\n    try {\n        // Load YAML file\n        const yamlText = localStorage.getItem('systems_yaml');\n        if (!yamlText) {\n            throw new Error('Could not load system data from local storage');\n        }\n\n        // Parse YAML to JavaScript object\n        const parsedData = jsyaml.load(yamlText);\n\n        return parsedData;\n    } catch (error) {\n        console.log('Could not load data, fallback to new data set', error);\n        return {\n            systems: [],\n            dependencies: []\n        };\n    }\n}\n\n/**\n * Saves the system data as YAML in local storage\n * @param {Object} data - The system data to save\n */\nfunction saveSystemData(data) {\n    try {\n        const yamlText = jsyaml.dump(data);\n        localStorage.setItem('systems_yaml', yamlText);\n        console.log('Data saved successfully');\n    } catch (error) {\n        console.error('Error saving data:', error);\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)('Error saving data', 'danger');\n    }\n}\n\n\n/**\n * DataManager - Central class for managing system data\n * Serves as the single source of truth for all other components\n */\nclass DataManager extends _event_emitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor() {\n        super();\n        this.data = loadSystemData();\n        let saveTimeout = null;\n        this.on('dataChanged', () => {\n            if (saveTimeout) clearTimeout(saveTimeout);\n            saveTimeout = setTimeout(() => {\n                saveSystemData(this.data);\n                saveTimeout = null;\n            }, 500);\n        });\n    }\n\n    /**\n     * Initializes the DataManager with data\n     * @param {Object} data - The initial system data\n     */\n    initialize(data) {\n        if (data && data.systems && data.dependencies) {\n            this.data = data;\n        }\n        this.emit('dataChanged', this.data);\n    }\n\n    /**\n     * Returns the current system data\n     * @returns {Object} The system data\n     */\n    getData() {\n        return this.data;\n    }\n\n    /**\n     * Completely updates the system data\n     * @param {Object} newData - The new system data\n     */\n    setData(newData, notify = true) {\n        if (newData && newData.systems && newData.dependencies) {\n            this.data = newData;\n            notify && this.emit('dataChanged', this.data);\n        }\n    }\n\n    /**\n     * Completely removes the system data\n     * @param {Object} newData - The new system data\n     */\n    clearData(notify = true) {\n        this.setData({ systems: [], dependencies: [] }, notify);\n    }\n\n    /**\n     * Returns all unique groups present in the system data\n     * @returns {Array} Array of unique group names\n     */\n    getAllGroups() {\n        const groups = new Set();\n\n        this.data.systems.forEach(system => {\n            if (Array.isArray(system.groups)) {\n                system.groups.forEach(group => {\n                    if (group && group.trim() !== '') {\n                        groups.add(group);\n                    }\n                });\n            } else if (system.group && typeof system.group === 'string') {\n                groups.add(system.group);\n            }\n        });\n\n        return Array.from(groups).sort();\n    }\n\n    /**\n     * Helper function to ensure each system has a 'groups' array\n     * Converts single 'group' strings to arrays if necessary (backward compatibility)\n     * @param {Object} system - The system to check\n     */\n    ensureGroupsArray(system) {\n        // Case 1: system already has a groups array -> do nothing\n        if (Array.isArray(system.groups)) {\n            // Remove empty values and duplicates\n            system.groups = system.groups\n                .filter(group => group && group.trim() !== '')\n                .filter((group, index, self) => self.indexOf(group) === index);\n\n            // Remove legacy group field if present\n            delete system.group;\n            return;\n        }\n\n        // Case 2: system has a group field -> convert to groups array\n        if (typeof system.group === 'string' && system.group.trim() !== '') {\n            // If group is a comma-separated string, split\n            if (system.group.includes(',')) {\n                system.groups = system.group.split(',')\n                    .map(g => g.trim())\n                    .filter(g => g !== '');\n            } else {\n                system.groups = [system.group];\n            }\n            delete system.group;\n            return;\n        }\n\n        // Case 3: system has neither group nor groups\n        if (!system.groups) {\n            system.groups = [];\n            delete system.group; // Ensure no empty group field exists\n        }\n    }\n\n    /**\n     * Adds a new system\n     * @param {Object} system - The new system\n     * @returns {string} The ID of the added system\n     */\n    addSystem(system, notify = true) {\n        if (!system.id) {\n            system.id = this.generateUniqueId();\n        }\n\n        // Compatibility handling for converting 'group' to 'groups'\n        this.ensureGroupsArray(system);\n\n        this.data.systems.push(system);\n        notify && this.emit('dataChanged', this.data);\n        return system.id;\n    }\n\n    /**\n     * Updates an existing system\n     * @param {Object} updatedSystem - The updated system\n     * @returns {boolean} True if the system was found and updated\n     */\n    updateSystem(updatedSystem, notify = true) {\n        const index = this.data.systems.findIndex(sys => sys.id === updatedSystem.id);\n        if (index !== -1) {\n            // Compatibility handling for converting 'group' to 'groups'\n            this.ensureGroupsArray(updatedSystem);\n\n            this.data.systems[index] = updatedSystem;\n            notify && this.emit('dataChanged', this.data);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Deletes a system and associated dependencies\n     * @param {string} systemId - The ID of the system to delete\n     * @returns {boolean} True if the system was found and deleted\n     */\n    deleteSystem(systemId, notify = true) {\n        const systemIndex = this.data.systems.findIndex(sys => sys.id === systemId);\n        if (systemIndex === -1) return false;\n\n        // Delete system\n        this.data.systems.splice(systemIndex, 1);\n\n        // Delete associated dependencies\n        this.data.dependencies = this.data.dependencies.filter(\n            dep => dep.source !== systemId && dep.target !== systemId\n        );\n\n        notify && this.emit('dataChanged', this.data);\n        return true;\n    }\n\n    /**\n     * Adds a new dependency\n     * @param {Object} dependency - The new dependency\n     * @returns {boolean} True on success\n     */\n    addDependency(dependency, notify = true) {\n        // Check if source and target systems exist\n        const sourceExists = this.data.systems.some(sys => sys.id === dependency.source);\n        const targetExists = this.data.systems.some(sys => sys.id === dependency.target);\n\n        if (!sourceExists || !targetExists) return false;\n\n        this.data.dependencies.push(dependency);\n        notify && this.emit('dataChanged', this.data);\n        return true;\n    }\n\n    /**\n     * Deletes a dependency\n     * @param {Object} dependency - The dependency to delete (must contain source and target)\n     * @returns {boolean} True if the dependency was found and deleted\n     */\n    deleteDependency(dependency, notify = true) {\n        const index = this.data.dependencies.findIndex(\n            dep => dep.source === dependency.source && dep.target === dependency.target\n        );\n\n        if (index !== -1) {\n            this.data.dependencies.splice(index, 1);\n            notify && this.emit('dataChanged', this.data);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Applies a batch of changes at once and triggers only a single update event\n     * @param {Object} differences - Object with added, modified and removed arrays for systems and dependencies\n     * @returns {boolean} True on success\n     */\n    applyBatch(differences) {\n        if (!differences) return false;\n\n        try {\n            // Remove systems\n            if (differences.removed && differences.removed.systems) {\n                differences.removed.systems.forEach(system => {\n                    this.deleteSystem(system.id, false);\n                });\n            }\n\n            // Update systems\n            if (differences.modified && differences.modified.systems) {\n                differences.modified.systems.forEach(modifiedSystem => {\n                    this.updateSystem(modifiedSystem, false);\n                });\n            }\n\n            // Add new systems\n            if (differences.added && differences.added.systems) {\n                differences.added.systems.forEach(newSystem => {\n                    this.addSystem(newSystem, false);\n                });\n            }\n\n            // Remove dependencies\n            if (differences.removed && differences.removed.dependencies) {\n                differences.removed.dependencies.forEach(dependency => {\n                    this.deleteDependency(dependency, false);\n                });\n            }\n\n            // Update dependencies\n            if (differences.modified && differences.modified.dependencies) {\n                differences.modified.dependencies.forEach(modifiedDep => {\n                    // Delete and re-add, since updateDependency does not exist\n                    this.deleteDependency(modifiedDep, false);\n                    this.addDependency(modifiedDep, false);\n                });\n            }\n\n            // Add new dependencies\n            if (differences.added && differences.added.dependencies) {\n                differences.added.dependencies.forEach(newDep => {\n                    this.addDependency(newDep, false);\n                });\n            }\n\n            // Notify all listeners only once\n            this.emit('dataChanged', this.data);\n\n            return true;\n        } catch (error) {\n            console.error(\"Error applying batch changes:\", error);\n            return false;\n        }\n    }\n\n    /**\n     * Generates a unique ID\n     * @returns {string} A unique ID\n     */\n    generateUniqueId() {\n        const timestamp = new Date().getTime();\n        const randomPart = Math.floor(Math.random() * 10000);\n        return `sys_${timestamp}_${randomPart}`;\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/data-manager.js?");

/***/ }),

/***/ "./src/dependency-manager.js":
/*!***********************************!*\
  !*** ./src/dependency-manager.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DependencyManager: () => (/* binding */ DependencyManager)\n/* harmony export */ });\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities.js */ \"./src/utilities.js\");\n\n\n/**\n * DependencyManager - Manages adding and removing dependencies\n */\nclass DependencyManager {\n    constructor() {\n        this.initialized = false;\n        this.isConnectionModeActive = false;\n        this.sourceSystem = null;\n        this.tempLink = null;\n        this.mousePosition = { x: 0, y: 0 };\n        \n        // Default values for new connections\n        this.defaultConnectionType = \"data\";\n        this.defaultConnectionProtocol = \"API\";\n    }\n\n    /**\n     * Initializes the DependencyManager\n     */\n    initialize(dataManager, visualizer) {\n        if (this.initialized) return;\n        \n        this.dataManager = dataManager;\n        this.visualizer = visualizer;\n        \n        // Event listener for connection mode toggle\n        document.getElementById('toggle-connection-mode').addEventListener('click', () => {\n            this.toggleConnectionMode();\n        });\n        \n        // Event listener for data changes to keep connection mode active\n        this.dataManager.on('dataChanged', () => {\n            if (this.isConnectionModeActive) {\n                // Short delay to wait for UI update\n                setTimeout(() => {\n                    this.setupConnectionDrag();\n                }, 100);\n            }\n        });\n        \n        this.initialized = true;\n        console.log('DependencyManager has been initialized');\n    }\n\n    /**\n     * Toggles the connection mode on/off\n     */\n    toggleConnectionMode() {\n        this.isConnectionModeActive = !this.isConnectionModeActive;\n        const toggleButton = document.getElementById('toggle-connection-mode');\n        \n        if (this.isConnectionModeActive) {\n            document.body.classList.add('connection-mode');\n            toggleButton.classList.add('active');\n            toggleButton.title = 'Exit connection mode';\n            toggleButton.querySelector('i').className = 'bi bi-link-45deg';\n            \n            // Disable default drag and enable connection drag instead\n            this.visualizer.disableDrag(); // Set flag\n            this.setupConnectionDrag();\n            \n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Connection mode enabled: Drag from one system to another', 'info');\n        } else {\n            document.body.classList.remove('connection-mode');\n            toggleButton.classList.remove('active');\n            toggleButton.title = 'Connection mode';\n            toggleButton.querySelector('i').className = 'bi bi-link';\n            \n            // Remove connection drag and restore default drag\n            this.removeConnectionDrag();\n            this.visualizer.enableDrag(); // Reset flag\n            \n            // Cleanup\n            this.resetConnectionState();\n            \n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Connection mode disabled', 'info');\n        }\n    }\n\n    /**\n     * Sets up the drag mechanism for connections\n     */\n    setupConnectionDrag() {\n        if (!this.visualizer.nodeElements) return;\n        \n        // Remove connection drag if present\n        this.removeConnectionDrag();\n        \n        // Define drag function for connections\n        const connectionDrag = d3.drag()\n            .on(\"start\", (event, d) => this.handleDragStart(event, d))\n            .on(\"drag\", (event, d) => this.handleDragMove(event, d))\n            .on(\"end\", (event, d) => this.handleDragEnd(event, d));\n        \n        // Apply to nodes\n        this.visualizer.nodeElements.call(connectionDrag);\n    }\n    \n    /**\n     * Removes the connection drag mechanism\n     */\n    removeConnectionDrag() {\n        if (!this.visualizer.nodeElements) return;\n        \n        // Remove connection drag\n        this.visualizer.nodeElements.on('.drag', null);\n    }\n\n    /**\n     * Handles the start of a connection drag\n     */\n    handleDragStart(event, d) {\n        if (!this.isConnectionModeActive) return;\n        \n        // Set source system\n        this.sourceSystem = d;\n        \n        // Visually mark\n        d3.select(event.sourceEvent.target.closest('.node')).classed('connection-source', true);\n        \n        // Create temporary connection line\n        this.createTempLink(d);\n    }\n\n    /**\n     * Handles movement during a connection drag\n     */\n    handleDragMove(event, d) {\n        if (!this.isConnectionModeActive || !this.tempLink) return;\n        \n        // Update temporary line\n        this.tempLink.attr('d', `M${this.sourceSystem.x},${this.sourceSystem.y} L${event.x},${event.y}`);\n    }\n\n    /**\n     * Handles the end of a connection drag\n     */\n    handleDragEnd(event, d) {\n        if (!this.isConnectionModeActive || !this.sourceSystem) return;\n        \n        // Check if released over another node\n        const targetElement = document.elementFromPoint(event.sourceEvent.clientX, event.sourceEvent.clientY);\n        const targetNode = targetElement ? targetElement.closest('.node') : null;\n        \n        if (targetNode) {\n            const targetSystemId = targetNode.getAttribute('data-system-id');\n            const targetSystem = this.dataManager.getData().systems.find(sys => sys.id === targetSystemId);\n            \n            if (targetSystem && targetSystem.id !== this.sourceSystem.id) {\n                // Create connection with default values\n                this.createConnection(this.sourceSystem, targetSystem);\n            } else if (targetSystem && targetSystem.id === this.sourceSystem.id) {\n                // Same node used as target\n                (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Source and target system cannot be identical.', 'warning');\n            }\n        }\n        \n        // Cleanup\n        this.resetConnectionState();\n    }\n\n    /**\n     * Creates a temporary connection line from the source system\n     */\n    createTempLink(sourceSystem) {\n        // Create temporary line\n        this.tempLink = this.visualizer.svg.select('g').append('path')\n            .attr('class', 'temp-link')\n            .attr('d', `M${sourceSystem.x},${sourceSystem.y} L${sourceSystem.x},${sourceSystem.y}`);\n    }\n\n    /**\n     * Creates a new connection with default values\n     */\n    createConnection(sourceSystem, targetSystem) {\n        // Create new dependency with default values\n        const newDependency = {\n            source: sourceSystem.id,\n            target: targetSystem.id,\n            type: this.defaultConnectionType,\n            description: `Connection from ${sourceSystem.name} to ${targetSystem.name}`,\n            protocol: this.defaultConnectionProtocol\n        };\n        \n        // Add dependency via DataManager\n        const success = this.dataManager.addDependency(newDependency);\n        \n        if (success) {\n            // Success message\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)(\n                `Connection from \"${sourceSystem.name}\" to \"${targetSystem.name}\" has been created`,\n                'success'\n            );\n        } else {\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Error creating connection', 'danger');\n        }\n    }\n\n    /**\n     * Resets the connection state\n     */\n    resetConnectionState() {\n        // Reset source system\n        if (this.sourceSystem) {\n            d3.selectAll('.node').classed('connection-source', false);\n            this.sourceSystem = null;\n        }\n        \n        // Remove temporary line\n        if (this.tempLink) {\n            this.tempLink.remove();\n            this.tempLink = null;\n        }\n    }\n\n    /**\n     * Shows the delete control for a connection\n     */\n    showLinkControls(event, linkData) {\n        // Do not show controls in connection mode\n        if (this.isConnectionModeActive) return;\n        \n        // Remove existing controls\n        this.hideLinkControls();\n        \n        // Create new controls\n        const controls = document.createElement('div');\n        controls.className = 'link-controls';\n        controls.innerHTML = `\n            <button class=\"link-delete-btn\" title=\"Delete connection\">\n                <i class=\"bi bi-trash\"></i>\n            </button>\n        `;\n        \n        // Set position\n        controls.style.left = `${event.pageX}px`;\n        controls.style.top = `${event.pageY}px`;\n        \n        // Add to DOM\n        document.body.appendChild(controls);\n        \n        // Store link data in attribute\n        controls.setAttribute('data-source', linkData.source.id || linkData.source);\n        controls.setAttribute('data-target', linkData.target.id || linkData.target);\n        \n        // Event listener for delete button\n        controls.querySelector('.link-delete-btn').addEventListener('click', () => {\n            this.showDeleteDependencyConfirmation(linkData);\n            this.hideLinkControls();\n        });\n        \n        // Show controls\n        controls.style.display = 'block';\n        \n        // Click outside to close\n        document.addEventListener('click', (e) => {\n            if (!controls.contains(e.target) && e.target !== event.target) {\n                this.hideLinkControls();\n            }\n        }, { once: true });\n    }\n\n    /**\n     * Hides the link controls\n     */\n    hideLinkControls() {\n        const existingControls = document.querySelector('.link-controls');\n        if (existingControls) {\n            existingControls.remove();\n        }\n    }\n\n    /**\n     * Shows a confirmation prompt to delete a dependency\n     */\n    showDeleteDependencyConfirmation(linkData) {\n        const sourceId = linkData.source.id || linkData.source;\n        const targetId = linkData.target.id || linkData.target;\n        \n        const sourceSystem = this.dataManager.getData().systems.find(sys => sys.id === sourceId);\n        const targetSystem = this.dataManager.getData().systems.find(sys => sys.id === targetId);\n        \n        if (!sourceSystem || !targetSystem) return;\n        \n        // Confirmation message\n        const message = `Do you really want to delete the connection from \"${sourceSystem.name}\" to \"${targetSystem.name}\"?`;\n        \n        document.getElementById('confirm-message').innerHTML = message;\n        document.getElementById('confirm-action').setAttribute('data-action', 'delete-dependency');\n        document.getElementById('confirm-action').setAttribute('data-source', sourceId);\n        document.getElementById('confirm-action').setAttribute('data-target', targetId);\n        \n        // Show modal\n        const modal = new bootstrap.Modal(document.getElementById('confirm-modal'));\n        modal.show();\n    }\n\n    /**\n     * Deletes a dependency\n     */\n    deleteDependency(sourceId, targetId) {\n        // Find systems for notification\n        const sourceSystem = this.dataManager.getData().systems.find(sys => sys.id === sourceId);\n        const targetSystem = this.dataManager.getData().systems.find(sys => sys.id === targetId);\n        \n        if (!sourceSystem || !targetSystem) return;\n        \n        // Delete dependency via DataManager\n        const success = this.dataManager.deleteDependency({\n            source: sourceId,\n            target: targetId\n        });\n        \n        if (success) {\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)(\n                `Connection from \"${sourceSystem.name}\" to \"${targetSystem.name}\" has been deleted`,\n                'success'\n            );\n        } else {\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Error deleting connection', 'danger');\n        }\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/dependency-manager.js?");

/***/ }),

/***/ "./src/event-emitter.js":
/*!******************************!*\
  !*** ./src/event-emitter.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter)\n/* harmony export */ });\n/**\n * A simple EventEmitter class for managing custom events.\n *\n * @class\n * @example\n * const emitter = new EventEmitter();\n * emitter.on('event', data => console.log(data));\n * emitter.emit('event', { foo: 'bar' });\n */\nclass EventEmitter {\n    /**\n     * Initializes the EventEmitter instance.\n     * @constructor\n     */\n    constructor() {\n        this.events = {};\n    }\n\n    /**\n     * Registers a callback for the specified event.\n     * @param {string} eventName - The name of the event.\n     * @param {Function} callback - The callback function to register.\n     * @returns {EventEmitter} The instance for chaining.\n     */\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(callback);\n        return this; // for chaining\n    }\n\n    /**\n     * Removes a callback for the specified event.\n     * If no callback is provided, removes all callbacks for the event.\n     * @param {string} eventName - The name of the event.\n     * @param {Function} [callback] - The callback function to remove.\n     * @returns {EventEmitter} The instance for chaining.\n     */\n    off(eventName, callback) {\n        if (!this.events[eventName]) return this;\n\n        if (callback) {\n            this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);\n        } else {\n            delete this.events[eventName];\n        }\n        return this;\n    }\n\n    /**\n     * Emits an event, calling all registered callbacks with the provided arguments.\n     * @param {string} eventName - The name of the event.\n     * @param {...any} args - Arguments to pass to the callbacks.\n     * @returns {boolean} True if the event had listeners, false otherwise.\n     */\n    emit(eventName, ...args) {\n        if (!this.events[eventName]) return false;\n\n        this.events[eventName].forEach(callback => {\n            callback(...args);\n        });\n        return true;\n    }\n\n    /**\n     * Registers a callback that is called at most once for the specified event.\n     * @param {string} eventName - The name of the event.\n     * @param {Function} callback - The callback function to register.\n     * @returns {EventEmitter} The instance for chaining.\n     */\n    once(eventName, callback) {\n        const onceCallback = (...args) => {\n            this.off(eventName, onceCallback);\n            callback(...args);\n        };\n\n        return this.on(eventName, onceCallback);\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/event-emitter.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _data_manager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data-manager.js */ \"./src/data-manager.js\");\n/* harmony import */ var _visualizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./visualizer.js */ \"./src/visualizer.js\");\n/* harmony import */ var _dependency_manager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dependency-manager.js */ \"./src/dependency-manager.js\");\n/* harmony import */ var _system_manager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./system-manager.js */ \"./src/system-manager.js\");\n/* harmony import */ var _llm_integration_manager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./llm-integration-manager.js */ \"./src/llm-integration-manager.js\");\n/* harmony import */ var _data_loader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data-loader.js */ \"./src/data-loader.js\");\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utilities.js */ \"./src/utilities.js\");\n\n\n\n\n\n\n\n\ndocument.addEventListener('DOMContentLoaded', async () => {\n    // Systemdaten laden und DataManager initialisieren\n    const dataManager = new _data_manager_js__WEBPACK_IMPORTED_MODULE_0__.DataManager();\n    console.log('Systemdaten geladen:', dataManager.data);\n\n    // Visualizer erstellen und mit DataManager verknüpfen\n    const visualizer = new _visualizer_js__WEBPACK_IMPORTED_MODULE_1__.SystemVisualizer('visualization-container', dataManager);\n    visualizer.initialize();\n\n    // DependencyManager initialisieren\n    const dependencyManager = new _dependency_manager_js__WEBPACK_IMPORTED_MODULE_2__.DependencyManager();\n    dependencyManager.initialize(dataManager, visualizer);\n\n    // Visualizer Dependency-Klick an Dependency-Manager weitergeben übergeben\n    visualizer.on('dependencyClick', (ref) => {\n        const { event, data } = ref;\n        dependencyManager.showLinkControls(event, data)\n    });\n    window.vis = visualizer;\n\n    // SystemManager initialisieren\n    const systemManager = new _system_manager_js__WEBPACK_IMPORTED_MODULE_3__.SystemManager();\n    systemManager.initialize(dataManager);\n\n    // LLM-Integration initialisieren (NEU)\n    const llmManager = new _llm_integration_manager_js__WEBPACK_IMPORTED_MODULE_4__.LlmIntegrationManager({\n        apiKey: (await (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.retrieveAndDecrypt)(\"llmApiKey\")) || \"\", // API-Key aus localStorage\n        llmType: localStorage.getItem(\"llmType\") || \"\", // claude, openai, custom\n        llmModel: localStorage.getItem(\"llmModel\") || \"\", // Modell je nach LLM-Typ, e.g. claude-3-7-sonnet-20250219\n        llmSystemPrompt: localStorage.getItem(\"llmSystemPrompt\") || \"\", // Modell je nach LLM-Typ, e.g. claude-3-7-sonnet-20250219\n        llmPromptPrefix: localStorage.getItem(\"llmPromptPrefix\") || \"\", // Modell je nach LLM-Typ, e.g. claude-3-7-sonnet-20250219\n        // llmUrl: \"https://deine-custom-api-url.com\", // Nur für custom-Typ\n    });\n    llmManager.initialize(dataManager);\n\n    // Chat-Interface einrichten (NEU)\n    setupLlmChatInterface(llmManager);\n\n    window.llm = llmManager; // Optional: Für Zugriff über die Konsole\n\n    setupGroupsUI(systemManager);\n\n    // Toggle-Buttons für die Overlays\n    document.getElementById('toggle-search').addEventListener('click', () => toggleOverlay('search-panel'));\n    document.getElementById('toggle-filters').addEventListener('click', () => toggleOverlay('filter-panel'));\n    document.getElementById('toggle-legend').addEventListener('click', () => toggleOverlay('legend-panel'));\n\n    // Event-Listener für den Upload-Button\n    document.getElementById('upload-data').addEventListener('click', () => (0,_data_loader_js__WEBPACK_IMPORTED_MODULE_5__.uploadSystemData)(dataManager));\n\n    // Event-Listener für den Download-Button\n    document.getElementById('download-data').addEventListener('click', () => (0,_data_loader_js__WEBPACK_IMPORTED_MODULE_5__.downloadSystemData)(dataManager));\n\n    // Event-Listener für den Add-System-Button\n    document.getElementById('add-system').addEventListener('click', () => systemManager.showSystemModal());\n\n    // \"System speichern\"-Button Event im Modal\n    document.getElementById('save-system').addEventListener('click', () => systemManager.saveSystem());\n\n    // \"System speichern\"-Button Event im Modal\n    document.getElementById('clear-data').addEventListener('click', () => {\n        // Öffne das Reset-Modal\n        const resetModal = new bootstrap.Modal(document.getElementById('reset-modal'));\n        resetModal.show();\n\n        // Handler entfernen, um Mehrfachbindung zu vermeiden\n        document.getElementById('reset-modal-llm-action').onclick = null;\n        document.getElementById('reset-modal-data-action').onclick = null;\n        document.getElementById('reset-modal-all-action').onclick = null;\n\n        // Nur LLM-Konfiguration zurücksetzen\n        document.getElementById('reset-modal-llm-action').onclick = () => {\n            localStorage.removeItem(\"llmType\");\n            localStorage.removeItem(\"llmModel\");\n            localStorage.removeItem(\"llmSystemPrompt\");\n            localStorage.removeItem(\"llmPromptPrefix\");\n            localStorage.removeItem(\"llmApiKey\", \"\"); // Leeren Key speichern\n            llmManager.updateConfig();\n            document.getElementById('llm-chat-container').style.display = 'none';\n            resetModal.hide();\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.showNotification)(\"LLM-Konfiguration wurde zurückgesetzt.\", \"info\");\n        };\n\n        // Nur Daten zurücksetzen\n        document.getElementById('reset-modal-data-action').onclick = () => {\n            dataManager.clearData();\n            visualizer.nodeCache.clear(true);\n            resetModal.hide();\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.showNotification)(\"Daten wurden zurückgesetzt.\", \"info\");\n        };\n\n        // Alles zurücksetzen\n        document.getElementById('reset-modal-all-action').onclick = () => {\n            dataManager.clearData();\n            visualizer.nodeCache.clear(true);\n            localStorage.clear();\n            llmManager.updateConfig();\n            document.getElementById('llm-chat-container').style.display = 'none';\n            resetModal.hide();\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.showNotification)(\"Alle Daten und Konfigurationen wurden gelöscht.\", \"info\");\n        };\n    });\n\n    // Event-Handler für Bearbeiten- und Löschen-Buttons in der Detailansicht\n    document.querySelector('.edit-system-btn').addEventListener('click', () => {\n        const systemId = document.getElementById('detail-title').getAttribute('data-system-id');\n        if (systemId) {\n            systemManager.showSystemModal(systemId);\n        }\n    });\n\n    document.querySelector('.delete-system-btn').addEventListener('click', () => {\n        const systemId = document.getElementById('detail-title').getAttribute('data-system-id');\n        if (systemId) {\n            systemManager.showDeleteConfirmation(systemId);\n        }\n    });\n\n    // Event-Handler für Bestätigungs-Modal\n    document.getElementById('confirm-action').addEventListener('click', () => {\n        const confirmAction = document.getElementById('confirm-action').getAttribute('data-action');\n        const confirmId = document.getElementById('confirm-action').getAttribute('data-id');\n\n        if (confirmAction === 'delete-system' && confirmId) {\n            systemManager.deleteSystem(confirmId);\n            bootstrap.Modal.getInstance(document.getElementById('confirm-modal')).hide();\n        } else if (confirmAction === 'delete-dependency') {\n            const sourceId = document.getElementById('confirm-action').getAttribute('data-source');\n            const targetId = document.getElementById('confirm-action').getAttribute('data-target');\n            if (sourceId && targetId) {\n                dependencyManager.deleteDependency(sourceId, targetId);\n                bootstrap.Modal.getInstance(document.getElementById('confirm-modal')).hide();\n            }\n        }\n    });\n\n    document.querySelector('.toggle-fix-btn').addEventListener('click', () => {\n        const systemId = document.getElementById('detail-title').getAttribute('data-system-id');\n        if (systemId) {\n            const isNowFixed = visualizer.toggleNodeFixed(systemId);\n        }\n    });\n\n    visualizer.on('toggleFixed', (data) => {\n        const systemId = document.getElementById('detail-title').getAttribute('data-system-id');\n        const { id, state } = data;\n\n        if (id !== systemId) return;\n\n        const toggleButton = document.querySelector('.toggle-fix-btn');\n        if (state) {\n            toggleButton.classList.add('active');\n            toggleButton.title = 'Position freigeben';\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.showNotification)('Position wurde fixiert', 'info');\n        } else {\n            toggleButton.classList.remove('active');\n            toggleButton.title = 'Position fixieren';\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.showNotification)('Position wurde freigegeben', 'info');\n        }\n    });\n\n    // Close-Buttons in den Overlays\n    document.querySelectorAll('.close-overlay').forEach(btn => {\n        btn.addEventListener('click', () => {\n            const targetId = btn.getAttribute('data-close-target');\n            document.getElementById(targetId).classList.remove('active');\n        });\n    });\n\n    // Overlay-Funktion\n    function toggleOverlay(id) {\n        const panel = document.getElementById(id);\n\n        // Alle anderen Overlays schließen\n        document.querySelectorAll('.overlay').forEach(overlay => {\n            if (overlay.id !== id) overlay.classList.remove('active');\n        });\n\n        // Ausgewähltes Overlay umschalten\n        panel.classList.toggle('active');\n    }\n});\nfunction setupGroupsUI(systemManager) {\n    const groupInput = document.getElementById('system-groups-input');\n    const addButton = document.getElementById('add-group-btn');\n\n    // Event-Listener für das Hinzufügen von Gruppen mit dem Button\n    addButton.addEventListener('click', () => {\n        const value = groupInput.value.trim();\n        if (value) {\n            // Wenn Kommas enthalten sind, mehrere Gruppen gleichzeitig hinzufügen\n            if (value.includes(',')) {\n                const groups = value.split(',').map(g => g.trim()).filter(g => g !== '');\n                groups.forEach(group => systemManager.addGroupBadge(group));\n            } else {\n                systemManager.addGroupBadge(value);\n            }\n            groupInput.value = '';\n        }\n    });\n\n    // Event-Listener für das Hinzufügen von Gruppen mit Enter\n    groupInput.addEventListener('keydown', (event) => {\n        if (event.key === 'Enter') {\n            event.preventDefault();\n            addButton.click();\n        }\n    });\n\n    // Auto-Vervollständigung bei Komma\n    groupInput.addEventListener('input', () => {\n        const value = groupInput.value;\n        if (value.endsWith(',')) {\n            const newGroup = value.slice(0, -1).trim();\n            if (newGroup) {\n                systemManager.addGroupBadge(newGroup);\n                groupInput.value = '';\n            }\n        }\n    });\n}\n// Diese Funktion nach der LlmIntegrationManager-Initialisierung aufrufen\nfunction setupLlmChatInterface(llmManager) {\n    // UI-Elemente\n    const chatContainer = document.getElementById('llm-chat-container');\n    const chatMessages = document.getElementById('llm-chat-messages');\n    const chatInput = document.getElementById('llm-chat-input');\n    const sendButton = document.getElementById('llm-chat-send');\n    const closeButton = document.getElementById('llm-chat-close');\n    const loadingIndicator = document.getElementById('llm-chat-loading');\n    const toggleLlmChat = document.getElementById('toggle-llm-chat');\n    const saveLlmConfig = document.getElementById('save-llm-config');\n    const cancelLlmConfig = document.getElementById('cancel-llm-config');\n\n    function isVisible() {\n        return !chatContainer.classList.contains('active');\n    }\n\n    // Toggle-Button zur Controls-Leiste hinzufügen\n    const controlsOverlay = document.querySelector('.controls-overlay .btn-group');\n    if (controlsOverlay) {\n        // Event-Listener für den Toggle-Button\n        toggleLlmChat.addEventListener('click', toggleChat);\n    }\n\n    const hiddenKeyIfNotEmpty = \"-----hidden-----\";\n    const configModal = new bootstrap.Modal(document.getElementById('llm-config-modal'));\n    function changeLlmConfig() {\n        // Felder mit gespeicherter Konfiguration befüllen\n        document.getElementById('llm-type').value = localStorage.getItem(\"llmType\") || \"claude\";\n        document.getElementById('llm-api-key').value = localStorage.getItem(\"llmApiKey\") ? hiddenKeyIfNotEmpty : \"\";\n        document.getElementById('llm-model').value = localStorage.getItem(\"llmModel\") || \"\";\n        document.getElementById('llm-system-prompt').value = localStorage.getItem(\"llmSystemPrompt\") || llmManager.getDefaultSystemPrompt();\n        document.getElementById('llm-prompt-prefix').value = localStorage.getItem(\"llmPromptPrefix\") || llmManager.getDefaultPromptPrefix();\n        configModal.show();\n    }\n\n    function checkIfConfiguratedOrCloseChat() {\n        if (!llmManager.isConfigurated()) {\n            if (isVisible()) {\n                chatContainer.style.display = 'none';\n                toggleLlmChat.classList.remove('active');\n                (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.showNotification)(\"Bitte konfiguriere den Chat-Assistenten.\", \"warning\");\n            }\n            return false;\n        }\n        return true;\n    }\n\n    if (!llmManager.isConfigurated()) {\n        chatContainer.style.display = 'none';\n    }\n\n    function saveConfig() {\n        const llmType = document.getElementById('llm-type').value;\n        const llmApiKey = document.getElementById('llm-api-key').value;\n        const llmModel = document.getElementById('llm-model').value;\n        const llmSystemPrompt = document.getElementById('llm-system-prompt').value;\n        const llmPromptPrefix = document.getElementById('llm-prompt-prefix').value;\n\n        // Konfiguration speichern\n        localStorage.setItem(\"llmType\", llmType);\n        if (llmApiKey !== hiddenKeyIfNotEmpty) {\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.encryptAndStore)(\"llmApiKey\", llmApiKey).then(() => {\n                console.log(\"API-Key gespeichert\");\n            }).catch((error) => {\n                console.error(\"Fehler beim Speichern des API-Keys:\", error);\n            });\n        }\n        localStorage.setItem(\"llmModel\", llmModel);\n        localStorage.setItem(\"llmSystemPrompt\", llmSystemPrompt);\n        localStorage.setItem(\"llmPromptPrefix\", llmPromptPrefix);\n        llmManager.updateConfig(llmType, llmModel, llmApiKey, llmSystemPrompt, llmPromptPrefix);\n        if (checkIfConfiguratedOrCloseChat()) {\n            chatContainer.style.display = 'flex';\n            if (isVisible()) {\n                chatInput.focus();\n                if (chatMessages.children.length === 0) {\n                    addSystemMessage(\"Wie kann ich dir bei der Verwaltung deiner IT-Infrastruktur helfen? Du kannst mir Änderungen beschreiben, und ich aktualisiere das Modell für dich.\");\n                }\n            }\n        }\n        configModal.hide();\n    }\n\n    document.getElementById('llm-chat-settings').addEventListener('click', changeLlmConfig);\n    document.querySelector('#llm-config-modal .btn-close').addEventListener('click', () => {\n        checkIfConfiguratedOrCloseChat();\n    });\n    cancelLlmConfig.addEventListener('click', () => {\n        checkIfConfiguratedOrCloseChat();\n    });\n    saveLlmConfig.addEventListener('click', () => {\n        saveConfig();\n    });\n\n    // Chat öffnen/schließen\n    function toggleChat() {\n        const wasVisible = isVisible();\n        if (wasVisible) {\n            chatContainer.classList.add('active');\n            toggleLlmChat.classList.remove('active');\n        } else {\n            chatContainer.classList.remove('active');\n            toggleLlmChat.classList.add('active');\n        }\n\n        if (!wasVisible) {\n            if (!llmManager.isConfigurated()) {\n                changeLlmConfig();\n            } else {\n                chatInput.focus();\n\n                // Willkommensnachricht anzeigen, wenn der Chat leer ist\n                if (chatMessages.children.length === 0) {\n                    addSystemMessage(\"Wie kann ich dir bei der Verwaltung deiner IT-Infrastruktur helfen? Du kannst mir Änderungen beschreiben, und ich aktualisiere das Modell für dich.\");\n                }\n            }\n        }\n    }\n\n    chatInput.addEventListener('focus', () => {\n        if (chatContainer.classList.contains('active')) {\n            chatContainer.classList.remove('active');\n            if (!llmManager.isConfigurated()) {\n                changeLlmConfig();\n            } else {\n                // Willkommensnachricht anzeigen, wenn der Chat leer ist\n                if (chatMessages.children.length === 0) {\n                    addSystemMessage(\"Wie kann ich dir bei der Verwaltung deiner IT-Infrastruktur helfen? Du kannst mir Änderungen beschreiben, und ich aktualisiere das Modell für dich.\");\n                }\n            }\n        }\n    });\n\n    // Let Chat-Input growth (chatInput)\n    chatInput.addEventListener('input', () => {\n        chatInput.style.height = 'auto';\n        const maxRows = 3;\n        const lines = chatInput.value.split('\\n').length;\n        const rows = Math.min(lines, maxRows);\n        chatInput.rows = rows;\n    });\n\n    // Close-Button\n    closeButton.addEventListener('click', () => {\n        chatContainer.classList.add('active');\n        document.getElementById('toggle-llm-chat').classList.remove('active');\n    });\n\n    // Nachrichten senden\n    sendButton.addEventListener('click', sendMessage);\n\n    // Enter-Taste zum Senden (ohne Shift)\n    chatInput.addEventListener('keydown', (event) => {\n        if (event.key === 'Enter' && !event.shiftKey) {\n            event.preventDefault();\n            sendMessage();\n        }\n    });\n\n    // Nachricht senden und LLM-Antwort verarbeiten\n    async function sendMessage() {\n        const userInput = chatInput.value.trim();\n        if (!userInput) return;\n\n        // Benutzereingabe anzeigen\n        addUserMessage(userInput);\n        chatInput.value = '';\n\n        // Loading-Indikator anzeigen\n        loadingIndicator.style.display = 'flex';\n\n        // Aktuelle Nachricht im UI zusammenbauen\n        let currentAssistantMessage = '';\n        const messageElement = addAssistantMessage('');\n\n        // LLM-Anfrage verarbeiten\n        let currentResult = \"\";\n        const result = await llmManager.processUserInput(userInput, (token) => {\n            currentResult += token;\n            messageElement.innerHTML = marked ? marked.parse(currentResult) : currentResult;\n        });\n        console.log(result);\n\n        // Loading-Indikator ausblenden\n        loadingIndicator.style.display = 'none';\n\n        // Antwort anzeigen\n        messageElement.innerHTML = marked ? marked.parse(result.originalResponse) : result.originalResponse;\n\n        // Bei YAML-Antwort mit Änderungen\n        if (result.success && result.yamlData) {\n            showUpdateConfirmation(result.yamlData, result.differences);\n        }\n    }\n\n    // Zeigt Bestätigungsdialog für Änderungen an\n    function showUpdateConfirmation(newData, differences) {\n        // Nur bestätigen lassen, wenn es Änderungen gibt\n        if (differences.added.systems.length === 0 &&\n            differences.modified.systems.length === 0 &&\n            differences.removed.systems.length === 0 &&\n            differences.added.dependencies.length === 0 &&\n            differences.modified.dependencies.length === 0 &&\n            differences.removed.dependencies.length === 0) {\n            return;\n        }\n\n        // Zusammenfassung der Änderungen erstellen\n        let summaryText = \"Folgende Änderungen wurden erkannt:\\n\\n\";\n\n        // Systeme\n        if (differences.added.systems.length > 0) {\n            summaryText += `➕ ${differences.added.systems.length} neue Systeme: ${differences.added.systems.map(s => s.name).join(', ')}\\n`;\n        }\n        if (differences.modified.systems.length > 0) {\n            summaryText += `✏️ ${differences.modified.systems.length} geänderte Systeme: ${differences.modified.systems.map(s => s.name).join(', ')}\\n`;\n        }\n        if (differences.removed.systems.length > 0) {\n            summaryText += `❌ ${differences.removed.systems.length} entfernte Systeme: ${differences.removed.systems.map(s => s.name).join(', ')}\\n`;\n        }\n\n        // Abhängigkeiten\n        if (differences.added.dependencies.length > 0) {\n            summaryText += `➕ ${differences.added.dependencies.length} neue Verbindungen\\n`;\n        }\n        if (differences.modified.dependencies.length > 0) {\n            summaryText += `✏️ ${differences.modified.dependencies.length} geänderte Verbindungen\\n`;\n        }\n        if (differences.removed.dependencies.length > 0) {\n            summaryText += `❌ ${differences.removed.dependencies.length} entfernte Verbindungen\\n`;\n        }\n\n        // Nachricht erstellen\n        const messageElement = document.createElement('div');\n        messageElement.className = 'llm-chat-message llm-system-message';\n        messageElement.textContent = summaryText;\n\n        // Aktions-Buttons hinzufügen\n        const actionsDiv = document.createElement('div');\n        actionsDiv.className = 'llm-update-actions';\n\n        const applyButton = document.createElement('button');\n        applyButton.className = 'btn btn-primary';\n        applyButton.textContent = 'Änderungen anwenden';\n        applyButton.addEventListener('click', () => {\n            // Daten im DataManager aktualisieren\n            llmManager.applyChanges(differences);\n\n            // Feedback anzeigen\n            addSystemMessage(\"Die Änderungen wurden erfolgreich angewendet.\");\n\n            // Button-Container entfernen\n            messageElement.removeChild(actionsDiv);\n        });\n\n        const cancelButton = document.createElement('button');\n        cancelButton.className = 'btn btn-outline-secondary';\n        cancelButton.textContent = 'Verwerfen';\n        cancelButton.addEventListener('click', () => {\n            addSystemMessage(\"Die Änderungen wurden verworfen.\");\n\n            // Button-Container entfernen\n            messageElement.removeChild(actionsDiv);\n        });\n\n        actionsDiv.appendChild(applyButton);\n        actionsDiv.appendChild(cancelButton);\n        messageElement.appendChild(actionsDiv);\n\n        // Zum Chat hinzufügen\n        chatMessages.appendChild(messageElement);\n        chatMessages.scrollTop = chatMessages.scrollHeight;\n    }\n\n    // Hilfsfunktionen zum Hinzufügen von Nachrichten\n\n    function addUserMessage(message) {\n        const messageElement = document.createElement('div');\n        messageElement.className = 'llm-chat-message llm-user-message';\n        messageElement.textContent = message;\n        chatMessages.appendChild(messageElement);\n        chatMessages.scrollTop = chatMessages.scrollHeight;\n        return messageElement;\n    }\n\n    function addAssistantMessage(message) {\n        const messageElement = document.createElement('div');\n        messageElement.className = 'llm-chat-message llm-assistant-message';\n        messageElement.innerHTML = message;\n        chatMessages.appendChild(messageElement);\n        chatMessages.scrollTop = chatMessages.scrollHeight;\n        return messageElement;\n    }\n\n    function addSystemMessage(message) {\n        const messageElement = document.createElement('div');\n        messageElement.className = 'llm-chat-message llm-system-message';\n        messageElement.textContent = message;\n        chatMessages.appendChild(messageElement);\n        chatMessages.scrollTop = chatMessages.scrollHeight;\n        return messageElement;\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/index.js?");

/***/ }),

/***/ "./src/llm-integration-manager.js":
/*!****************************************!*\
  !*** ./src/llm-integration-manager.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LlmIntegrationManager: () => (/* binding */ LlmIntegrationManager)\n/* harmony export */ });\n/* harmony import */ var _completion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./completion.js */ \"./src/completion.js\");\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utilities.js */ \"./src/utilities.js\");\n\n\n\n/**\n * LlmIntegrationManager - Verwaltet die Integration eines LLM in die Systemvisualisierung\n * Konzentriert sich auf die Kernfunktionalität der LLM-Kommunikation und Datenmodell-Updates\n */\nclass LlmIntegrationManager {\n    constructor(options = {}) {\n        this.dataManager = null;\n        this.initialized = false;\n        this.isProcessing = false;\n\n        // Konfiguration mit Standardwerten\n        this.config = {\n            apiKey: options.apiKey || \"\",\n            llmType: options.llmType || \"\", // claude, openai, custom\n            llmModel: options.llmModel || \"\", // like claude-3-7-sonnet-20250219\n            llmUrl: options.llmUrl || \"\", // Nur für custom notwendig\n            systemPrompt: options.systemPrompt || \"\",\n            promptPrefix: options.promptPrefixs || \"\",\n            onMessageReceived: options.onMessageReceived || null,\n            onTyping: options.onTyping || null\n        };\n    }\n\n    /**\n     * Updates the LLM integration configuration with the provided parameters.\n     *\n     * @param {string} llmType - The type of the language model (e.g., 'openai', 'anthropic').\n     * @param {string} llmModel - The specific model to use (e.g., 'gpt-4', 'claude-2').\n     * @param {string} llmApiKey - The API key for authenticating requests to the LLM service.\n     * @param {string} [llmSystemPrompt] - Optional system prompt to use; defaults to the class's default if not provided.\n     * @param {string} [llmPromptPrefix] - Optional prefix to prepend to prompts; defaults to an empty string if not provided.\n     */\n    updateConfig(llmType = undefined, llmModel = undefined, llmApiKey = undefined, llmSystemPrompt = undefined, llmPromptPrefix = undefined) {\n        this.config.llmType = llmType;\n        this.config.llmModel = llmModel;\n        this.config.apiKey = llmApiKey;\n        this.config.systemPrompt = llmSystemPrompt || this.getDefaultSystemPrompt();\n        this.config.promptPrefix = llmPromptPrefix || this.getDefaultPromptPrefix();\n\n        if(this.isConfigurated()) {\n            this.createLlmGenerator();\n        }\n    }\n\n    /**\n     * Checks if the configuration is complete by verifying the presence of\n     * `apiKey`, `llmType`, and `llmModel` properties in the config object.\n     *\n     * @returns {boolean} Returns `true` if all required configuration properties are set; otherwise, `false`.\n     */\n    isConfigurated() {\n        return this.config.apiKey && this.config.llmType && this.config.llmModel;\n    }\n\n    /**\n     * Initialisiert den LlmIntegrationManager\n     * @param {DataManager} dataManager - Der DataManager für die Datenverwaltung\n     */\n    initialize(dataManager) {\n        if (this.initialized) return;\n\n        if (!dataManager) {\n            console.error(\"Kein DataManager bereitgestellt\");\n            return;\n        }\n\n        this.dataManager = dataManager;\n\n        this.initialized = true;\n        console.log(\"LlmIntegrationManager wurde initialisiert\");\n    }\n\n    /**\n     * Erstellt den LLM-Generator basierend auf der Konfiguration\n     */\n    createLlmGenerator() {\n        const variables = {\n            example: this.getExampleDataAsPromptBlock(),\n            dataStructure: this.getDataStructureAsPromptBlock()\n        };\n\n        // Generator mit der createGenerator-Funktion erstellen\n        const generator = (0,_completion_js__WEBPACK_IMPORTED_MODULE_0__.createGenerator)(\n            variables,\n            this.config.systemPrompt || this.getDefaultSystemPrompt(),\n            this.config.promptPrefix || this.getDefaultPromptPrefix(),\n            {\n                llmType: this.config.llmType,\n                llmModel: this.config.llmModel,\n                llmApiKey: this.config.apiKey,\n                llmUrl: this.config.llmUrl\n            }\n        );\n\n        if (!generator) {\n            console.error(\"Fehler beim Erstellen des LLM-Generators\");\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(\"LLM-Integration konnte nicht initialisiert werden\", \"danger\");\n        }\n\n        return generator;\n    }\n\n    /**\n     * Verarbeitet eine Benutzeranfrage und sendet sie an das LLM\n     * @param {string} userInput - Die Benutzereingabe\n     * @returns {Promise<Object>} - Verarbeitungsergebnis mit Antwort und Datenänderungen\n     */\n    async processUserInput(userInput, callback) {\n        if (!this.isConfigurated()) {\n            return { success: false, message: \"Fehlende Konfigurationen für die Anbindung an ChatBot-Provider\" };\n        }\n\n        let generator;\n        try {\n            generator = this.createLlmGenerator();\n        } catch (error) {\n            console.error(\"Fehler beim Erstellen des LLM-Generators:\", error);\n            return { success: false, message: \"Fehler beim Erstellen des LLM-Generators\" };\n        }\n\n        if (!userInput || this.isProcessing) {\n            return { success: false, message: \"Eingabe kann nicht verarbeitet werden\" };\n        }\n\n        this.isProcessing = true;\n        let result = {\n            success: false,\n            message: \"\",\n            originalResponse: \"\",\n            yamlData: null,\n            differences: null\n        };\n\n        try {\n            // Aktuelle Daten vorbereiten\n            const currentData = this.dataManager.getData();\n\n            // Nachricht an das LLM senden\n            generator.attachMessageAsUserUsingPrefix({\n                userInput: userInput,\n                currentData: this.getCurrentDataAsPromptBlock(currentData),\n                example: this.getExampleDataAsPromptBlock(),\n            });\n\n            // Stream-Antwort verarbeiten\n            const response = await (0,_completion_js__WEBPACK_IMPORTED_MODULE_0__.handleSse)(\n                generator,\n                (error, token) => {\n                    if (error) {\n                        console.error(\"Stream-Fehler:\", error);\n                        return;\n                    }\n\n                    // Token an Handler übergeben, falls definiert\n                    if (this.config.onTyping && token) {\n                        this.config.onTyping(token);\n                    }\n                    if (callback && token) {\n                        callback(token);\n                    }\n                }\n            );\n\n            // Vollständige Antwort speichern\n            result.originalResponse = response;\n            generator.attachMessageAsAssistant(response);\n\n            // Antwort parsen und YAML extrahieren\n            const yamlContent = this.extractYamlFromResponse(response);\n\n            if (yamlContent) {\n                try {\n                    // YAML parsen\n                    const parsedData = jsyaml.load(yamlContent);\n\n                    // Daten validieren\n                    if (this.validateSystemData(parsedData)) {\n                        result.yamlData = parsedData;\n\n                        // Unterschiede berechnen\n                        result.differences = this.calculateDifferences(currentData, parsedData);\n                        result.success = true;\n                    } else {\n                        result.message = \"Die YAML-Struktur ist ungültig\";\n                    }\n                } catch (error) {\n                    console.error(\"Fehler beim Parsen der YAML-Antwort:\", error);\n                    result.message = \"Die YAML-Antwort konnte nicht verarbeitet werden\";\n                }\n            } else {\n                // Normale Konversation ohne YAML-Änderungen\n                result.success = true;\n                result.message = \"Keine Infrastrukturänderungen erkannt\";\n            }\n\n            // Falls ein Callback für empfangene Nachrichten definiert ist, diesen aufrufen\n            if (this.config.onMessageReceived) {\n                this.config.onMessageReceived(result);\n            }\n\n            return result;\n        } catch (error) {\n            console.error(\"Fehler bei der LLM-Verarbeitung:\", error);\n            result.message = \"Es ist ein Fehler bei der Verarbeitung aufgetreten\";\n            return result;\n        } finally {\n            this.isProcessing = false;\n        }\n    }\n\n    /**\n     * Erstellt einen YAML-Markdown-Block für die aktuelle Infrastruktur\n     * @param {Object} currentData - Aktuelle Infrastrukturdaten\n     * @returns {string} - Die formatierte Nachricht mit Kontext\n     */\n    getCurrentDataAsPromptBlock(currentData) {\n        return `\n\\`\\`\\`yaml\nsystems:\n${currentData.systems.map(sys => `  - id: ${sys.id}\n    name: ${sys.name}\n    description: ${sys.description}\n    category: ${sys.category}${this.formatGroups(sys)}\n    status: ${sys.status}\n    knownUsage: ${sys.knownUsage}${sys.tags && sys.tags.length > 0 ? `\\n    tags:\\n${sys.tags.map(tag => `      - ${tag}`).join('\\n')}` : ''}\n`).join('\\n')}\n\ndependencies:\n${currentData.dependencies.map(dep => `  - source: ${dep.source}\n    target: ${dep.target}\n    type: ${dep.type}\n    description: ${dep.description || 'No Description'}\n    protocol: ${dep.protocol || 'API'}\n`).join('\\n')}\n\\`\\`\\`\n`;\n    }\n\n    /**\n     * Erstellt einen YAML-Markdown-Block als Beispiel für den Prompt\n     * @returns {string} - Die formatierte Nachricht mit Kontext\n     */\n    getDataStructureAsPromptBlock() {\n        return `\n\\`\\`\\`yaml\nsystems:\n  - id: systemId\n    name: System Name\n    description: Beschreibung\n    category: kategorie\n    groups:\n      - gruppe1\n      - gruppe2\n    status: status\n    knownUsage: true/false\n    delete: true/false\n    tags:\n      - tag1\n      - tag2\n\ndependencies:\n  - source: quellSystemId\n    target: zielSystemId\n    type: verbindungstyp\n    description: Beschreibung der Verbindung\n    delete: true/false\n    protocol: Verwendetes Protokoll\n\\`\\`\\`\n`;\n    }\n\n    /**\n     * Erstellt einen YAML-Markdown-Block als Beispiel für den Prompt\n     * @returns {string} - Die formatierte Nachricht mit Kontext\n     */\n    getExampleDataAsPromptBlock() {\n        return `\n\\`\\`\\`yaml\nsystems:\n  - id: system1\n    name: System Name\n    description: Beschreibung\n    category: category\n    groups:\n      - group1\n      - group2\n    status: status\n    delete: true/false\n    knownUsage: true/false\n    # Weitere Eigenschaften...\n\ndependencies:\n  - source: system1\n    target: system2\n    type: type\n    description: Beschreibung\n    delete: true/false\n    protocol: Protokoll\n\\`\\`\\`\n`;\n    }\n\n    /**\n     * Hilfsfunktion zum Formatieren der Gruppen-Information für die YAML-Darstellung\n     * @param {Object} system - Das System-Objekt\n     * @returns {string} - Formatierte Gruppen-Information\n     */\n    formatGroups(system) {\n        let groupsText = '';\n\n        // Fall 1: system hat ein groups-Array mit Einträgen\n        if (Array.isArray(system.groups) && system.groups.length > 0) {\n            groupsText = '\\n    groups:';\n            system.groups.forEach(group => {\n                groupsText += `\\n      - ${group}`;\n            });\n        }\n        // Fall 2: Legacy-Fall mit einfachem group-Feld\n        else if (system.group && typeof system.group === 'string') {\n            groupsText = `\\n    group: ${system.group}`;\n        }\n\n        return groupsText;\n    }\n\n    /**\n     * Wendet Datenänderungen auf das Datenmodell an\n     * @param {Object} differences - Die geänderten Daten\n     * @returns {boolean} - True bei Erfolg\n     */\n    applyChanges(differences) {\n        try {\n            // Daten im DataManager aktualisieren\n            this.dataManager.applyBatch(differences);\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(\"Die Änderungen wurden erfolgreich angewendet\", \"success\");\n            return true;\n        } catch (error) {\n            console.error(\"Fehler beim Anwenden der Änderungen:\", error);\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(\"Fehler beim Anwenden der Änderungen\", \"danger\");\n            return false;\n        }\n    }\n\n    /**\n     * Berechnet die Unterschiede zwischen zwei Datenmodellen\n     * @param {Object} currentData - Aktuelle Daten\n     * @param {Object} newData - Neue Daten\n     * @returns {Object} Unterschiede (hinzugefügt, geändert, entfernt)\n     */\n    calculateDifferences(currentData, newData) {\n        const differences = {\n            added: {\n                systems: [],\n                dependencies: []\n            },\n            modified: {\n                systems: [],\n                dependencies: []\n            },\n            removed: {\n                systems: [],\n                dependencies: []\n            }\n        };\n\n        // Systeme vergleichen\n        const currentSystemIds = new Set(currentData.systems.map(s => s.id));\n\n        // Hinzugefügte Systeme\n        newData.systems.forEach(newSystem => {\n            // Gelöschte Systeme\n            if (newSystem.delete) {\n                differences.removed.systems.push(newSystem);\n                return;\n            }\n            if (!currentSystemIds.has(newSystem.id)) {\n                differences.added.systems.push(newSystem);\n            } else {\n                // Geänderte Systeme\n                const currentSystem = currentData.systems.find(s => s.id === newSystem.id);\n                if (!this.areSystemsEqual(currentSystem, newSystem)) {\n                    differences.modified.systems.push(newSystem);\n                }\n            }\n        });\n\n        // Abhängigkeiten vergleichen\n        const currentDepKeys = new Set(currentData.dependencies.map(d => `${d.source}-${d.target}`));\n\n        // Hinzugefügte Abhängigkeiten\n        newData.dependencies.forEach(newDep => {\n            if (newDep.delete) {\n                differences.removed.dependencies.push(newDep);\n                return;\n            }\n            const key = `${newDep.source}-${newDep.target}`;\n            if (!currentDepKeys.has(key)) {\n                differences.added.dependencies.push(newDep);\n            } else {\n                // Geänderte Abhängigkeiten\n                const currentDep = currentData.dependencies.find(d =>\n                    d.source === newDep.source && d.target === newDep.target);\n                if (!this.areDependenciesEqual(currentDep, newDep)) {\n                    differences.modified.dependencies.push(newDep);\n                }\n            }\n        });\n\n        return differences;\n    }\n\n    /**\n     * Vergleicht zwei Systeme auf Gleichheit, angepasst für Multi-Gruppen\n     * @param {Object} system1 - Erstes System\n     * @param {Object} system2 - Zweites System\n     * @returns {boolean} True, wenn die Systeme gleich sind\n     */\n    areSystemsEqual(system1, system2) {\n        if (!system1 || !system2) return false;\n\n        // Vergleich der Haupteigenschaften\n        if (system1.name !== system2.name ||\n            system1.description !== system2.description ||\n            system1.category !== system2.category ||\n            system1.status !== system2.status ||\n            system1.knownUsage !== system2.knownUsage) {\n            return false;\n        }\n\n        // Gruppen vergleichen\n        const groups1 = this.getSystemGroups(system1);\n        const groups2 = this.getSystemGroups(system2);\n\n        if (groups1.length !== groups2.length) {\n            return false;\n        }\n\n        // Prüfen, ob alle Gruppen übereinstimmen (Reihenfolge unwichtig)\n        for (const group of groups1) {\n            if (!groups2.includes(group)) {\n                return false;\n            }\n        }\n\n        // Tags vergleichen (falls vorhanden)\n        if (Array.isArray(system1.tags) && Array.isArray(system2.tags)) {\n            if (system1.tags.length !== system2.tags.length) {\n                return false;\n            }\n\n            for (let i = 0; i < system1.tags.length; i++) {\n                if (!system2.tags.includes(system1.tags[i])) {\n                    return false;\n                }\n            }\n        } else if ((system1.tags && !system2.tags) || (!system1.tags && system2.tags)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Hilfsfunktion zum Extrahieren aller Gruppen eines Systems\n     * @param {Object} system - Das System-Objekt\n     * @returns {Array} Array mit allen Gruppennamen\n     */\n    getSystemGroups(system) {\n        let groups = [];\n\n        if (Array.isArray(system.groups) && system.groups.length > 0) {\n            groups = [...system.groups];\n        } else if (system.group && typeof system.group === 'string') {\n            groups = [system.group];\n        }\n\n        return groups;\n    }\n\n    /**\n     * Vergleicht zwei Abhängigkeiten auf Gleichheit\n     * @param {Object} dep1 - Erste Abhängigkeit\n     * @param {Object} dep2 - Zweite Abhängigkeit\n     * @returns {boolean} True, wenn die Abhängigkeiten gleich sind\n     */\n    areDependenciesEqual(dep1, dep2) {\n        if (!dep1 || !dep2) return false;\n\n        return dep1.type === dep2.type &&\n            dep1.description === dep2.description &&\n            dep1.protocol === dep2.protocol;\n    }\n\n    /**\n     * Validiert die Datenstruktur\n     * @param {Object} data - Die zu validierende Datenstruktur\n     * @returns {boolean} True, wenn die Daten valide sind\n     */\n    validateSystemData(data) {\n        // Überprüfe, ob die Grundstruktur vorhanden ist\n        if (!data || (!Array.isArray(data.systems) && !Array.isArray(data.dependencies))) {\n            return false;\n        }\n\n        data.systems = data.systems || [];\n        data.dependencies = data.dependencies || [];\n\n        // Überprüfe, ob alle Systeme eine ID haben\n        const allSystemsHaveId = data.systems.every(system => !!system.id);\n        if (!allSystemsHaveId) {\n            return false;\n        }\n\n        // Überprüfe, ob alle Abhängigkeiten gültige source und target haben\n        const currentData = this.dataManager.getData();\n        const allDependenciesValid = data.dependencies.every(dep =>\n            !!dep.source && !!dep.target &&\n            (data.systems.some(sys => sys.id === dep.source) || currentData.systems.some(sys => sys.id === dep.source)) &&\n            (data.systems.some(sys => sys.id === dep.target) || currentData.systems.some(sys => sys.id === dep.target))\n        );\n\n        return allDependenciesValid;\n    }\n\n    /**\n     * Extrahiert YAML-Inhalt aus einer LLM-Antwort\n     * @param {string} response - Die LLM-Antwort\n     * @returns {string|null} Der extrahierte YAML-Inhalt oder null\n     */\n    extractYamlFromResponse(response) {\n        // Suche nach YAML-Blöcken in der Antwort (mit Markdown-Code-Block)\n        const yamlRegex = /```(?:yaml)?\\s*([\\s\\S]*?)\\s*```/i;\n        const match = response.match(yamlRegex);\n\n        if (match && match[1]) {\n            return match[1].trim();\n        }\n\n        return null;\n    }\n\n    /**\n     * Gibt den Standard-Systemprompt zurück\n     * @returns {string} Der Standard-Systemprompt\n     */\n    getDefaultSystemPrompt() {\n        return `Du bist ein Infrastruktur-Assistent, der dabei hilft, IT-Systeme und deren Abhängigkeiten zu verwalten. IT-Systeme bestehen aus id, name, description, category, status, knownUsage, groups (array, optional) und tags (array, optional). Abhängigkeiten zwischen Systemen haben die Attribute source, target, type, description und protocol. Du analysierst Benutzeranfragen und wandelst sie in strukturierte YAML-Definitionen um.\n\nAkzeptable Kategorien (category) für Systeme sind:\n- core: Zentrale Systeme\n- legacy: Veraltete Systeme\n- data: Datenspeicher und -verarbeitung\n- service: Dienste und Anwendungen\n- external: Externe Systeme\n\nVerbindungstypen (type) zwischen Systemen können sein:\n- data: Datenaustausch\n- integration: Systemintegration\n- authentication: Authentifizierung\n- monitoring: Überwachung\n\nStatus-Werte (status) für Systeme:\n- active: Aktiv im Einsatz\n- planned: Geplant\n- deprecated: Veraltet\n- retired: Außer Betrieb\n\nWenn der Benutzer dich bittet, die Infrastruktur zu ändern (z.B. Systeme hinzuzufügen, zu bearbeiten oder zu löschen), \nantworte mit den neuen, geänderten und gelöschten Elementen in der YAML-Struktur. Gelöschte Elemente werden mit dem Attribut \\`delete: true\\` markiert. \nFüge keine Erklärungen innerhalb des YAML-Blocks hinzu.\n\nHalte dich an dieses Format:\n\n{{dataStructure}}\n\nWenn du nach allgemeinen Informationen über die Infrastrukturvisualisierung gefragt wirst, \nantworte mit hilfreichen Erklärungen, ohne YAML zurückzugeben.`;\n    }\n\n    /**\n     * Erstellt den Standard-Prompt-Header\n     * \n     * @returns {string} - Die formatierte Nachricht mit Kontext\n     */\n    getDefaultPromptPrefix() {\n        return `\nHier ist die aktuelle YAML-Darstellung der Infrastruktur:\n\n{{currentData}}\n\nBenutzeranfrage:\n\n{{userInput}}\n\nWenn du Änderungen an der Infrastruktur vornehmen sollst, gib die neuen, aktualisierten oder zu löschenden Elemente in YAML im folgenden Format zurück:\n\n{{example}}\n\nWenn keine Änderungen erforderlich sind, antworte mit normaler Konversation. Gib YAML nur zurück, wenn Infrastrukturänderungen angefordert wurden.\n`;\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/llm-integration-manager.js?");

/***/ }),

/***/ "./src/node-cache.js":
/*!***************************!*\
  !*** ./src/node-cache.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NodeCache: () => (/* binding */ NodeCache)\n/* harmony export */ });\n/**\n * NodeCache - Manages the persistence of node positions in the diagram\n * Continuously stores positions and can load them from various sources\n */\nclass NodeCache {\n    constructor(options = {}) {\n        this.positions = new Map();\n        this.options = {\n            useLocalStorage: options.useLocalStorage || false,\n            localStorageKey: options.localStorageKey || 'system_visualizer_node_positions',\n            debounceTime: options.debounceTime || 500, // ms between local saves\n            persistGroups: options.persistGroups || true\n        };\n\n        // Debounce timer for LocalStorage updates\n        this.saveTimer = null;\n\n        // Load from LocalStorage on initialization\n        if (this.options.useLocalStorage) {\n            this.loadFromLocalStorage();\n        }\n    }\n\n    /**\n     * Stores the position of a node\n     * @param {string} id - The ID of the node\n     * @param {Object} position - The position {x, y, vx, vy} and optionally other properties\n     */\n    set(id, position) {\n        if (!id) return;\n\n        // Set current position\n        this.positions.set(id, {\n            x: position.x,\n            y: position.y,\n            vx: position.vx || 0,\n            vy: position.vy || 0,\n            // Optionally more metadata\n            lastUpdated: Date.now(),\n            isFixed: position.isFixed || false,\n        });\n\n        this.saveToLocalStorage();\n    }\n\n    /**\n     * Updates multiple nodes at once\n     * @param {Array} nodes - Array of nodes with id and position data\n     */\n    updateBatch(nodes) {\n        if (!Array.isArray(nodes)) return;\n\n        let updated = false;\n        nodes.forEach(node => {\n            if (node.id && (node.x !== undefined && node.y !== undefined)) {\n                this.positions.set(node.id, {\n                    x: node.x,\n                    y: node.y,\n                    vx: node.vx || 0,\n                    vy: node.vy || 0,\n                    lastUpdated: Date.now(),\n                    isFixed: node.isFixed || false,\n                });\n                updated = true;\n            }\n        });\n\n        if (updated) {\n            this.saveToLocalStorage();\n        }\n    }\n\n    /**\n     * Retrieves the stored position of a node\n     * @param {string} id - The ID of the node\n     * @returns {Object|null} The stored position or null\n     */\n    get(id) {\n        return this.positions.get(id) || null;\n    }\n\n    /**\n     * Checks if a position exists for a node\n     * @param {string} id - The ID of the node\n     * @returns {boolean} True if position exists\n     */\n    has(id) {\n        return this.positions.has(id);\n    }\n\n    /**\n     * Removes an entry from the cache\n     * @param {string} id - The ID of the node\n     */\n    remove(id) {\n        this.positions.delete(id);\n        this.saveToLocalStorage();\n    }\n\n    saveToLocalStorage() {\n        if (this.options.useLocalStorage) {\n            clearTimeout(this.saveTimer);\n            this.saveTimer = setTimeout(() => {\n                this.doSaveToLocalStorage();\n            }, this.options.debounceTime);\n        }\n    }\n\n    /**\n     * Save to LocalStorage\n     */\n    doSaveToLocalStorage() {\n        if (!this.options.useLocalStorage) return;\n\n        try {\n            // Convert the Map to an array of [id, data] pairs\n            const positionsArray = Array.from(this.positions);\n            localStorage.setItem(\n                this.options.localStorageKey,\n                JSON.stringify(positionsArray)\n            );\n        } catch (error) {\n            console.warn('Error saving positions:', error);\n        }\n    }\n\n    /**\n     * Load from LocalStorage\n     */\n    loadFromLocalStorage() {\n        if (!this.options.useLocalStorage) return;\n\n        try {\n            const stored = localStorage.getItem(this.options.localStorageKey);\n            if (stored) {\n                // Convert array of [id, data] pairs back to Map\n                const positionsArray = JSON.parse(stored);\n                this.positions = new Map(positionsArray);\n            }\n        } catch (error) {\n            console.warn('Error loading positions:', error);\n        }\n    }\n\n    /**\n     * Clear cache\n     * @param {boolean} alsoLocalStorage - If true, also clear LocalStorage\n     */\n    clear(alsoLocalStorage = false) {\n        this.positions.clear();\n\n        if (alsoLocalStorage && this.options.useLocalStorage) {\n            localStorage.removeItem(this.options.localStorageKey);\n        }\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/node-cache.js?");

/***/ }),

/***/ "./src/simulation.js":
/*!***************************!*\
  !*** ./src/simulation.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SimulationManager: () => (/* binding */ SimulationManager)\n/* harmony export */ });\n/* harmony import */ var _event_emitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-emitter.js */ \"./src/event-emitter.js\");\n\n\n/**\n * SimulationManager - Handles d3 force simulation logic separate from visualization\n */\nclass SimulationManager extends _event_emitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor(options = {}) {\n        super();\n        this.options = {\n            linkDistance: options.linkDistance || 150,\n            chargeStrength: options.chargeStrength || -300,\n            collisionRadius: options.collisionRadius || 60,\n            groupForceStrength: options.groupForceStrength || 0.5,\n            ...options\n        };\n\n        this.simulation = null;\n        this.nodeCache = options.nodeCache || null;\n        this.width = options.width || 800;\n        this.height = options.height || 600;\n\n        // For throttling cache updates\n        this.lastCacheUpdate = 0;\n        this.cacheUpdateInterval = options.cacheUpdateInterval || 300;\n\n        // Callbacks\n        this.onTick = options.onTick || (() => { });\n        this.onEnd = options.onEnd || (() => { });\n        this.onToggleFixed = options.onToggleFixed || (() => { });\n    }\n\n    /**\n     * Returns the node with the given ID from the current simulation\n     * @param {string} systemId - The ID of the system to find\n     * @returns {Object|null} The node object or null if not found\n     */\n    getNodeById(systemId) {\n        return this.simulation.nodes().find(node => node.id === systemId);\n    }\n\n    /**\n     * Checks if a node is fixed\n     * @param {string} systemId - The ID of the system to check\n     * @returns {boolean} True if the node is fixed, false otherwise or if not found\n     */\n    isNodeFixed(systemId, curNode = undefined) {\n        const node = curNode || this.getNodeById(systemId);\n        return node ? !!node.isFixed : false;\n    }\n\n    /**\n     * Toggles the fixed state of a node identified by systemId.\n     *\n     * @param {string|number} systemId - The unique identifier of the node to toggle.\n     * @param {Object} [curNode=undefined] - The current node object (optional). If not provided, the node will be retrieved by systemId.\n     * @returns {null|undefined} Returns null if the node is not found; otherwise, returns undefined.\n     */\n    toggleNodeFixed(systemId, curNode = undefined) {\n        const node = curNode && this.getNodeById(systemId);\n        if (!node) return null;\n        const isFixed = this.isNodeFixed(systemId, node);\n        const newState = !isFixed;\n        this.setNodeFixed(systemId, newState, node);\n    }\n\n    /**\n     * Sets or removes the fixed position of a node in the simulation.\n     *\n     * @param {string|number} systemId - The unique identifier of the node to fix or unfix.\n     * @param {boolean} state - If true, fixes the node at its current position; if false, releases the node.\n     * @param {Object} [curNode=undefined] - (Optional) The node object to operate on. If not provided, the node is retrieved by systemId.\n     * @returns {boolean|null} Returns the node's fixed state after the operation, or null if the node was not found.\n     */\n    setNodeFixed(systemId, state, curNode = undefined) {\n        const node = curNode || this.getNodeById(systemId);\n        if (!node) return null;\n\n        if (!state) {\n            // Remove fixation\n            node.isFixed = false;\n            node.fx = null;\n            node.fy = null;\n        } else {\n            // Fix node at current position\n            node.isFixed = true;\n            node.fx = node.x;\n            node.fy = node.y;\n        }\n\n        // Update cache\n        if (this.nodeCache && node.id) {\n            this.nodeCache.set(node.id, {\n                x: node.x,\n                y: node.y,\n                vx: node.vx || 0,\n                vy: node.vy || 0,\n                isFixed: node.isFixed\n            });\n        }\n\n        // Slightly restart simulation\n        this.restart(0.1);\n\n        this.onToggleFixed && this.onToggleFixed(systemId, state);\n\n        return node.isFixed;\n    }\n\n    /**\n     * Initialize simulation with nodes and links\n     */\n    initialize(nodes, links, groups) {\n        // Apply cached positions before simulation starts\n        if (this.nodeCache) {\n            this.applyNodePositionsFromCache(nodes);\n        }\n\n        // Calculate initial positions for nodes without cache positions\n        this.applyInitialPositions(nodes);\n\n        // Create simulation\n        this.simulation = d3.forceSimulation(nodes)\n            .force(\"link\", d3.forceLink(links)\n                .id(d => d.id)\n                .distance(this.options.linkDistance))\n            .force(\"charge\", d3.forceManyBody()\n                .strength(this.options.chargeStrength))\n            .force(\"center\", d3.forceCenter(this.width / 2, this.height / 2))\n            .force(\"collision\", d3.forceCollide()\n                .radius(this.options.collisionRadius));\n\n        // Add group force if groups are provided\n        if (groups && Object.keys(groups).length > 0) {\n            this.simulation.force(\"group\", d3.forceClusterMultiGroup()\n                .centers(groups)\n                .strength(this.options.groupForceStrength));\n        }\n\n        // Add containment force to keep nodes within bounds\n        this.simulation.force(\"containment\", this.createContainmentForce());\n\n        // Register tick handler\n        this.simulation.on(\"tick\", () => {\n            // Update node cache periodically during simulation\n            this.throttledUpdateNodeCache();\n\n            // Call external tick handler\n            this.onTick();\n        });\n\n        // Register end handler\n        this.simulation.on(\"end\", () => {\n            // Save final positions to cache\n            if (this.nodeCache) {\n                this.nodeCache.updateBatch(this.simulation.nodes());\n            }\n\n            // Call external end handler\n            this.onEnd();\n        });\n\n        return this.simulation;\n    }\n\n    /**\n     * Retrieves the groups associated with a node.\n     *\n     * If the node has a non-empty `groups` array, it returns that array.\n     * If the node has a `group` property as a string, it returns an array containing that string.\n     * Otherwise, it returns an empty array.\n     *\n     * @param {Object} node - The node object to extract groups from.\n     * @param {Array<string>} [node.groups] - An optional array of group names.\n     * @param {string} [node.group] - An optional single group name.\n     * @returns {Array<string>} An array of group names associated with the node.\n     */\n    getNodeGroups(node) {\n        if (Array.isArray(node.groups) && node.groups.length > 0) {\n            return node.groups;\n        } else if (node.group && typeof node.group === 'string') {\n            return [node.group];\n        }\n        return [];\n    }\n\n    /**\n     * Create a force that keeps nodes within the container bounds\n     */\n    createContainmentForce() {\n        // Add padding to prevent nodes from touching the edge\n        const padding = 50;\n\n        return () => {\n            for (let node of this.simulation.nodes()) {\n                // Gradually increase force as node approaches boundaries\n                if (node.x < padding) {\n                    node.vx += (padding - node.x) * 0.1;\n                } else if (node.x > this.width - padding) {\n                    node.vx -= (node.x - (this.width - padding)) * 0.1;\n                }\n\n                if (node.y < padding) {\n                    node.vy += (padding - node.y) * 0.1;\n                } else if (node.y > this.height - padding) {\n                    node.vy -= (node.y - (this.height - padding)) * 0.1;\n                }\n\n                // Dampen velocity for stable movement\n                node.vx *= 0.9;\n                node.vy *= 0.9;\n            }\n        };\n    }\n\n    /**\n     * Applies cached positions and velocities to a list of nodes.\n     * \n     * For each node with a matching entry in the node cache, updates its position (`x`, `y`),\n     * velocity (`vx`, `vy`), and temporarily fixes its position (`fx`, `fy`) for visual stability.\n     * If the node is not marked as fixed, releases the fixed position after a short delay.\n     * \n     * @param {Array<Object>} nodes - Array of node objects to update. Each node should have an `id` property.\n     * @returns {number} The number of nodes that had their positions updated from the cache.\n     */\n    applyNodePositionsFromCache(nodes) {\n        if (!nodes || !this.nodeCache) return 0;\n\n        let cacheHits = 0;\n        nodes.forEach(node => {\n            if (node.id) {\n                const cachedPosition = this.nodeCache.get(node.id);\n                if (cachedPosition) {\n                    // Position from cache\n                    node.x = cachedPosition.x;\n                    node.y = cachedPosition.y;\n\n                    // Reduced velocity for smoother transitions\n                    node.vx = (cachedPosition.vx || 0) * 0.3;\n                    node.vy = (cachedPosition.vy || 0) * 0.3;\n\n                    // Briefly fix position for visual stability\n                    node.fx = cachedPosition.x;\n                    node.fy = cachedPosition.y;\n\n                    // Schedule release of fixed position\n                    node.isFixed = !!cachedPosition.isFixed;\n                    if(!node.isFixed) {\n                        setTimeout(() => {\n                            node.fx = null;\n                            node.fy = null;\n                        }, 500);\n                    }\n\n                    cacheHits++;\n                }\n            }\n        });\n\n        return cacheHits;\n    }\n\n    /**\n     * Assigns initial positions and velocities to nodes that lack position data.\n     * \n     * For each node without a position, this method:\n     * - Attempts to find reference nodes in the same group(s) (if any), or falls back to all positioned nodes.\n     * - Calculates a target position near the center of the reference nodes, with a random offset.\n     * - Places the node at a random angle and distance from the target position.\n     * - Sets an initial velocity pointing gently toward the target position.\n     * \n     * @param {Array<Object>} nodes - Array of node objects. Each node may have `x`, `y`, `vx`, `vy` properties and group information.\n     */\n    applyInitialPositions(nodes) {\n        // Find nodes without position\n        const nodesWithoutPosition = nodes.filter(node =>\n            node.x === undefined || node.y === undefined);\n\n        if (nodesWithoutPosition.length === 0) return;\n\n        // Get positioned nodes\n        const positionedNodes = nodes.filter(node =>\n            node.x !== undefined && node.y !== undefined);\n\n        // For each new node\n        nodesWithoutPosition.forEach(node => {\n            let referenceNodes = [];\n            let targetPosition;\n\n            // Reference nodes based on groups or all nodes\n            const nodeGroups = this.getNodeGroups(node);\n\n            if (nodeGroups.length > 0) {\n                // Collect all reference nodes for all groups of the node\n                nodeGroups.forEach(group => {\n                    const groupNodes = positionedNodes.filter(n => {\n                        const nGroups = this.getNodeGroups(n);\n                        return nGroups.includes(group);\n                    });\n\n                    referenceNodes = [...referenceNodes, ...groupNodes];\n                });\n\n                // Remove duplicates\n                referenceNodes = Array.from(new Set(referenceNodes));\n            }\n\n            if (referenceNodes.length === 0) {\n                referenceNodes = positionedNodes;\n            }\n\n            // Calculate target position (between all group centers)\n            if (referenceNodes.length > 0) {\n                let sumX = 0, sumY = 0;\n                referenceNodes.forEach(refNode => {\n                    sumX += refNode.x;\n                    sumY += refNode.y;\n                });\n\n                // Group center with offset\n                const isGroupCentered = referenceNodes !== positionedNodes;\n                const offset = isGroupCentered ? 50 : 150;\n\n                targetPosition = {\n                    x: (sumX / referenceNodes.length) + (Math.random() - 0.5) * offset,\n                    y: (sumY / referenceNodes.length) + (Math.random() - 0.5) * offset\n                };\n            } else {\n                // If no references, use screen center\n                targetPosition = {\n                    x: this.width / 2 + (Math.random() - 0.5) * 200,\n                    y: this.height / 2 + (Math.random() - 0.5) * 200\n                };\n            }\n\n            // Starting position at group center edge\n            const distanceFromCenter = referenceNodes.length > 0 ? 100 : 200;\n            const angle = Math.random() * Math.PI * 2;  // Random angle\n\n            node.x = targetPosition.x + Math.cos(angle) * distanceFromCenter;\n            node.y = targetPosition.y + Math.sin(angle) * distanceFromCenter;\n\n            // Initial velocity toward target position\n            const dx = targetPosition.x - node.x;\n            const dy = targetPosition.y - node.y;\n\n            // Gentle movement toward center\n            const speedFactor = 0.01;  // Very low for gentle movement\n            node.vx = dx * speedFactor;\n            node.vy = dy * speedFactor;\n        });\n    }\n\n    /**\n     * Update node cache throttled\n     */\n    throttledUpdateNodeCache() {\n        const now = Date.now();\n        if (this.nodeCache && now - this.lastCacheUpdate > this.cacheUpdateInterval) {\n            this.lastCacheUpdate = now;\n            this.nodeCache.updateBatch(this.simulation.nodes());\n        }\n    }\n\n    /**\n     * Restart simulation with alpha\n     */\n    restart(alpha = 0.3) {\n        if (this.simulation) {\n            this.simulation.alpha(alpha).restart();\n        }\n    }\n\n    /**\n     * Stop simulation\n     */\n    stop() {\n        if (this.simulation) {\n            this.simulation.stop();\n        }\n    }\n\n    /**\n     * Update simulation size\n     */\n    updateSize(width, height) {\n        this.width = width;\n        this.height = height;\n\n        if (this.simulation) {\n            this.simulation.force(\"center\", d3.forceCenter(width / 2, height / 2));\n            // Restart with low alpha to adjust positions\n            this.restart(0.1);\n        }\n    }\n\n    /**\n     * Create drag behavior\n     */\n    createDragBehavior() {\n        return d3.drag()\n            .on(\"start\", (event, d) => this.dragstarted(event, d))\n            .on(\"drag\", (event, d) => this.dragged(event, d))\n            .on(\"end\", (event, d) => this.dragended(event, d));\n    }\n\n    /**\n     * Handle drag start\n     */\n    dragstarted(event, d) {\n        if (!event.active) this.simulation.alphaTarget(0.3).restart();\n        d.fx = d.x;\n        d.fy = d.y;\n        this.setNodeFixed(d.id, true, d);\n    }\n\n    /**\n     * Handle dragging\n     */\n    dragged(event, d) {\n        d.fx = event.x;\n        d.fy = event.y;\n    }\n\n    /**\n     * Handle drag end\n     */\n    dragended(event, d) {\n        if (!event.active) this.simulation.alphaTarget(0);\n\n        // Only persist position in cache if dragged\n        if (this.nodeCache && d.id) {\n            this.nodeCache.set(d.id, {\n                x: d.x,\n                y: d.y,\n                vx: 0,\n                vy: 0,\n                isFixed: d.isFixed || false\n            });\n        }\n    }\n}\n\nd3.forceClusterMultiGroup = function () {\n    let strength = 0.1;\n    let centers = {};\n    let nodes = [];\n\n    // Weight for each group (1/number of groups of a node)\n    // So that nodes with fewer groups are more strongly attracted to their groups\n    function getGroupWeight(node) {\n        const nodeGroups = getNodeGroups(node);\n        return nodeGroups.length > 0 ? 1 / nodeGroups.length : 0;\n    }\n\n    // Helper function to extract all groups of a node\n    function getNodeGroups(node) {\n        if (Array.isArray(node.groups) && node.groups.length > 0) {\n            return node.groups;\n        } else if (node.group && typeof node.group === 'string') {\n            return [node.group];\n        }\n        return [];\n    }\n\n    function force(alpha) {\n        // For each node\n        nodes.forEach(d => {\n            const nodeGroups = getNodeGroups(d);\n            if (nodeGroups.length === 0) return; // Skip if no group\n\n            // Vector for the total force on the node\n            let totalForceX = 0;\n            let totalForceY = 0;\n            let totalWeight = 0;\n\n            // Calculate force from each group\n            nodeGroups.forEach(groupName => {\n                const groupCenter = centers[groupName];\n                if (!groupCenter) return;\n\n                // Weight for this group\n                const weight = getGroupWeight(d);\n                totalWeight += weight;\n\n                // Adjust force depending on the number of groups the node is in\n                const k = strength * alpha * weight;\n\n                // Force towards the group center\n                totalForceX += (groupCenter.x - d.x) * k;\n                totalForceY += (groupCenter.y - d.y) * k;\n            });\n\n            // Apply total force to the node\n            if (totalWeight > 0) {\n                d.vx += totalForceX;\n                d.vy += totalForceY;\n            }\n        });\n    }\n\n    force.initialize = function (_) {\n        nodes = _;\n    };\n\n    force.centers = function (_) {\n        return arguments.length ? (centers = _, force) : centers;\n    };\n\n    force.strength = function (_) {\n        return arguments.length ? (strength = _, force) : strength;\n    };\n\n    return force;\n};\n\n//# sourceURL=webpack://infravis/./src/simulation.js?");

/***/ }),

/***/ "./src/system-manager.js":
/*!*******************************!*\
  !*** ./src/system-manager.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemManager: () => (/* binding */ SystemManager)\n/* harmony export */ });\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities.js */ \"./src/utilities.js\");\n\n\n/**\n * System Manager - Manages adding, editing, and deleting systems\n */\nclass SystemManager {\n    constructor() {\n        this.initialized = false;\n        this.currentEditingSystem = null;\n    }\n\n    /**\n     * Initializes the SystemManager\n     */\n    initialize(dataManager) {\n        this.dataManager = dataManager;\n\n        if (this.initialized) return;\n\n        // React to data changes\n        this.dataManager.on('dataChanged', () => {\n            // Optional: Update the UI on data changes\n        });\n\n        this.initialized = true;\n        console.log('SystemManager has been initialized');\n    }\n\n    /**\n     * Shows the system modal for adding or editing\n     * @param {string} systemId - The ID of the system to edit (null for adding)\n     */\n    showSystemModal(systemId = null) {\n        // Set modal title depending on action (add or edit)\n        document.getElementById('system-modal-label').textContent =\n            systemId ? 'Edit System' : 'Add System';\n\n        const form = document.getElementById('system-form');\n\n        // Reset form\n        form.reset();\n\n        // Clear groups container\n        const groupsContainer = document.getElementById('system-groups-container');\n        if (groupsContainer) {\n            groupsContainer.innerHTML = '';\n        }\n\n        const groupsValueField = document.getElementById('system-groups-value');\n        if (groupsValueField) {\n            groupsValueField.value = '';\n        }\n\n        // If systemId exists, fill form data with system data\n        if (systemId) {\n            const system = this.dataManager.getData().systems.find(sys => sys.id === systemId);\n            if (system) {\n                this.currentEditingSystem = system;\n\n                // Fill form with system data\n                document.getElementById('system-id').value = system.id;\n                document.getElementById('system-name').value = system.name;\n                document.getElementById('system-description').value = system.description;\n                document.getElementById('system-category').value = system.category;\n                document.getElementById('system-status').value = system.status;\n                document.getElementById('system-known-usage').checked = system.knownUsage;\n\n                // Add groups as badges\n                const groups = [];\n                if (Array.isArray(system.groups)) {\n                    system.groups.forEach(group => this.addGroupBadge(group));\n                    groups.push(...system.groups);\n                } else if (system.group && typeof system.group === 'string') {\n                    this.addGroupBadge(system.group);\n                    groups.push(system.group);\n                }\n\n                // Store groups in hidden field\n                if (groupsValueField) {\n                    groupsValueField.value = groups.join(',');\n                }\n\n                // Display tags as comma-separated list\n                if (system.tags && Array.isArray(system.tags)) {\n                    document.getElementById('system-tags').value = system.tags.join(', ');\n                } else {\n                    document.getElementById('system-tags').value = '';\n                }\n            }\n        } else {\n            // New system, clear ID field\n            document.getElementById('system-id').value = '';\n            this.currentEditingSystem = null;\n        }\n\n        // Fill group list (for datalist)\n        const groupList = document.getElementById('group-list');\n        if (groupList) {\n            groupList.innerHTML = '';\n\n            // Collect existing groups\n            const groups = this.dataManager.getAllGroups ?\n                this.dataManager.getAllGroups() : this.getExistingGroups();\n\n            // Fill group list\n            groups.forEach(group => {\n                const option = document.createElement('option');\n                option.value = group;\n                groupList.appendChild(option);\n            });\n        }\n\n        // Show modal\n        const modal = new bootstrap.Modal(document.getElementById('system-modal'));\n        modal.show();\n    }\n\n    /**\n     * Saves a new or edited system\n     */\n    saveSystem() {\n        // Collect form data\n        const systemId = document.getElementById('system-id').value;\n        const name = document.getElementById('system-name').value;\n        const description = document.getElementById('system-description').value;\n        const category = document.getElementById('system-category').value;\n        const status = document.getElementById('system-status').value;\n        const knownUsage = document.getElementById('system-known-usage').checked;\n\n        // Create groups array - support for old and new UI format\n        let groups = [];\n\n        // New UI (with system-groups-value as hidden field)\n        const groupsValueField = document.getElementById('system-groups-value');\n        if (groupsValueField) {\n            groups = groupsValueField.value\n                ? groupsValueField.value.split(',').map(g => g.trim()).filter(g => g !== '')\n                : [];\n        }\n        // Old UI (with system-group as direct input)\n        else {\n            const groupField = document.getElementById('system-group');\n            if (groupField && groupField.value.trim() !== '') {\n                // Check for commas (for manual multi-group input)\n                if (groupField.value.includes(',')) {\n                    groups = groupField.value.split(',').map(g => g.trim()).filter(g => g !== '');\n                } else {\n                    groups = [groupField.value.trim()];\n                }\n            }\n        }\n\n        // Convert tags from comma-separated list to array\n        const tagsString = document.getElementById('system-tags').value;\n        const tags = tagsString\n            ? tagsString.split(',').map(tag => tag.trim()).filter(tag => tag)\n            : [];\n\n        // Form validation\n        if (!name || !description || !category || !status) {\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Please fill in all required fields', 'warning');\n            return;\n        }\n\n        // Create new system object\n        const updatedSystem = {\n            id: systemId || this.dataManager.generateUniqueId(),\n            name,\n            description,\n            category,\n            status,\n            knownUsage,\n            tags,\n            groups // New multi-group array\n        };\n\n        // For backward compatibility also set the single group field\n        if (groups.length > 0) {\n            updatedSystem.group = groups[0];\n        }\n\n        // Add or update the system\n        if (!systemId) {\n            // Add new system\n            this.dataManager.addSystem(updatedSystem);\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)(`System \"${name}\" has been added`, 'success');\n        } else {\n            // Update existing system\n            this.dataManager.updateSystem(updatedSystem);\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)(`System \"${name}\" has been updated`, 'success');\n        }\n\n        // Close modal\n        bootstrap.Modal.getInstance(document.getElementById('system-modal')).hide();\n    }\n\n    /**\n     * Adds a group as a badge to the container\n     * @param {string} groupName - Name of the group\n     */\n    addGroupBadge(groupName) {\n        if (!groupName || groupName.trim() === '') return;\n\n        const container = document.getElementById('system-groups-container');\n        const hiddenField = document.getElementById('system-groups-value');\n\n        if (!container || !hiddenField) {\n            console.warn('Group UI elements not found. Multi-group UI may not be initialized.');\n            return;\n        }\n\n        // Check if the group has already been added\n        const currentGroups = hiddenField.value ? hiddenField.value.split(',') : [];\n        if (currentGroups.includes(groupName)) return;\n\n        // Create badge\n        const badge = document.createElement('span');\n        badge.className = 'badge bg-primary d-flex align-items-center';\n        badge.innerHTML = `\n        ${groupName}\n        <button type=\"button\" class=\"btn-close btn-close-white ms-2\" \n                aria-label=\"Remove\" style=\"font-size: 0.5rem;\"></button>\n    `;\n\n        // Delete button\n        badge.querySelector('.btn-close').addEventListener('click', () => {\n            container.removeChild(badge);\n\n            // Remove value from hidden field\n            const groups = hiddenField.value.split(',');\n            const index = groups.indexOf(groupName);\n            if (index !== -1) {\n                groups.splice(index, 1);\n                hiddenField.value = groups.join(',');\n            }\n        });\n\n        // Add to container\n        container.appendChild(badge);\n\n        // Add to hidden field\n        const newGroups = [...currentGroups, groupName];\n        hiddenField.value = newGroups.join(',');\n    }\n\n    /**\n     * Helper function to collect all existing groups\n     * (Only needed if getAllGroups is not implemented in DataManager)\n     * @returns {Array} Array of unique group names\n     */\n    getExistingGroups() {\n        const groups = new Set();\n\n        this.dataManager.getData().systems.forEach(system => {\n            if (Array.isArray(system.groups)) {\n                system.groups.forEach(group => {\n                    if (group && group.trim() !== '') {\n                        groups.add(group);\n                    }\n                });\n            } else if (system.group && typeof system.group === 'string') {\n                groups.add(system.group);\n            }\n        });\n\n        return Array.from(groups).sort();\n    }\n\n    /**\n     * Shows the delete confirmation for a system\n     * @param {string} systemId - The ID of the system to delete\n     */\n    showDeleteConfirmation(systemId) {\n        const system = this.dataManager.getData().systems.find(sys => sys.id === systemId);\n        if (!system) return;\n\n        // Check if the system is used in dependencies\n        const data = this.dataManager.getData();\n        const incomingDeps = data.dependencies.filter(dep => dep.target === systemId);\n        const outgoingDeps = data.dependencies.filter(dep => dep.source === systemId);\n\n        let message = `Do you really want to delete the system \"${system.name}\"?`;\n\n        if (incomingDeps.length > 0 || outgoingDeps.length > 0) {\n            message += `<br><br><div class=\"alert alert-warning\">\n                <strong>Warning:</strong> This system has ${incomingDeps.length + outgoingDeps.length} \n                dependencies that will also be deleted.\n            </div>`;\n        }\n\n        document.getElementById('confirm-message').innerHTML = message;\n        document.getElementById('confirm-action').setAttribute('data-action', 'delete-system');\n        document.getElementById('confirm-action').setAttribute('data-id', systemId);\n\n        // Show modal\n        const modal = new bootstrap.Modal(document.getElementById('confirm-modal'));\n        modal.show();\n    }\n\n    /**\n     * Deletes a system and its dependencies\n     * @param {string} systemId - The ID of the system to delete\n     */\n    deleteSystem(systemId) {\n        // Find system and store name for notification\n        const system = this.dataManager.getData().systems.find(sys => sys.id === systemId);\n        if (!system) return;\n\n        const systemName = system.name;\n\n        // Delete system via DataManager\n        this.dataManager.deleteSystem(systemId);\n\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)(`System \"${systemName}\" and related dependencies have been deleted`, 'success');\n\n        // Close details panel\n        document.getElementById('details-panel').classList.remove('active');\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/system-manager.js?");

/***/ }),

/***/ "./src/utilities.js":
/*!**************************!*\
  !*** ./src/utilities.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encryptAndStore: () => (/* binding */ encryptAndStore),\n/* harmony export */   retrieveAndDecrypt: () => (/* binding */ retrieveAndDecrypt),\n/* harmony export */   showNotification: () => (/* binding */ showNotification)\n/* harmony export */ });\n/**\n * Displays a notification at the top of the screen\n * @param {string} message - The message to display\n * @param {string} type - The Bootstrap type (success, danger, warning, info)\n */\nfunction showNotification(message, type = 'info') {\n    // Check if a notification container exists\n    let notificationContainer = document.getElementById('notification-container');\n    \n    if (!notificationContainer) {\n        // Create a new container if none exists\n        notificationContainer = document.createElement('div');\n        notificationContainer.id = 'notification-container';\n        notificationContainer.style.position = 'fixed';\n        notificationContainer.style.top = '10px';\n        notificationContainer.style.left = '50%';\n        notificationContainer.style.transform = 'translateX(-50%)';\n        notificationContainer.style.zIndex = '9999';\n        document.body.appendChild(notificationContainer);\n    }\n    \n    // Create the notification\n    const notification = document.createElement('div');\n    notification.className = `alert alert-${type} alert-dismissible fade show`;\n    notification.role = 'alert';\n    notification.innerHTML = `\n        ${message}\n        <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\" aria-label=\"Close\"></button>\n    `;\n    \n    // Add the notification to the container\n    notificationContainer.appendChild(notification);\n    \n    // Remove the notification after 5 seconds\n    setTimeout(() => {\n        notification.classList.remove('show');\n        setTimeout(() => {\n            notificationContainer.removeChild(notification);\n        }, 300);\n    }, 5000);\n}\n\n/**\n * Initialisiert einen client-spezifischen Verschlüsselungsschlüssel\n * Falls noch nicht vorhanden, wird ein neuer generiert und gespeichert\n * @returns {string} Verschlüsselungsschlüssel für diesen Client\n */\nfunction getOrCreateClientKey(recreate = false) {\n  // Prüfen, ob bereits ein Client-Key existiert\n  let clientKey = localStorage.getItem('_client_encryption_salt');\n  \n  // Falls nicht, einen neuen erstellen und speichern\n  if (!clientKey || recreate) {\n    // 32 zufällige Bytes generieren und als Hex-String speichern\n    const randomBytes = crypto.getRandomValues(new Uint8Array(32));\n    clientKey = Array.from(randomBytes)\n      .map(b => b.toString(16).padStart(2, '0'))\n      .join('');\n    \n    localStorage.setItem('_client_encryption_salt', clientKey);\n  }\n  \n  // Kombination aus dem gespeicherten Salt und einigen browserspezifischen Daten\n  const browserFingerprint = navigator.userAgent + navigator.language + screen.colorDepth;\n  \n  // Einfache (nicht kryptografische) Kombination der Werte\n  return clientKey + '_' + browserFingerprint.split('').reduce((hash, char) => {\n    return ((hash << 5) - hash) + char.charCodeAt(0);\n  }, 0);\n}\n\n/**\n * Stores a value encrypted in localStorage\n * @param {string} storageKey - Key for localStorage \n * @param {string} value - Value to store (e.g. API Key)\n * @param {string} password - Password for encryption\n * @returns {Promise<void>}\n */\nasync function encryptAndStore(storageKey, value) {\n    try {\n        const password = getOrCreateClientKey();\n        // Salt and IV for more security\n        const salt = crypto.getRandomValues(new Uint8Array(16));\n        const iv = crypto.getRandomValues(new Uint8Array(12));\n        \n        // Derive a cryptographic key from the password\n        const passwordKey = await crypto.subtle.importKey(\n            'raw', \n            new TextEncoder().encode(password),\n            { name: 'PBKDF2' },\n            false, \n            ['deriveBits', 'deriveKey']\n        );\n        \n        const aesKey = await crypto.subtle.deriveKey(\n            {\n                name: 'PBKDF2',\n                salt: salt,\n                iterations: 100000,\n                hash: 'SHA-256'\n            },\n            passwordKey,\n            { name: 'AES-GCM', length: 256 },\n            false,\n            ['encrypt']\n        );\n        \n        // Encrypt value\n        const encrypted = await crypto.subtle.encrypt(\n            { name: 'AES-GCM', iv: iv },\n            aesKey,\n            new TextEncoder().encode(value)\n        );\n        \n        // Combine everything into an object and store as JSON in localStorage\n        const encryptedObj = {\n            salt: Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join(''),\n            iv: Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join(''),\n            data: Array.from(new Uint8Array(encrypted)).map(b => b.toString(16).padStart(2, '0')).join('')\n        };\n        \n        const jsonString = JSON.stringify(encryptedObj);\n        const jsonStringBase64 = btoa(encodeURIComponent(jsonString).replace(/%([0-9A-F]{2})/g, (_, p1) => String.fromCharCode('0x' + p1)));\n        localStorage.setItem(storageKey, jsonStringBase64);\n    } catch (error) {\n        console.error('Encryption error:', error);\n    }\n}\n\n/**\n * Reads an encrypted value from localStorage and decrypts it\n * @param {string} storageKey - Key for localStorage\n * @param {string} password - Password for decryption\n * @returns {Promise<string|null>} - Decrypted value or null on error\n */\nasync function retrieveAndDecrypt(storageKey) {\n    try {\n        const password = getOrCreateClientKey();\n        // Get encrypted data from localStorage\n        const storedData = localStorage.getItem(storageKey);\n        if (!storedData) return null;\n        // Decode base64 to JSON string\n        const jsonString = decodeURIComponent(Array.prototype.map.call(atob(storedData), c => \n            '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)\n        ).join(''));\n        const encryptedObj = JSON.parse(jsonString);\n        if (!encryptedObj) return null;\n        \n        // Convert hex strings back to Uint8Arrays\n        const salt = new Uint8Array(encryptedObj.salt.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n        const iv = new Uint8Array(encryptedObj.iv.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n        const encryptedData = new Uint8Array(encryptedObj.data.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n        \n        // Derive a cryptographic key from the password (same process as when storing)\n        const passwordKey = await crypto.subtle.importKey(\n            'raw', \n            new TextEncoder().encode(password),\n            { name: 'PBKDF2' },\n            false, \n            ['deriveBits', 'deriveKey']\n        );\n        \n        const aesKey = await crypto.subtle.deriveKey(\n            {\n                name: 'PBKDF2',\n                salt: salt,\n                iterations: 100000,\n                hash: 'SHA-256'\n            },\n            passwordKey,\n            { name: 'AES-GCM', length: 256 },\n            false,\n            ['decrypt']\n        );\n        \n        // Decrypt\n        const decrypted = await crypto.subtle.decrypt(\n            { name: 'AES-GCM', iv: iv },\n            aesKey,\n            encryptedData\n        );\n        \n        // Return as string\n        return new TextDecoder().decode(decrypted);\n    } catch (error) {\n        console.error('Decryption error:', error);\n        return null;\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/utilities.js?");

/***/ }),

/***/ "./src/visualizer.js":
/*!***************************!*\
  !*** ./src/visualizer.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemVisualizer: () => (/* binding */ SystemVisualizer)\n/* harmony export */ });\n/* harmony import */ var _simulation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simulation.js */ \"./src/simulation.js\");\n/* harmony import */ var _node_cache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node-cache.js */ \"./src/node-cache.js\");\n/* harmony import */ var _event_emitter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event-emitter.js */ \"./src/event-emitter.js\");\n\n\n\n\n/**\n * SystemVisualizer - Visualisiert IT-Systeme und deren Abhängigkeiten als interaktiven Graphen\n */\nclass SystemVisualizer extends _event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.EventEmitter {\n    constructor(containerId, dataManager) {\n        super();\n        this.containerId = containerId;\n        this.dataManager = dataManager;\n\n        // Getter für Zugriff auf aktuelle Daten\n        Object.defineProperty(this, 'data', {\n            get: () => this.dataManager.getData()\n        });\n\n        // D3-Visualisierungsvariablen\n        this.svg = null;\n        this.width = 0;\n        this.height = 0;\n        this.zoom = null;\n\n        // UI-Zustände\n        this.searchResults = [];\n        this.activeFilters = {\n            categories: [\"core\", \"legacy\", \"data\", \"service\", \"external\"],\n            knownUsage: [\"known\", \"unknown\"]\n        };\n\n        // Farbskalen\n        this.colorScale = d3.scaleOrdinal()\n            .domain([\"core\", \"legacy\", \"data\", \"service\", \"external\"])\n            .range([\"#0d6efd\", \"#6c757d\", \"#198754\", \"#ffc107\", \"#dc3545\"]);\n        this.groupColorScale = d3.scaleOrdinal(d3.schemeCategory10);\n\n        // Node-Cache erstellen\n        this.nodeCache = new _node_cache_js__WEBPACK_IMPORTED_MODULE_1__.NodeCache({\n            useLocalStorage: true,\n            localStorageKey: 'system_visualizer_node_positions',\n            debounceTime: 250\n        });\n\n        // SimulationManager erstellen (wird später initialisiert)\n        this.simulationManager = null;\n\n        // Visualisierungselemente\n        this.nodeElements = null;\n        this.linkElements = null;\n        this.groupHulls = null;\n        this.groupLabels = null;\n    }\n\n    /**\n     * Initialisiert die Visualisierung\n     */\n    initialize() {\n        if (!this.data) {\n            this.showError(\"Keine Systemdaten verfügbar\");\n            return;\n        }\n\n        this.createVisualization();\n        this.setupZoom();\n        this.attachEventListeners();\n\n        // Auf Datenänderungen reagieren\n        this.dataManager.on('dataChanged', () => {\n            // Visualisierung neu erstellen\n            const container = document.getElementById(this.containerId);\n            if (container) {\n                container.innerHTML = '';\n                this.createVisualization();\n                this.setupZoom();\n            }\n        });\n\n        // Details-Panel-Aktualisierung bei Datenänderungen\n        this.dataManager.on('dataChanged', () => {\n            const detailsPanel = document.getElementById('details-panel');\n            if (detailsPanel && detailsPanel.classList.contains('active')) {\n                const systemId = document.getElementById('detail-title').getAttribute('data-system-id');\n                if (systemId) {\n                    const updatedSystem = this.dataManager.getData().systems.find(sys => sys.id === systemId);\n                    if (updatedSystem) {\n                        this.showSystemDetails(updatedSystem);\n                    } else {\n                        detailsPanel.classList.remove('active');\n                    }\n                }\n            }\n        });\n\n        // Event-Listener für Fenstergrößenänderungen\n        window.addEventListener('resize', this.handleResize.bind(this));\n\n        // Vor dem Beenden Cache aktualisieren\n        window.addEventListener('beforeunload', () => {\n            if (this.simulationManager) {\n                this.simulationManager.stop();\n            }\n        });\n    }\n\n    /**\n     * Erstellt die D3.js-Visualisierung\n     */\n    createVisualization() {\n        const container = document.getElementById(this.containerId);\n\n        if (!container) {\n            console.error(`Container mit ID \"${this.containerId}\" nicht gefunden`);\n            return;\n        }\n\n        // Größe und Margins (Vollbild)\n        this.width = container.clientWidth;\n        this.height = container.clientHeight;\n\n        // SVG erstellen\n        this.svg = d3.select(container)\n            .append(\"svg\")\n            .attr(\"width\", this.width)\n            .attr(\"height\", this.height);\n\n        // Gruppe für Zoom\n        const g = this.svg.append(\"g\");\n\n        // Tooltip erstellen\n        // Tooltip-Element suchen oder erstellen (als D3-Selection)\n        let tooltip = d3.select(\"body\").select(\".tooltip\");\n        if (tooltip.empty()) {\n            tooltip = d3.select(\"body\").append(\"div\")\n                .attr(\"class\", \"tooltip\")\n                .style(\"opacity\", 0);\n        }\n\n        // Graph-Daten vorbereiten und filtern\n        const nodes = this.getFilteredNodes();\n        const links = this.getFilteredLinks(nodes);\n\n        // Gruppierungen identifizieren\n        const groups = this.identifyGroups(nodes);\n\n        // SimulationManager erstellen\n        this.simulationManager = new _simulation_js__WEBPACK_IMPORTED_MODULE_0__.SimulationManager({\n            width: this.width,\n            height: this.height,\n            nodeCache: this.nodeCache,\n            linkDistance: 150,\n            chargeStrength: -300,\n            collisionRadius: 60,\n            groupForceStrength: 0.5,\n            onTick: () => this.onSimulationTick(),\n            onToggleFixed:(id, state) => {\n                this.emit('toggleFixed', { id, state });\n            },\n        });\n\n        // Pfeilspitzen für die Links\n        g.append(\"defs\").selectAll(\"marker\")\n            .data([\"data\", \"integration\", \"authentication\", \"monitoring\"])\n            .enter().append(\"marker\")\n            .attr(\"id\", d => `arrowhead-${d}`)\n            .attr(\"viewBox\", \"0 -5 10 10\")\n            .attr(\"refX\", 8)  // Kein Versatz - Pfeilspitze beginnt am Ende des Pfades\n            .attr(\"refY\", 0)  // Kein Versatz\n            .attr(\"markerWidth\", 6)\n            .attr(\"markerHeight\", 6)\n            .attr(\"orient\", \"auto\")\n            .append(\"path\")\n            .attr(\"d\", \"M0,-5L10,0L0,5\")\n            .attr(\"fill\", d => {\n                switch (d) {\n                    case \"data\": return \"#0d6efd\";\n                    case \"integration\": return \"#198754\";\n                    case \"authentication\": return \"#dc3545\";\n                    case \"monitoring\": return \"#6c757d\";\n                    default: return \"#999\";\n                }\n            });\n\n        // Gruppenrahmen zeichnen (vor den Knoten und Links)\n        this.groupHulls = g.append(\"g\")\n            .attr(\"class\", \"groups\")\n            .selectAll(\".group-hull\")\n            .data(Object.entries(groups).filter(([name]) => name !== \"ungrouped\")) // \"undefined\" Gruppe ausfiltern\n            .enter().append(\"path\")\n            .attr(\"class\", \"group-hull\")\n            .attr(\"data-group\", d => d[0])\n            .style(\"fill\", d => this.groupColorScale(d[0]))\n            .style(\"stroke\", d => d3.rgb(this.groupColorScale(d[0])).darker())\n            .style(\"stroke-width\", 1.5)\n            .style(\"fill-opacity\", 0.2)\n            .style(\"stroke-opacity\", 0.4);\n\n        // Links zeichnen\n        const that = this;\n        // Links zeichnen\n        this.linkElements = g.append(\"g\")\n            .attr(\"class\", \"links\")\n            .selectAll(\"path\")\n            .data(links)\n            .enter().append(\"path\")\n            .attr(\"class\", \"link\")\n            .attr(\"marker-end\", d => `url(#arrowhead-${d.type})`)\n            .attr(\"data-type\", d => d.type)\n            .attr(\"data-link-index\", d => d.linkIndex)\n            .attr(\"data-total-links\", d => d.totalLinks)\n            .on(\"mouseover\", function (event, d) {\n                if (that.dragDisabled) return;\n                tooltip.transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n\n                const sourceSystem = nodes.find(n => n.id === d.source.id || n.id === d.source);\n                const targetSystem = nodes.find(n => n.id === d.target.id || n.id === d.target);\n\n                tooltip.html(`\n                    <strong>${sourceSystem ? sourceSystem.name : 'Unbekannt'} → ${targetSystem ? targetSystem.name : 'Unbekannt'}</strong><br>\n                    ${d.description || 'Keine Beschreibung'}<br>\n                    <em>Protokoll: ${d.protocol || 'Nicht spezifiziert'}</em>\n                `);\n\n                // Tooltip mittig unterhalb des Mauszeigers positionieren\n                const tooltipNode = tooltip.node();\n                // Temporär sichtbar machen, um Breite zu messen\n                tooltip.style(\"opacity\", 0).style(\"display\", \"block\");\n                const tooltipWidth = tooltipNode.offsetWidth;\n                tooltip.style(\"display\", null); // zurücksetzen\n\n                tooltip\n                    .style(\"left\", (event.pageX - tooltipWidth / 2) + \"px\")\n                    .style(\"top\", (event.pageY + 16) + \"px\")\n                    .transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n            })\n            .on(\"mouseout\", function () {\n                tooltip.transition()\n                    .duration(500)\n                    .style(\"opacity\", 0);\n            })\n            .on(\"click\", (event, data) => {\n                this.emit('dependencyClick', { event, data });\n                event.stopPropagation();\n            });;\n\n        // Knoten erstellen\n        const nodeGroup = g.append(\"g\")\n            .attr(\"class\", \"nodes\");\n\n        this.nodeElements = nodeGroup.selectAll(\".node\")\n            .data(nodes)\n            .enter().append(\"g\")\n            .attr(\"class\", d => {\n                const classes = [\"node\"];\n                if (!d.knownUsage) classes.push(\"unknown-usage\");\n\n                // Mehrere Gruppen-Klassen hinzufügen\n                const nodeGroups = this.getNodeGroups(d);\n                nodeGroups.forEach(group => {\n                    classes.push(`group-${group}`);\n                });\n\n                return classes.join(\" \");\n            })\n            .attr(\"data-system-id\", d => d.id)\n            .attr(\"data-groups\", d => this.getNodeGroups(d).join(\",\"));\n\n        if (!this.dragDisabled) {\n            this.nodeElements.call(this.simulationManager.createDragBehavior())\n        }\n\n        // Kreise für die Systeme\n        const radius = 30;\n        this.nodeElements.append(\"circle\")\n            .attr(\"r\", radius)\n            .attr(\"fill\", d => this.colorScale(d.category))\n            .attr(\"stroke\", d => {\n                const nodeGroups = this.getNodeGroups(d);\n                if (nodeGroups.length > 0) {\n                    // Bei mehreren Gruppen einen Mehrfarben-Stroke erstellen (könnte z.B. gestrichelt sein)\n                    return nodeGroups.length > 1 ?\n                        \"url(#multigroup-gradient-\" + d.id + \")\" : // ID für Gradient\n                        this.groupColorScale(nodeGroups[0]); // Einzelne Gruppe\n                }\n                return \"#fff\"; // Standard ohne Gruppe\n            })\n            .attr(\"stroke-width\", d => this.getNodeGroups(d).length > 0 ? 3 : 2)\n            .attr(\"stroke-dasharray\", d => this.getNodeGroups(d).length > 1 ? \"5,3\" : null)\n            .on(\"mouseover\", function (event, d) {\n                if (that.dragDisabled) return;\n                tooltip.transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n                tooltip.html(`\n                    <strong>${d.name}</strong><br>\n                    ${d.description}<br>\n                    ${d.group ? '<span class=\"badge bg-info\">Gruppe: ' + d.group + '</span>' : ''}\n                `);\n\n                // Temporär sichtbar machen, um Breite und Höhe zu messen\n                tooltip.style(\"opacity\", 0).style(\"display\", \"block\");\n                const tooltipNode = tooltip.node();\n                const tooltipWidth = tooltipNode.offsetWidth;\n                tooltip.style(\"display\", null); // zurücksetzen\n\n                // Höhe des Kreises bestimmen (SVG-Kreis hat r=30)\n                const circleRadius = radius;\n                // Optional: Falls der Kreisradius dynamisch ist, könnte man ihn so ermitteln:\n                // const circleRadius = d3.select(this).attr(\"r\");\n\n                tooltip\n                    .style(\"left\", (event.pageX - tooltipWidth / 2) + \"px\")\n                    .style(\"top\", (event.pageY + Number(circleRadius) + 8) + \"px\") // 8px Abstand unterhalb des Kreises\n                    .transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n            })\n            .on(\"mouseout\", function () {\n                tooltip.transition()\n                    .duration(500)\n                    .style(\"opacity\", 0);\n            })\n            .on(\"click\", (event, d) => this.showSystemDetails(d));\n\n        // Text-Labels\n        this.nodeElements.append(\"text\")\n            .attr(\"dy\", -40)\n            .attr(\"text-anchor\", \"middle\")\n            .text(d => d.name)\n            .attr(\"fill\", \"#333\");\n\n        // Gruppen-Labels hinzufügen\n        this.groupLabels = g.append(\"g\")\n            .attr(\"class\", \"group-labels\")\n            .selectAll(\".group-label\")\n            .data(Object.entries(groups).filter(([name]) => name !== \"ungrouped\"))\n            .enter().append(\"text\")\n            .attr(\"class\", \"group-label\")\n            .attr(\"text-anchor\", \"middle\")\n            .style(\"font-size\", \"16px\")\n            .style(\"font-weight\", \"bold\")\n            .style(\"fill\", d => d3.rgb(this.groupColorScale(d[0])).darker(2))\n            .style(\"pointer-events\", \"none\")\n            .text(d => {\n                // Anzeige für zusammengeführte Gruppen\n                if (d[1].allGroups && d[1].allGroups.length > 1) {\n                    return `${d[0]} (+${d[1].allGroups.length - 1})`;\n                }\n                return d[0];\n            });\n        this.groupLabels.append(\"title\") // Tooltip für Details\n            .text(d => {\n                if (d[1].allGroups && d[1].allGroups.length > 1) {\n                    return `Zusammengeführte Gruppen:\\n${d[1].allGroups.join('\\n')}`;\n                }\n                return d[0];\n            });\n\n        const defs = g.select(\"defs\");\n        nodes.forEach(d => {\n            const nodeGroups = this.getNodeGroups(d);\n            if (nodeGroups.length > 1) {\n                const gradient = defs.append(\"linearGradient\")\n                    .attr(\"id\", \"multigroup-gradient-\" + d.id)\n                    .attr(\"x1\", \"0%\")\n                    .attr(\"y1\", \"0%\")\n                    .attr(\"x2\", \"100%\")\n                    .attr(\"y2\", \"100%\");\n\n                // Farbstopps für jede Gruppe hinzufügen\n                nodeGroups.forEach((group, i) => {\n                    gradient.append(\"stop\")\n                        .attr(\"offset\", (i / (nodeGroups.length - 1) * 100) + \"%\")\n                        .attr(\"stop-color\", this.groupColorScale(group));\n                });\n            }\n        });\n\n        // Simulation starten\n        this.simulationManager.initialize(nodes, links, groups);\n    }\n\n    /**\n    * Gibt gefilterte Links basierend auf den gefilterten Knoten zurück\n    */\n    getFilteredLinks(nodes) {\n        const nodeIds = nodes.map(node => node.id);\n\n        // Verbindungszähler initialisieren\n        const linkCounts = {};\n\n        // Erste Filterung der Links\n        const filteredLinks = this.data.dependencies.filter(dep => {\n            return nodeIds.includes(dep.source) && nodeIds.includes(dep.target);\n        });\n\n        // Links zählen und indizieren\n        filteredLinks.forEach(dep => {\n            const key = `${dep.source}-${dep.target}`;\n            const reverseKey = `${dep.target}-${dep.source}`;\n\n            // Zähler für diese Richtung initialisieren\n            if (!linkCounts[key]) {\n                linkCounts[key] = 0;\n            }\n\n            // Zähler erhöhen und dem Link zuweisen\n            linkCounts[key]++;\n            dep.linkIndex = linkCounts[key] - 1; // 0-basierter Index\n\n            // Gesamtzahl der Links in dieser Richtung speichern\n            dep.totalLinks = filteredLinks.filter(d =>\n                (d.source === dep.source && d.target === dep.target)\n            ).length;\n        });\n\n        // Links mit zusätzlichen Informationen zurückgeben\n        return filteredLinks.map(dep => ({\n            source: dep.source,\n            target: dep.target,\n            linkIndex: dep.linkIndex,\n            totalLinks: dep.totalLinks,\n            ...dep\n        }));\n    }\n\n    /**\n     * Wird bei jedem Simulation-Tick aufgerufen\n     */\n    onSimulationTick() {\n        if (!this.linkElements || !this.nodeElements || !this.groupHulls || !this.groupLabels) {\n            return;\n        }\n\n        // Links aktualisieren\n        this.linkElements.attr(\"d\", this.linkArc);\n\n        // Knoten aktualisieren\n        this.nodeElements.attr(\"transform\", d => `translate(${d.x},${d.y})`);\n\n        // Gruppierungshüllen aktualisieren\n        this.groupHulls.attr(\"d\", d => {\n            const groupName = d[0];\n            const simulation = this.simulationManager.simulation;\n\n            // Alle Knoten finden, die zu dieser Gruppe gehören\n            // WICHTIGER UNTERSCHIED: Wir prüfen jetzt, ob ein Knoten zu EINER der ursprünglichen Gruppen gehört\n            const groupNodes = simulation.nodes().filter(n => {\n                const nodeGroups = this.getNodeGroups(n);\n\n                // Prüfe, ob der Knoten zu einer der ursprünglichen Gruppen gehört,\n                // die auf diese Repräsentanten-Gruppe abgebildet wurden\n                if (d[1].allGroups) {\n                    // Für eine zusammengeführte Gruppe prüfen, ob der Knoten zu einer der ursprünglichen Gruppen gehört\n                    return nodeGroups.some(ng => d[1].allGroups.includes(ng));\n                } else {\n                    // Für eine einzelne Gruppe normal prüfen\n                    return nodeGroups.includes(groupName);\n                }\n            });\n\n            // Wenn keine oder nur ein Knoten, zeichne einen kleinen Kreis um diesen\n            if (groupNodes.length === 0) {\n                return \"\"; // Keine Hülle, wenn keine Knoten\n            }\n\n            if (groupNodes.length === 1) {\n                // Bei nur einem Knoten: zeichne Kreis um diesen\n                const node = groupNodes[0];\n                return `M${node.x + 60},${node.y} \n                    A60,60 0 1,1 ${node.x - 60},${node.y} \n                    A60,60 0 1,1 ${node.x + 60},${node.y}`;\n            }\n\n            // Zentroid der Gruppe berechnen\n            const points = groupNodes.map(n => [n.x, n.y]);\n            const centroid = this.getCentroid(points);\n\n            // Radius berechnen (mit zusätzlichem Padding)\n            const maxDist = Math.max(40, this.getMaxDistanceFromCentroid(points, centroid) + 40);\n\n            // Kreisförmige Hülle um die Gruppe zeichnen\n            return this.createHullPath(centroid, maxDist, 24);\n        });\n\n        // Gruppenbezeichnungen aktualisieren\n        this.groupLabels.attr(\"transform\", d => {\n            const groupName = d[0];\n            const simulation = this.simulationManager.simulation;\n\n            // Die gleiche Filterlogik wie bei den Hüllen verwenden\n            const groupNodes = simulation.nodes().filter(n => {\n                const nodeGroups = this.getNodeGroups(n);\n\n                if (d[1].allGroups) {\n                    return nodeGroups.some(ng => d[1].allGroups.includes(ng));\n                } else {\n                    return nodeGroups.includes(groupName);\n                }\n            });\n\n            if (groupNodes.length === 0) return \"translate(0,0)\";\n\n            const points = groupNodes.map(n => [n.x, n.y]);\n            const centroid = this.getCentroid(points);\n\n            return `translate(${centroid[0]},${centroid[1] - 60})`;\n        });\n    }\n\n    /**\n     * Richtet Zoom-Funktionalität ein\n     */\n    setupZoom() {\n        this.zoom = d3.zoom()\n            .scaleExtent([0.1, 4])\n            .on(\"zoom\", (event) => {\n                this.svg.select(\"g\").attr(\"transform\", event.transform);\n            });\n\n        this.svg.call(this.zoom);\n\n        // Reset-Zoom-Button\n        document.getElementById(\"reset-zoom\").addEventListener(\"click\", () => {\n            this.svg.transition().duration(750).call(\n                this.zoom.transform,\n                d3.zoomIdentity\n            );\n        });\n\n        // Nach dem Zoom oder Pan den Zustand speichern\n        this.zoom.on('end', () => {\n            this.saveViewportState();\n        });\n\n        // Zustand wiederherstellen\n        this.restoreViewportState();\n    }\n\n    /**\n * Optimierte linkArc-Funktion mit angepasster Verteilung für gerade Anzahl von Links\n */\n    linkArc(d) {\n        // Knotenradius\n        const nodeRadius = 32;\n\n        // Extrahiere Quell- und Zielkoordinaten\n        const sourceX = d.source.x;\n        const sourceY = d.source.y;\n        const targetX = d.target.x;\n        const targetY = d.target.y;\n\n        // Berechne Abstand und Basiswinkel zwischen den Knoten\n        const dx = targetX - sourceX;\n        const dy = targetY - sourceY;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        const baseAngle = Math.atan2(dy, dx);\n\n        // Bestimmung der Winkelversätze\n        const totalLinks = d.totalLinks || 1;\n        const linkIndex = d.linkIndex || 0;\n\n        // Maximaler Winkelversatz in Grad (±15°), in Radiant umgerechnet\n        const maxOffsetDegrees = 15;\n        const maxOffset = (maxOffsetDegrees * Math.PI) / 180;\n\n        // Winkelversatz berechnen - mit Anpassung für gerade Anzahl von Links\n        let angleOffset = 0;\n\n        if (totalLinks > 1) {\n            if (totalLinks % 2 === 0) {\n                // Bei gerader Anzahl: Verschiebung, um die Mitte zu vermeiden\n                // z.B. bei 4 Links: -0.75, -0.25, +0.25, +0.75 statt -1, -0.33, +0.33, +1\n                const step = 1 / totalLinks;\n                angleOffset = ((linkIndex / (totalLinks - 1)) * 2 - 1 + step) * maxOffset;\n            } else {\n                // Bei ungerader Anzahl: normale Verteilung\n                angleOffset = ((linkIndex / (totalLinks - 1)) * 2 - 1) * maxOffset;\n            }\n        }\n\n        // Startpunkt auf dem Quellknoten\n        const startAngle = baseAngle + angleOffset;\n        const startX = sourceX + Math.cos(startAngle) * nodeRadius;\n        const startY = sourceY + Math.sin(startAngle) * nodeRadius;\n\n        // Endpunkt auf dem Zielknoten mit gespiegeltem Winkelversatz\n        const endAngle = baseAngle + Math.PI - angleOffset;\n        const endX = targetX + Math.cos(endAngle) * nodeRadius;\n        const endY = targetY + Math.sin(endAngle) * nodeRadius;\n\n        // Minimaler Winkelversatz für die Krümmung (selbst bei einzelnen Links)\n        // Einzelne Links bekommen eine leichte Kurve statt einer geraden Linie\n        const minCurvatureAngle = (3 * Math.PI) / 180;  // 3 Grad in Radiant\n\n        // Effektiver Winkelversatz für die Krümmungsberechnung\n        const effectiveAngleOffset = Math.max(Math.abs(angleOffset), minCurvatureAngle);\n\n        // Bogenrichtung basierend auf dem Vorzeichen des Winkelversatzes\n        // Bei einzelnen Links: standardmäßig im Uhrzeigersinn\n        const sweep = (totalLinks === 1 || angleOffset >= 0) ? 1 : 0;\n\n        // Krümmungsfaktor basierend auf Winkelversatz und Distanz\n        // Minimal 0.15 für leichte Kurve, maximal 0.5 für starke Kurve\n        let curvature = 0.15 + (effectiveAngleOffset / maxOffset) * 0.35;\n\n        // Orthogonale Richtungsvektoren für den Kontrollpunkt\n        const tangentX = (endX - startX) / distance;\n        const tangentY = (endY - startY) / distance;\n        const perpX = -tangentY;\n        const perpY = tangentX;\n\n        // Mittelpunkt berechnen\n        const midX = (startX + endX) / 2;\n        const midY = (startY + endY) / 2;\n\n        // Kontrollpunkt mit Richtung basierend auf sweep\n        const ctrlFactor = (sweep === 1 ? 1 : -1) * curvature * distance;\n        const ctrlX = midX + perpX * ctrlFactor;\n        const ctrlY = midY + perpY * ctrlFactor;\n\n        // Quadratische Bézierkurve\n        return `M${startX},${startY}Q${ctrlX},${ctrlY} ${endX},${endY}`;\n    }\n\n    /**\n     * Identifiziert alle Gruppen und bereitet sie für d3.js vor\n     * Optimiert, um Gruppen mit identischen Knoten zusammenzuführen\n     */\n    /**\n * Erweiterte identifyGroups Methode, die sowohl Zusammenführung durchführt\n * als auch bidirektionale Zuordnungen zwischen Gruppen speichert\n */\n    identifyGroups(nodes) {\n        // Schritt 1: Initiale Gruppierung erstellen\n        const initialGroupMap = {};\n        const UNGROUPED_GROUP_NAME = \"ungrouped\";\n\n        // Datenstruktur für Gruppe -> Zugehörige Knoten\n        nodes.forEach(node => {\n            const nodeGroups = this.getNodeGroups(node);\n\n            if (nodeGroups.length > 0) {\n                nodeGroups.forEach(groupName => {\n                    if (!initialGroupMap[groupName]) {\n                        initialGroupMap[groupName] = {\n                            nodes: [],\n                            nodeIds: new Set(),\n                            x: 0,\n                            y: 0\n                        };\n                    }\n                    initialGroupMap[groupName].nodes.push(node);\n                    initialGroupMap[groupName].nodeIds.add(node.id);\n                });\n            } else {\n                if (!initialGroupMap[UNGROUPED_GROUP_NAME]) {\n                    initialGroupMap[UNGROUPED_GROUP_NAME] = {\n                        nodes: [],\n                        nodeIds: new Set(),\n                        x: 0,\n                        y: 0\n                    };\n                }\n                initialGroupMap[UNGROUPED_GROUP_NAME].nodes.push(node);\n                initialGroupMap[UNGROUPED_GROUP_NAME].nodeIds.add(node.id);\n            }\n        });\n\n        // Schritt 2: Gruppen mit identischen Knoten identifizieren\n        const groupSignatures = {};  // Signatur -> Gruppen mit dieser Signatur\n\n        Object.entries(initialGroupMap).forEach(([groupName, groupData]) => {\n            if (groupName === UNGROUPED_GROUP_NAME) return;\n\n            // Erstelle eine eindeutige Signatur basierend auf den Knoten-IDs\n            const signature = Array.from(groupData.nodeIds).sort().join(',');\n\n            if (!groupSignatures[signature]) {\n                groupSignatures[signature] = [];\n            }\n\n            groupSignatures[signature].push(groupName);\n        });\n\n        // Schritt 3: Finale Gruppenkarte erstellen\n        const finalGroupMap = {};\n\n        // Mapping von ursprünglichen Gruppen zu repräsentativen Gruppen\n        // WICHTIG: Wir speichern dies als globale/Klasseninstanz-Variable\n        this.groupMap = {};\n\n        // Zuerst die ungrouped-Gruppe hinzufügen, falls vorhanden\n        if (initialGroupMap[UNGROUPED_GROUP_NAME]) {\n            finalGroupMap[UNGROUPED_GROUP_NAME] = initialGroupMap[UNGROUPED_GROUP_NAME];\n        }\n\n        // Dann die zusammengeführten Gruppen\n        Object.entries(groupSignatures).forEach(([signature, groups]) => {\n            // Die erste Gruppe als repräsentative Gruppe verwenden\n            const primaryGroup = groups[0];\n\n            // Gruppe in die finale Karte übernehmen\n            finalGroupMap[primaryGroup] = initialGroupMap[primaryGroup];\n\n            // Speichere alle ursprünglichen Gruppen als Metadaten\n            if (groups.length > 1) {\n                finalGroupMap[primaryGroup].allGroups = groups;\n                console.log(`Merged identical groups: ${groups.join(', ')} -> ${primaryGroup}`);\n\n                // Bidirektionale Zuordnung erstellen\n                groups.forEach(originalGroup => {\n                    this.groupMap[originalGroup] = primaryGroup;\n                });\n            } else {\n                // Auch für Einzelgruppen die Zuordnung erstellen\n                this.groupMap[primaryGroup] = primaryGroup;\n            }\n        });\n\n        // Schritt 4: Initiale Positionen berechnen\n        Object.entries(finalGroupMap).forEach(([groupName, group], index) => {\n            // Positionen gleichmäßig um den Mittelpunkt verteilen\n            const angle = (index / Object.keys(finalGroupMap).length) * 2 * Math.PI;\n            const radius = Math.min(this.width, this.height) * 0.4;\n\n            group.x = this.width / 2 + radius * Math.cos(angle);\n            group.y = this.height / 2 + radius * Math.sin(angle);\n        });\n\n        return finalGroupMap;\n    }\n\n    /**\n     * Hilfsfunktion um zu prüfen, ob zwei Arrays die gleichen Elemente enthalten\n     * (Reihenfolge wird ignoriert)\n     */\n    arraysHaveSameElements(arr1, arr2) {\n        if (arr1.length !== arr2.length) return false;\n\n        const set1 = new Set(arr1);\n        for (const item of arr2) {\n            if (!set1.has(item)) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Hilfsfunktion zum Extrahieren aller Gruppen eines Knotens\n     * Berücksichtigt neue groups-Arrays und Legacy group-Felder\n     */\n    getNodeGroups(node) {\n        if (Array.isArray(node.groups) && node.groups.length > 0) {\n            return node.groups;\n        } else if (node.group && typeof node.group === 'string') {\n            return [node.group];\n        }\n        return [];\n    }\n\n    /**\n     * Berechnet den Schwerpunkt (Zentroid) einer Gruppe von Punkten\n     */\n    getCentroid(points) {\n        const n = points.length;\n        if (n === 0) return [0, 0];\n\n        const sumX = points.reduce((sum, p) => sum + p[0], 0);\n        const sumY = points.reduce((sum, p) => sum + p[1], 0);\n\n        return [sumX / n, sumY / n];\n    }\n\n    /**\n     * Berechnet die maximale Distanz vom Zentroid zu einem Punkt der Gruppe\n     */\n    getMaxDistanceFromCentroid(points, centroid) {\n        if (points.length === 0) return 0;\n\n        return Math.max(...points.map(p =>\n            Math.sqrt(Math.pow(p[0] - centroid[0], 2) + Math.pow(p[1] - centroid[1], 2))\n        ));\n    }\n\n    /**\n     * Erstellt einen Pfad für die Gruppenhülle\n     */\n    createHullPath(center, radius, segments) {\n        const angleStep = (2 * Math.PI) / segments;\n        let path = `M${center[0] + radius},${center[1]}`;\n\n        for (let i = 1; i <= segments; i++) {\n            const angle = i * angleStep;\n            const x = center[0] + radius * Math.cos(angle);\n            const y = center[1] + radius * Math.sin(angle);\n            path += ` L${x},${y}`;\n        }\n\n        return path + \"Z\";\n    }\n\n    /**\n     * Gibt den Knoten mit der angegebenen ID aus der aktuellen Simulation zurück\n     * @param {string} systemId - Die ID des zu findenden Systems\n     * @returns {Object|null} Das Knotenobjekt oder null, wenn nicht gefunden\n     */\n    getNodeById(systemId) {\n        return this.simulationManager.getNodeById(systemId);\n    }\n\n    /**\n     * Prüft, ob ein Knoten fixiert ist\n     * @param {string} systemId - Die ID des zu prüfenden Systems\n     * @returns {boolean} True, wenn der Knoten fixiert ist, false sonst oder wenn nicht gefunden\n     */\n    isNodeFixed(systemId) {\n        return this.simulationManager.isNodeFixed(systemId);\n    }\n\n    /**\n     * Schaltet den fixierten Zustand eines Knotens um\n     * @param {string} systemId - Die ID des zu ändernden Systems\n     * @returns {boolean} Der neue Fixierungszustand oder null, wenn der Knoten nicht gefunden wurde\n     */\n    toggleNodeFixed(systemId) {\n        return this.simulationManager.toggleNodeFixed(systemId);\n    }\n\n    /**\n     * Zeigt die Systemdetails im Overlay an\n     */\n    showSystemDetails(system) {\n        const detailsPanel = document.getElementById('details-panel');\n        const detailsDiv = document.getElementById('system-details');\n        const detailTitle = document.getElementById('detail-title');\n\n        if (!detailsDiv || !detailsPanel || !detailTitle) {\n            console.error('Details-Container nicht gefunden');\n            return;\n        }\n\n        // Titel setzen\n        detailTitle.textContent = system.name;\n        detailTitle.setAttribute('data-system-id', system.id);\n\n        // Eingehende und ausgehende Abhängigkeiten finden\n        const incomingDeps = this.data.dependencies.filter(dep => dep.target === system.id);\n        const outgoingDeps = this.data.dependencies.filter(dep => dep.source === system.id);\n\n        let html = `\n        <div class=\"system-detail-card\">\n            <p class=\"mb-1\">${system.description}</p>\n            <div class=\"badge bg-${this.getCategoryClass(system.category)} mb-2\">${system.category}</div>\n            <p><strong>Status:</strong> ${system.status}</p>\n            <p><strong>Bekannte Nutzung:</strong> ${system.knownUsage ? 'Ja' : 'Nein'}</p>\n    `;\n\n        // Gruppen-Information hinzufügen - Multi-Gruppen-Unterstützung\n        const groups = [];\n        if (Array.isArray(system.groups) && system.groups.length > 0) {\n            groups.push(...system.groups);\n        } else if (system.group && typeof system.group === 'string') {\n            groups.push(system.group);\n        }\n\n        if (groups.length > 0) {\n            html += `<p><strong>Gruppen:</strong> ${groups.map(group =>\n                `<span class=\"badge bg-info\">${group}</span>`).join(' ')}</p>`;\n        }\n\n        if (system.tags && system.tags.length > 0) {\n            html += `<p><strong>Tags:</strong> ${system.tags.map(tag =>\n                `<span class=\"badge bg-secondary\">${tag}</span>`).join(' ')}</p>`;\n        }\n\n        if (incomingDeps.length > 0) {\n            html += `<h6 class=\"mt-3\">Eingehende Verbindungen</h6><ul class=\"list-group\">`;\n            incomingDeps.forEach(dep => {\n                const source = this.data.systems.find(s => s.id === dep.source);\n                html += `\n                <li class=\"list-group-item\">\n                    <div class=\"d-flex w-100 justify-content-between\">\n                        <strong>${source ? source.name : 'Unbekannt'}</strong>\n                        <span class=\"badge bg-secondary\">${dep.protocol || 'Unbekannt'}</span>\n                    </div>\n                    <small>${dep.description || 'Keine Beschreibung'}</small>\n                </li>`;\n            });\n            html += `</ul>`;\n        }\n\n        if (outgoingDeps.length > 0) {\n            html += `<h6 class=\"mt-3\">Ausgehende Verbindungen</h6><ul class=\"list-group\">`;\n            outgoingDeps.forEach(dep => {\n                const target = this.data.systems.find(s => s.id === dep.target);\n                html += `\n                <li class=\"list-group-item\">\n                    <div class=\"d-flex w-100 justify-content-between\">\n                        <strong>${target ? target.name : 'Unbekannt'}</strong>\n                        <span class=\"badge bg-secondary\">${dep.protocol || 'Unbekannt'}</span>\n                    </div>\n                    <small>${dep.description || 'Keine Beschreibung'}</small>\n                </li>`;\n            });\n            html += `</ul>`;\n        }\n\n        if (incomingDeps.length === 0 && outgoingDeps.length === 0) {\n            html += `<div class=\"alert alert-warning mt-3\">Dieses System hat keine bekannten Verbindungen.</div>`;\n        }\n\n        html += `</div>`;\n\n        detailsDiv.innerHTML = html;\n\n        // Details-Panel anzeigen\n        detailsPanel.classList.add('active');\n\n        // Button-Zustand anpassen\n        const toggleFixButton = document.querySelector('.toggle-fix-btn');\n        const isFixed = this.isNodeFixed(system.id);\n        if (toggleFixButton) {\n            if (isFixed) {\n                toggleFixButton.classList.add('active');\n                toggleFixButton.title = 'Position freigeben';\n            } else {\n                toggleFixButton.classList.remove('active');\n                toggleFixButton.title = 'Position fixieren';\n            }\n        }\n    }\n\n    /**\n     * Hilfsfunktion zur Ermittlung der Bootstrap-Farbe für Kategorien\n     */\n    getCategoryClass(category) {\n        switch (category) {\n            case 'core': return 'primary';\n            case 'legacy': return 'secondary';\n            case 'data': return 'success';\n            case 'service': return 'warning';\n            case 'external': return 'danger';\n            default: return 'info';\n        }\n    }\n\n    /**\n     * Zeigt eine Fehlermeldung an\n     */\n    showError(message) {\n        const container = document.getElementById(this.containerId);\n        if (container) {\n            container.innerHTML = `<div class=\"alert alert-danger m-3\">${message}</div>`;\n        } else {\n            console.error(message);\n        }\n    }\n\n    /**\n     * Behandelt Größenänderungen des Fensters\n     */\n    handleResize() {\n        const container = document.getElementById(this.containerId);\n        if (container && this.svg) {\n            // Neue Größe erfassen\n            this.width = container.clientWidth;\n            this.height = container.clientHeight;\n\n            // SVG-Größe aktualisieren\n            this.svg\n                .attr(\"width\", this.width)\n                .attr(\"height\", this.height);\n\n            // Simulationsmanager über neue Größe informieren\n            if (this.simulationManager) {\n                this.simulationManager.updateSize(this.width, this.height);\n            }\n        }\n    }\n\n    /**\n     * Fügt Event-Listener für UI-Elemente hinzu\n     */\n    attachEventListeners() {\n        // Filter für Systemkategorien\n        const categoryFilters = document.querySelectorAll('.category-filter');\n        if (categoryFilters.length > 0) {\n            categoryFilters.forEach(filter => {\n                filter.addEventListener('change', () => {\n                    const checkedCategories = Array.from(document.querySelectorAll('.category-filter:checked'))\n                        .map(checkbox => checkbox.value);\n                    this.activeFilters.categories = checkedCategories;\n                });\n            });\n        }\n\n        // Filter für Systemstatus\n        const statusFilters = document.querySelectorAll('.status-filter');\n        if (statusFilters.length > 0) {\n            statusFilters.forEach(filter => {\n                filter.addEventListener('change', () => {\n                    const checkedStatuses = Array.from(document.querySelectorAll('.status-filter:checked'))\n                        .map(checkbox => checkbox.value);\n                    this.activeFilters.knownUsage = checkedStatuses;\n                });\n            });\n        }\n\n        // Filter anwenden\n        const applyFiltersButton = document.getElementById('apply-filters');\n        if (applyFiltersButton) {\n            applyFiltersButton.addEventListener('click', () => {\n                this.applyFilters();\n                document.getElementById('filter-panel').classList.remove('active');\n            });\n        }\n\n        // Suchfeld\n        const searchInput = document.getElementById('system-search');\n        if (searchInput) {\n            searchInput.addEventListener('input', () => this.performSearch(searchInput.value));\n        }\n    }\n\n    /**\n     * Wendet Filter auf die Visualisierung an\n     */\n    applyFilters() {\n        if (this.svg) {\n            this.svg.remove();\n            this.createVisualization();\n            this.setupZoom();\n        }\n    }\n\n    /**\n     * Gibt gefilterte Knoten zurück\n     */\n    getFilteredNodes() {\n        return this.data.systems.filter(system => {\n            // Kategorie-Filter\n            if (!this.activeFilters.categories.includes(system.category)) {\n                return false;\n            }\n\n            // Status-Filter (bekannte/unbekannte Nutzung)\n            const usageType = system.knownUsage ? 'known' : 'unknown';\n            if (!this.activeFilters.knownUsage.includes(usageType)) {\n                return false;\n            }\n\n            return true;\n        }).map(system => ({ ...system }));\n    }\n\n    /**\n     * Führt eine Suche durch und zeigt die Ergebnisse an\n     */\n    performSearch(query) {\n        const resultsContainer = document.getElementById('search-results');\n\n        if (!resultsContainer) {\n            console.error('Suchergebnisse-Container nicht gefunden');\n            return;\n        }\n\n        if (!query || query.trim() === '') {\n            resultsContainer.innerHTML = '';\n            return;\n        }\n\n        const searchTerm = query.toLowerCase().trim();\n\n        // Systeme durchsuchen\n        const results = this.data.systems.filter(system => {\n            return (\n                system.name.toLowerCase().includes(searchTerm) ||\n                system.description.toLowerCase().includes(searchTerm) ||\n                (system.tags && system.tags.some(tag => tag.toLowerCase().includes(searchTerm))) ||\n                (system.group && system.group.toLowerCase().includes(searchTerm)) // Auch in Gruppen suchen\n            );\n        });\n\n        // Ergebnisse anzeigen\n        if (results.length === 0) {\n            resultsContainer.innerHTML = '<div class=\"alert alert-info\">Keine Systeme gefunden.</div>';\n        } else {\n            let html = '';\n\n            results.forEach(system => {\n                html += `\n                    <button class=\"list-group-item list-group-item-action\" data-system-id=\"${system.id}\">\n                        <div class=\"d-flex w-100 justify-content-between\">\n                            <h6 class=\"mb-1\">${system.name}</h6>\n                            <span class=\"badge bg-${this.getCategoryClass(system.category)}\">${system.category}</span>\n                        </div>\n                        <small>${system.description}</small>\n                        ${system.group ? `<br><small><span class=\"badge bg-info\">Gruppe: ${system.group}</span></small>` : ''}\n                    </button>\n                `;\n            });\n\n            resultsContainer.innerHTML = html;\n\n            // Event-Listener für Klicks auf Suchergebnisse\n            const resultItems = resultsContainer.querySelectorAll('.list-group-item');\n            resultItems.forEach(item => {\n                item.addEventListener('click', () => {\n                    const systemId = item.getAttribute('data-system-id');\n                    const system = this.data.systems.find(s => s.id === systemId);\n\n                    if (system) {\n                        this.showSystemDetails(system);\n                        document.getElementById('search-panel').classList.remove('active');\n                    }\n                });\n            });\n        }\n    }\n\n    // Methode zum Speichern des aktuellen Viewports\n    saveViewportState() {\n        if (this.svg) {\n            const currentTransform = d3.zoomTransform(this.svg.node());\n            localStorage.setItem('system_visualizer_transform', JSON.stringify({\n                x: currentTransform.x,\n                y: currentTransform.y,\n                k: currentTransform.k\n            }));\n        }\n    }\n\n    // Methode zum Wiederherstellen des Viewports\n    restoreViewportState() {\n        try {\n            const storedTransform = localStorage.getItem('system_visualizer_transform');\n            if (storedTransform && this.svg && this.zoom) {\n                const t = JSON.parse(storedTransform);\n                const transform = d3.zoomIdentity.translate(t.x, t.y).scale(t.k);\n                this.svg.call(this.zoom.transform, transform);\n            }\n        } catch (e) {\n            console.warn('Fehler beim Wiederherstellen des Viewports:', e);\n        }\n    }\n\n    /**\n     * Deaktiviert die Drag-Funktion für Knoten\n     */\n    disableDrag() {\n        if (this.nodeElements) {\n            this.nodeElements.on('.drag', null);\n        }\n        this.dragDisabled = true;\n    }\n\n    /**\n     * Aktiviert die Drag-Funktion für Knoten wieder\n     */\n    enableDrag() {\n        if (this.nodeElements && this.simulationManager) {\n            this.nodeElements.call(this.simulationManager.createDragBehavior());\n        }\n        this.dragDisabled = false;\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/visualizer.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;