/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/completion.js":
/*!***************************!*\
  !*** ./src/completion.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGenerator: () => (/* binding */ createGenerator),\n/* harmony export */   handleSse: () => (/* binding */ handleSse)\n/* harmony export */ });\nclass PromptTemplate {\n    constructor(template) {\n        this.template = template;\n    }\n\n    // Methode 1: Template Literals (moderne ES6+ Syntax)\n    formatWithTemplateString(variables) {\n        return new Function(...Object.keys(variables), `return \\`${this.template}\\`;`)(...Object.values(variables));\n    }\n\n    // Methode 2: Named Parameters mit {{name}}\n    formatWithNamedParams(variables) {\n        return this.template.replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => variables[key] || \"\");\n    }\n}\n\nclass AbstractLlmApi {\n    async generate() {\n        throw new Error(\"Not implemented\");\n    }\n\n    setSystemPrompt(systemPrompt) {\n        this.systemPrompt = systemPrompt; \n    }\n\n    getSystemPrompt() {\n        return this.systemPrompt;\n    }\n\n    attachMessage(role, content) {\n        if(!this.messages) {\n            this.reset();\n        }\n        this.messages.push({ role, content });\n    }\n\n    attachMessageAsAssistant(content) {\n        this.attachMessage(this.getAssistantRole(), content);\n    }\n\n    attachMessageAsUser(content) {\n        this.attachMessage(this.getUserRole(), content);\n    }\n\n    reset() {\n        this.messages = [];\n    }\n\n    extractMessages(line) {\n        throw new Error(\"Not implemented\");\n    }\n\n    getAssistantRole() {\n        return \"assistant\";\n    }\n    getUserRole() {\n        return \"user\";\n    }\n    getDetails() {\n        return {\"type\": \"unknown\"};\n    }\n}\n\nclass ClaudeApi extends AbstractLlmApi {\n    constructor(apiKey, model) {\n        super();\n        this.apiKey = apiKey;\n        this.model = model;\n    }\n\n    getDetails() {\n        return {\"type\": \"claude\", \"model\": this.model};\n    }\n\n    async generate() {\n        try {\n            const body = JSON.stringify({\n                model: this.model || \"claude-3-5-sonnet-20241022\",\n                max_tokens: 4096,\n                stream: true,\n                system: [{\n                    type: \"text\",\n                    cache_control: {\"type\": \"ephemeral\"},\n                    text: this.systemPrompt\n                }],\n                messages: this.messages\n            });\n\n            const response = await fetch('https://api.anthropic.com/v1/messages', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'x-api-key': this.apiKey,\n                    'anthropic-version': '2023-06-01',\n                    'anthropic-dangerous-direct-browser-access': 'true'\n                },\n                body\n            });\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(`API error: ${response.status} ${response.statusText}\\nDetails: ${errorText}`);\n            }\n\n            return response.body;\n        } catch (error) {\n            throw new Error(`Failed to generate alternative: ${error.message}`);\n        }\n    }\n\n    extractMessages(line) {\n        if (!line || line.trim() === '') {\n            return '';\n        }\n        //console.log(`Message: ${line}`);\n        const parsedData = JSON.parse(line);\n\n        // We got a valid JSON message, but it might be an error\n        if (parsedData.type === \"error\") {\n            const error = new Error(`Stream error: ${parsedData.error?.type} - ${parsedData.error?.message}`);\n            error.isStreamError = true;\n            error.errorData = parsedData.error;\n            throw error;\n        }\n\n        // We got a valid JSON message and it looks like a delta\n        if (parsedData.delta && parsedData.delta.text) {\n            return parsedData.delta.text;\n        }\n        \n        return '';\n    }\n}\n\nclass OpenAiApi extends AbstractLlmApi {\n    constructor(apiKey, model) {\n        super();\n        this.apiKey = apiKey;\n        this.model = model;\n    }\n\n    getDetails() {\n        return {\"type\": \"openai\", \"model\": this.model};\n    }\n\n    reset() {\n        this.messages = [];\n        if (this.systemPrompt) {\n            this.attachMessage(\"system\", this.systemPrompt);\n        }\n    }\n\n    async generate() {\n        try {\n            const body = JSON.stringify({\n                model: this.model || \"gpt-4-turbo-preview\",\n                messages: this.messages,\n                max_tokens: 4096,\n                temperature: 0.7,\n                stream: true\n            });\n\n            const response = await fetch('https://api.openai.com/v1/chat/completions', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${this.apiKey}`\n                },\n                body\n            });\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(`API error: ${response.status} ${response.statusText}\\nDetails: ${errorText}`);\n            }\n\n            return response.body;\n        } catch (error) {\n            throw new Error(`Failed to generate alternative: ${error.message}`);\n        }\n    }\n\n    extractMessages(line) {\n        const parsedData = JSON.parse(line);\n        const token = parsedData.choices[0].delta.content || '';\n        return token;\n    }\n}\n\nclass CustomBasedOnOpenAiApi extends AbstractLlmApi {\n    constructor(apiKey, model, url) {\n        super();\n        this.apiKey = apiKey;\n        this.model = model;\n        this.url = url.endsWith('/') ? url.slice(0, -1) : url;\n    }\n\n    getDetails() {\n        return {\"type\": \"custom\", \"model\": this.model, \"url\": this.url};\n    }\n\n    reset() {\n        this.messages = [];\n        if (this.systemPrompt) {\n            this.attachMessage(\"system\", this.systemPrompt);\n        }\n    }\n\n    async generate() {\n        const body = JSON.stringify({\n            model: this.model || \"\",\n            messages: this.messages,\n            max_tokens: 1024,\n            temperature: 0.7,\n            stream: true\n        });\n\n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        if (this.apiKey) {\n            headers['Authorization'] = `Bearer ${this.apiKey}`;\n        }\n        let response;\n        const url = `${this.url}/v1/chat/completions`;\n        try {\n            response = await fetch(url, {\n                method: 'POST',\n                headers,\n                body\n            });\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(`API error: ${response.status} ${response.statusText}\\nDetails: ${errorText}`);\n            }\n\n            return response.body;\n        } catch (error) {\n            throw new Error(`Failed to generate alternative: ${error.message}\\nRequest Details: ${JSON.stringify({ url, body, headers, response }, null, 2)}`);\n        }\n    }\n\n    extractMessages(line) {\n        const parsedData = JSON.parse(line);\n        const token = parsedData.choices[0].delta.content || '';\n        return token;\n    }\n}\n\nclass Generator {\n    constructor(api, systemPrompt, promptPrefix, variables) {\n        this.api = api;\n        this.systemPrompt = systemPrompt;\n        this.promptPrefix = promptPrefix;\n        this.variables = variables;\n\n        this.reset();\n    }\n\n    getApiDetails() {\n        return this.api.getDetails();\n    }\n\n    reset() {\n        // Create prompt templates to replace them with information from variables\n        const systemPromptTemplate = new PromptTemplate(this.systemPrompt);\n\n        // Set current system prompt\n        this.api.setSystemPrompt(systemPromptTemplate.formatWithNamedParams(this.variables));\n\n        // Reset message history, some providers might require to add this to the message list\n        this.api.reset();\n    }\n\n    attachMessageAsAssistant(text) {\n        this.api.attachMessageAsAssistant(text);\n    }\n\n    attachMessageAsUser(text) {\n        this.api.attachMessageAsUser(text);\n    }\n\n    attachMessageAsUserUsingPrefix(variables) {\n        const codePromptTemplate = new PromptTemplate(this.promptPrefix);\n        this.api.attachMessageAsUser(codePromptTemplate.formatWithNamedParams(variables));\n    }\n\n    async generate() {\n        return await this.api.generate();\n    }\n\n    extractMessages(line) {\n        return this.api.extractMessages(line);\n    }\n\n    getMessages() {\n        return this.api.messages.map(el => {\n            let role = el.role;\n            if(el.role === this.api.getUserRole()) {\n                role = \"user\";\n            } else if(el.role === this.api.getAssistantRole()) {\n                role = \"assistant\";\n            }\n            return {\n                role,\n                content: el.content\n            }\n        });\n    }\n\n    restoreMessages(messages) {\n        this.api.messages = messages.map(el => {\n            let role = el.role;\n            if (el.role === \"user\") {\n                role = this.api.getUserRole();\n            } else if (el.role === \"assistant\") {\n                role = this.api.getAssistantRole();\n            }\n            return {\n                role,\n                content: el.content\n            };\n        });\n    }\n\n    getSystemPrompt() {\n        return this.api.getSystemPrompt();\n    }\n}\n\nfunction createGenerator(variables, systemPrompt = \"\", promptPrefix = \"\", options = {}) {\n    const llmType = options.llmType;\n    const llmModel = options.llmModel;\n    const llmApiKey = options.llmApiKey;\n\n    let api;\n    if (llmType === 'claude') {\n        api = new ClaudeApi(llmApiKey, llmModel);\n    } else if (llmType === 'openai') {\n        api = new OpenAiApi(llmApiKey, llmModel);\n    } else if (llmType === 'custom') {\n        const llmUrl = options.llmUrl;\n        api = new CustomBasedOnOpenAiApi(llmApiKey, llmModel, llmUrl);\n    } else {\n        throw new Error(`Unknown LLM type: ${llmType}`);\n    }\n\n    return new Generator(api, systemPrompt, promptPrefix, variables);\n}\n\nasync function handleSse(generator, callback) {\n    const stream = await generator.generate();\n    const reader = stream.getReader();\n    const decoder = new TextDecoder();\n\n    let result = '';\n    let buffer = '';\n    \n    try {\n        reading: while (true) {\n            const { done, value } = await reader.read();\n\n            if (done) {\n                break;\n            }\n\n            // Decodiere den Chunk und füge ihn zum Buffer hinzu\n            buffer += decoder.decode(value, { stream: true });\n\n            let pos;\n            while ((pos = buffer.indexOf('\\n\\n')) >= 0) {\n                const event = buffer.substring(0, pos);\n                buffer = buffer.substring(pos + 2);\n\n                const lines = event.split('\\n');\n                let data = '';\n                \n                for (const line of lines) {\n                    if (line.startsWith('data:')) {\n                        data += line.substring(5).trim();\n                    }\n                }\n\n                if (data === '[DONE]') {\n                    break reading;\n                }\n\n                if (data) {\n                    try {\n                        const token = generator.extractMessages(data);\n                        result += token;\n                        if (callback) {\n                            callback(undefined, token);\n                        }\n                    } catch (error) {\n                        if (error.isStreamError) {\n                            console.error(`Stream error: ${error.message}`);\n                            if (callback) {\n                                callback(JSON.stringify({\n                                    error: true,\n                                    type: error.errorData?.type,\n                                    message: error.errorData?.message\n                                }));\n                            }\n                            break reading;\n                        }\n                        console.error('Failed to parse JSON:', error);\n                    }\n                }\n            }\n        }\n    } catch (error) {\n        console.error('Stream processing error:', error);\n    }\n    \n    return result;\n}\n\n//# sourceURL=webpack://infravis/./src/completion.js?");

/***/ }),

/***/ "./src/data-loader.js":
/*!****************************!*\
  !*** ./src/data-loader.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   downloadSystemData: () => (/* binding */ downloadSystemData),\n/* harmony export */   downloadVisualizationAsPNG: () => (/* binding */ downloadVisualizationAsPNG),\n/* harmony export */   downloadVisualizationAsSVG: () => (/* binding */ downloadVisualizationAsSVG),\n/* harmony export */   uploadSystemData: () => (/* binding */ uploadSystemData),\n/* harmony export */   validateSystemData: () => (/* binding */ validateSystemData)\n/* harmony export */ });\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities.js */ \"./src/utilities.js\");\n\n\n\n/**\n * Opens a file dialog for the user to upload a YAML file containing system data.\n * Parses and validates the selected YAML file, updates the DataManager with the new data,\n * refreshes the visualization, and displays notifications based on the outcome.\n *\n * Utilizes a hidden file input element to trigger the file selection dialog.\n * Supports files with .yaml or .yml extensions.\n *\n * @function\n * @returns {void}\n */\nfunction uploadSystemData(dataManager) {\n    // Create a hidden file input element\n    const fileInput = document.createElement('input');\n    fileInput.type = 'file';\n    fileInput.accept = '.yaml,.yml';\n    fileInput.style.display = 'none';\n    document.body.appendChild(fileInput);\n    \n    // Simulate a click on the hidden input element\n    fileInput.click();\n    \n    // Event listener for file selection\n    fileInput.addEventListener('change', function(event) {\n        const file = event.target.files[0];\n        if (!file) return;\n        \n        const reader = new FileReader();\n        reader.onload = async function(e) {\n            try {\n                const yamlContent = e.target.result;\n                const parsedData = jsyaml.load(yamlContent);\n                \n                // Validate the data structure\n                if (!validateSystemData(parsedData)) {\n                    (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Invalid data format', 'danger');\n                    return;\n                }\n                \n                // Update data in DataManager\n                dataManager.setData(parsedData);\n                \n                (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Data loaded successfully', 'success');\n            } catch (error) {\n                console.error('Error parsing the YAML file:', error);\n                (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Invalid YAML format', 'danger');\n            }\n        };\n        \n        reader.readAsText(file);\n        \n        // Remove the temporary input element\n        document.body.removeChild(fileInput);\n    });\n}\n\n/**\n * Validates the uploaded data structure\n * @param {Object} data - The data structure to validate\n * @returns {boolean} True if the data is valid\n */\nfunction validateSystemData(data) {\n    // Check if the basic structure exists\n    if (!data || !Array.isArray(data.systems) || !Array.isArray(data.dependencies)) {\n        return false;\n    }\n    \n    // Check if all systems have an ID\n    const allSystemsHaveId = data.systems.every(system => !!system.id);\n    if (!allSystemsHaveId) {\n        return false;\n    }\n    \n    // Check if all dependencies have valid source and target\n    const allDependenciesValid = data.dependencies.every(dep => \n        !!dep.source && !!dep.target && \n        data.systems.some(sys => sys.id === dep.source) && \n        data.systems.some(sys => sys.id === dep.target)\n    );\n    \n    return allDependenciesValid;\n}\n\n/**\n * Downloads the current system data as a YAML file\n */\nfunction downloadSystemData(dataManager) {\n    const currentData = dataManager.getData();\n    \n    if (!currentData || !currentData.systems || currentData.systems.length === 0) {\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('No data available for download', 'warning');\n        return;\n    }\n    \n    try {\n        // Convert the JS object to YAML\n        const yamlString = jsyaml.dump(currentData);\n        \n        // Create a Blob and a download link\n        const blob = new Blob([yamlString], { type: 'application/x-yaml' });\n        const url = URL.createObjectURL(blob);\n        \n        const a = document.createElement('a');\n        a.href = url;\n        a.download = 'systems.yaml';\n        document.body.appendChild(a);\n        a.click();\n        \n        // Clean up\n        setTimeout(() => {\n            document.body.removeChild(a);\n            URL.revokeObjectURL(url);\n        }, 100);\n        \n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Data downloaded successfully', 'success');\n    } catch (error) {\n        console.error('Error downloading the data:', error);\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Error during download', 'danger');\n    }\n}\n/**\n * Exports the current visualization as an SVG file\n */\nfunction downloadVisualizationAsSVG() {\n    // Find the SVG element\n    const svgElement = document.querySelector('#visualization-container svg');\n    if (!svgElement) {\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('No visualization found to download', 'warning');\n        return;\n    }\n\n    try {\n        // Clone the SVG to not modify the original\n        const clonedSvg = svgElement.cloneNode(true);\n        \n        // Add CSS styles inline for the exported SVG\n        const styles = document.createElement('style');\n        for (const sheet of document.styleSheets) {\n            try {\n                if (sheet.href && sheet.href.includes('styles.css')) {\n                    // Add only relevant CSS styles\n                    for (const rule of sheet.cssRules) {\n                        if (rule.selectorText && (\n                            rule.selectorText.includes('.node') || \n                            rule.selectorText.includes('.link') || \n                            rule.selectorText.includes('.group') ||\n                            rule.selectorText.includes('svg') ||\n                            rule.selectorText.includes('circle') ||\n                            rule.selectorText.includes('text') ||\n                            rule.selectorText.includes('path')\n                        )) {\n                            styles.textContent += rule.cssText + '\\n';\n                        }\n                    }\n                }\n            } catch (err) {\n                // Some stylesheets may not be accessible due to CORS\n                console.warn('Could not access stylesheet:', err);\n            }\n        }\n        \n        // Add the styles to the SVG\n        clonedSvg.insertBefore(styles, clonedSvg.firstChild);\n        \n        // Set width and height attributes\n        const width = svgElement.clientWidth || 1200;\n        const height = svgElement.clientHeight || 800;\n        clonedSvg.setAttribute('width', width);\n        clonedSvg.setAttribute('height', height);\n        \n        // Add viewBox if it doesn't exist\n        if (!clonedSvg.getAttribute('viewBox')) {\n            clonedSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n        }\n        \n        // Convert SVG to XML string\n        const serializer = new XMLSerializer();\n        let svgString = serializer.serializeToString(clonedSvg);\n        \n        // Add XML declaration and DOCTYPE\n        svgString = '<?xml version=\"1.0\" standalone=\"no\"?>\\n' + svgString;\n        \n        // Create a blob and download link\n        const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });\n        const url = URL.createObjectURL(blob);\n        const link = document.createElement('a');\n        \n        // Set download attributes\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n        link.href = url;\n        link.download = `infrastructure-map-${timestamp}.svg`;\n        \n        // Trigger download\n        document.body.appendChild(link);\n        link.click();\n        \n        // Clean up\n        setTimeout(() => {\n            document.body.removeChild(link);\n            URL.revokeObjectURL(url);\n        }, 100);\n        \n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Visualization downloaded successfully', 'success');\n    } catch (error) {\n        console.error('Error downloading the SVG file:', error);\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Error during download', 'danger');\n    }\n}\n\n/**\n * Exports the current visualization as a PNG file\n */\nfunction downloadVisualizationAsPNG() {\n    // Find the SVG element\n    const svgElement = document.querySelector('#visualization-container svg');\n    if (!svgElement) {\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('No visualization found to download', 'warning');\n        return;\n    }\n\n    try {\n        // Clone the SVG to not modify the original\n        const clonedSvg = svgElement.cloneNode(true);\n\n        // Ensure that all link paths have no fill\n        const linkPaths = clonedSvg.querySelectorAll('.link');\n        linkPaths.forEach(path => {\n            // Set basic properties for all links\n            path.setAttribute('fill', 'none');\n            path.setAttribute('stroke-width', '1.5px');\n            path.setAttribute('stroke-opacity', '0.6');\n            \n            // Set color depending on connection type\n            const linkType = path.getAttribute('data-type');\n            switch(linkType) {\n                case 'data':\n                    path.setAttribute('stroke', '#0d6efd');\n                    break;\n                case 'integration':\n                    path.setAttribute('stroke', '#198754');\n                    break;\n                case 'authentication':\n                    path.setAttribute('stroke', '#dc3545');\n                    break;\n                case 'monitoring':\n                    path.setAttribute('stroke', '#6c757d');\n                    break;\n                default:\n                    path.setAttribute('stroke', '#999');\n            }\n        });\n        \n        // Set width and height attributes\n        const width = svgElement.clientWidth || 1200;\n        const height = svgElement.clientHeight || 800;\n        clonedSvg.setAttribute('width', width);\n        clonedSvg.setAttribute('height', height);\n        \n        // Add viewBox if it doesn't exist\n        if (!clonedSvg.getAttribute('viewBox')) {\n            clonedSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n        }\n        \n        // Convert SVG to XML string with inline styles\n        const serializer = new XMLSerializer();\n        let svgString = serializer.serializeToString(clonedSvg);\n        \n        // Create an Image object\n        const img = new Image();\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        const ctx = canvas.getContext('2d');\n        \n        // Set SVG as image source (as Data URL)\n        img.onload = function() {\n            // Fill background with white (SVG might have transparent background)\n            ctx.fillStyle = '#ffffff';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            \n            // Draw SVG image on canvas\n            ctx.drawImage(img, 0, 0);\n            \n            // Convert canvas to PNG and trigger download\n            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n            const pngUrl = canvas.toDataURL('image/png');\n            \n            const link = document.createElement('a');\n            link.href = pngUrl;\n            link.download = `infrastructure-map-${timestamp}.png`;\n            \n            document.body.appendChild(link);\n            link.click();\n            \n            // Clean up\n            setTimeout(() => {\n                document.body.removeChild(link);\n            }, 100);\n            \n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Visualization successfully downloaded as PNG', 'success');\n        };\n        \n        // Handle error\n        img.onerror = function() {\n            console.error('Error loading SVG into Image object');\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Error converting to PNG', 'danger');\n        };\n        \n        // Create a Blob containing the SVG and convert to Data URL\n        const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });\n        const reader = new FileReader();\n        reader.onload = function(e) {\n            img.src = e.target.result;\n        };\n        reader.readAsDataURL(blob);\n    } catch (error) {\n        console.error('Error downloading as PNG:', error);\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Error during download', 'danger');\n    }\n}\n\n\n//# sourceURL=webpack://infravis/./src/data-loader.js?");

/***/ }),

/***/ "./src/data-manager.js":
/*!*****************************!*\
  !*** ./src/data-manager.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataManager: () => (/* binding */ DataManager)\n/* harmony export */ });\n/* harmony import */ var _event_emitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-emitter.js */ \"./src/event-emitter.js\");\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utilities.js */ \"./src/utilities.js\");\n\n\n\n/**\n * Loads the system data from the YAML file\n * @returns {Promise<Object>} The parsed data object\n */\nfunction loadSystemData() {\n    try {\n        // Load YAML file\n        const yamlText = localStorage.getItem('systems_yaml');\n        if (!yamlText) {\n            throw new Error('Could not load system data from local storage');\n        }\n\n        // Parse YAML to JavaScript object\n        const parsedData = jsyaml.load(yamlText);\n\n        return parsedData;\n    } catch (error) {\n        console.log('Could not load data, fallback to new data set', error);\n        return {\n            systems: [],\n            dependencies: []\n        };\n    }\n}\n\n/**\n * Saves the system data as YAML in local storage\n * @param {Object} data - The system data to save\n */\nfunction saveSystemData(data) {\n    try {\n        const yamlText = jsyaml.dump(data);\n        localStorage.setItem('systems_yaml', yamlText);\n        console.log('Data saved successfully');\n    } catch (error) {\n        console.error('Error saving data:', error);\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)('Error saving data', 'danger');\n    }\n}\n\n\n/**\n * DataManager - Central class for managing system data\n * Serves as the single source of truth for all other components\n */\nclass DataManager extends _event_emitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor() {\n        super();\n        this.data = loadSystemData();\n        let saveTimeout = null;\n        this.on('dataChanged', () => {\n            if (saveTimeout) clearTimeout(saveTimeout);\n            saveTimeout = setTimeout(() => {\n                saveSystemData(this.data);\n                saveTimeout = null;\n            }, 500);\n        });\n    }\n\n    /**\n     * Initializes the DataManager with data\n     * @param {Object} data - The initial system data\n     */\n    initialize(data) {\n        if (data && data.systems && data.dependencies) {\n            this.data = data;\n        }\n        this.emit('dataChanged', this.data);\n    }\n\n    /**\n     * Returns the current system data\n     * @returns {Object} The system data\n     */\n    getData() {\n        return this.data;\n    }\n\n    /**\n     * Completely updates the system data\n     * @param {Object} newData - The new system data\n     */\n    setData(newData, notify = true) {\n        if (newData && newData.systems && newData.dependencies) {\n            this.data = newData;\n            notify && this.emit('dataChanged', this.data);\n        }\n    }\n\n    /**\n     * Completely removes the system data\n     * @param {Object} newData - The new system data\n     */\n    clearData(notify = true) {\n        this.setData({ systems: [], dependencies: [] }, notify);\n    }\n\n    /**\n     * Returns all unique groups present in the system data\n     * @returns {Array} Array of unique group names\n     */\n    getAllGroups() {\n        const groups = new Set();\n\n        this.data.systems.forEach(system => {\n            if (Array.isArray(system.groups)) {\n                system.groups.forEach(group => {\n                    if (group && group.trim() !== '') {\n                        groups.add(group);\n                    }\n                });\n            } else if (system.group && typeof system.group === 'string') {\n                groups.add(system.group);\n            }\n        });\n\n        return Array.from(groups).sort();\n    }\n\n    /**\n     * Helper function to ensure each system has a 'groups' array\n     * Converts single 'group' strings to arrays if necessary (backward compatibility)\n     * @param {Object} system - The system to check\n     */\n    ensureGroupsArray(system) {\n        // Case 1: system already has a groups array -> do nothing\n        if (Array.isArray(system.groups)) {\n            // Remove empty values and duplicates\n            system.groups = system.groups\n                .filter(group => group && group.trim() !== '')\n                .filter((group, index, self) => self.indexOf(group) === index);\n\n            // Remove legacy group field if present\n            delete system.group;\n            return;\n        }\n\n        // Case 2: system has a group field -> convert to groups array\n        if (typeof system.group === 'string' && system.group.trim() !== '') {\n            // If group is a comma-separated string, split\n            if (system.group.includes(',')) {\n                system.groups = system.group.split(',')\n                    .map(g => g.trim())\n                    .filter(g => g !== '');\n            } else {\n                system.groups = [system.group];\n            }\n            delete system.group;\n            return;\n        }\n\n        // Case 3: system has neither group nor groups\n        if (!system.groups) {\n            system.groups = [];\n            delete system.group; // Ensure no empty group field exists\n        }\n    }\n\n    /**\n     * Adds a new system\n     * @param {Object} system - The new system\n     * @returns {string} The ID of the added system\n     */\n    addSystem(system, notify = true) {\n        if (!system.id) {\n            system.id = this.generateUniqueId();\n        }\n\n        // Compatibility handling for converting 'group' to 'groups'\n        this.ensureGroupsArray(system);\n\n        this.data.systems.push(system);\n        notify && this.emit('dataChanged', this.data);\n        return system.id;\n    }\n\n    /**\n     * Updates an existing system\n     * @param {Object} updatedSystem - The updated system\n     * @returns {boolean} True if the system was found and updated\n     */\n    updateSystem(updatedSystem, notify = true) {\n        const index = this.data.systems.findIndex(sys => sys.id === updatedSystem.id);\n        if (index !== -1) {\n            // Compatibility handling for converting 'group' to 'groups'\n            this.ensureGroupsArray(updatedSystem);\n\n            this.data.systems[index] = updatedSystem;\n            notify && this.emit('dataChanged', this.data);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Deletes a system and associated dependencies\n     * @param {string} systemId - The ID of the system to delete\n     * @returns {boolean} True if the system was found and deleted\n     */\n    deleteSystem(systemId, notify = true) {\n        const systemIndex = this.data.systems.findIndex(sys => sys.id === systemId);\n        if (systemIndex === -1) return false;\n\n        // Delete system\n        this.data.systems.splice(systemIndex, 1);\n\n        // Delete associated dependencies\n        this.data.dependencies = this.data.dependencies.filter(\n            dep => dep.source !== systemId && dep.target !== systemId\n        );\n\n        notify && this.emit('dataChanged', this.data);\n        return true;\n    }\n\n    /**\n     * Adds a new dependency\n     * @param {Object} dependency - The new dependency\n     * @returns {boolean} True on success\n     */\n    addDependency(dependency, notify = true) {\n        // Check if source and target systems exist\n        const sourceExists = this.data.systems.some(sys => sys.id === dependency.source);\n        const targetExists = this.data.systems.some(sys => sys.id === dependency.target);\n\n        if (!sourceExists || !targetExists) return false;\n\n        this.data.dependencies.push(dependency);\n        notify && this.emit('dataChanged', this.data);\n        return true;\n    }\n\n    /**\n     * Deletes a dependency\n     * @param {Object} dependency - The dependency to delete (must contain source and target)\n     * @returns {boolean} True if the dependency was found and deleted\n     */\n    deleteDependency(dependency, notify = true) {\n        const index = this.data.dependencies.findIndex(\n            dep => dep.source === dependency.source && dep.target === dependency.target\n        );\n\n        if (index !== -1) {\n            this.data.dependencies.splice(index, 1);\n            notify && this.emit('dataChanged', this.data);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Applies a batch of changes at once and triggers only a single update event\n     * @param {Object} differences - Object with added, modified and removed arrays for systems and dependencies\n     * @returns {boolean} True on success\n     */\n    applyBatch(differences) {\n        if (!differences) return false;\n\n        try {\n            // Remove systems\n            if (differences.removed && differences.removed.systems) {\n                differences.removed.systems.forEach(system => {\n                    this.deleteSystem(system.id, false);\n                });\n            }\n\n            // Update systems\n            if (differences.modified && differences.modified.systems) {\n                differences.modified.systems.forEach(modifiedSystem => {\n                    this.updateSystem(modifiedSystem, false);\n                });\n            }\n\n            // Add new systems\n            if (differences.added && differences.added.systems) {\n                differences.added.systems.forEach(newSystem => {\n                    this.addSystem(newSystem, false);\n                });\n            }\n\n            // Remove dependencies\n            if (differences.removed && differences.removed.dependencies) {\n                differences.removed.dependencies.forEach(dependency => {\n                    this.deleteDependency(dependency, false);\n                });\n            }\n\n            // Update dependencies\n            if (differences.modified && differences.modified.dependencies) {\n                differences.modified.dependencies.forEach(modifiedDep => {\n                    // Delete and re-add, since updateDependency does not exist\n                    this.deleteDependency(modifiedDep, false);\n                    this.addDependency(modifiedDep, false);\n                });\n            }\n\n            // Add new dependencies\n            if (differences.added && differences.added.dependencies) {\n                differences.added.dependencies.forEach(newDep => {\n                    this.addDependency(newDep, false);\n                });\n            }\n\n            // Notify all listeners only once\n            this.emit('dataChanged', this.data);\n\n            return true;\n        } catch (error) {\n            console.error(\"Error applying batch changes:\", error);\n            return false;\n        }\n    }\n\n    /**\n     * Generates a unique ID\n     * @returns {string} A unique ID\n     */\n    generateUniqueId() {\n        const timestamp = new Date().getTime();\n        const randomPart = Math.floor(Math.random() * 10000);\n        return `sys_${timestamp}_${randomPart}`;\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/data-manager.js?");

/***/ }),

/***/ "./src/dependency-manager.js":
/*!***********************************!*\
  !*** ./src/dependency-manager.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DependencyManager: () => (/* binding */ DependencyManager)\n/* harmony export */ });\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities.js */ \"./src/utilities.js\");\n\n\n/**\n * DependencyManager - Manages adding and removing dependencies\n */\nclass DependencyManager {\n    constructor() {\n        this.initialized = false;\n        this.isConnectionModeActive = false;\n        this.sourceSystem = null;\n        this.tempLink = null;\n        this.mousePosition = { x: 0, y: 0 };\n        \n        // Default values for new connections\n        this.defaultConnectionType = \"data\";\n        this.defaultConnectionProtocol = \"API\";\n    }\n\n    /**\n     * Initializes the DependencyManager\n     */\n    initialize(dataManager, visualizer) {\n        if (this.initialized) return;\n        \n        this.dataManager = dataManager;\n        this.visualizer = visualizer;\n        \n        // Event listener for connection mode toggle\n        document.getElementById('toggle-connection-mode').addEventListener('click', () => {\n            this.toggleConnectionMode();\n        });\n        \n        // Event listener for data changes to keep connection mode active\n        this.dataManager.on('dataChanged', () => {\n            if (this.isConnectionModeActive) {\n                // Short delay to wait for UI update\n                setTimeout(() => {\n                    this.setupConnectionDrag();\n                }, 100);\n            }\n        });\n        \n        this.initialized = true;\n        console.log('DependencyManager has been initialized');\n    }\n\n    /**\n     * Toggles the connection mode on/off\n     */\n    toggleConnectionMode() {\n        this.isConnectionModeActive = !this.isConnectionModeActive;\n        const toggleButton = document.getElementById('toggle-connection-mode');\n        \n        if (this.isConnectionModeActive) {\n            document.body.classList.add('connection-mode');\n            toggleButton.classList.add('active');\n            toggleButton.title = 'Exit connection mode';\n            toggleButton.querySelector('i').className = 'bi bi-link-45deg';\n            \n            // Disable default drag and enable connection drag instead\n            this.visualizer.disableDrag(); // Set flag\n            this.setupConnectionDrag();\n            \n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Connection mode enabled: Drag from one system to another', 'info');\n        } else {\n            document.body.classList.remove('connection-mode');\n            toggleButton.classList.remove('active');\n            toggleButton.title = 'Connection mode';\n            toggleButton.querySelector('i').className = 'bi bi-link';\n            \n            // Remove connection drag and restore default drag\n            this.removeConnectionDrag();\n            this.visualizer.enableDrag(); // Reset flag\n            \n            // Cleanup\n            this.resetConnectionState();\n            \n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Connection mode disabled', 'info');\n        }\n    }\n\n    /**\n     * Sets up the drag mechanism for connections\n     */\n    setupConnectionDrag() {\n        if (!this.visualizer.nodeElements) return;\n        \n        // Remove connection drag if present\n        this.removeConnectionDrag();\n        \n        // Define drag function for connections\n        const connectionDrag = d3.drag()\n            .on(\"start\", (event, d) => this.handleDragStart(event, d))\n            .on(\"drag\", (event, d) => this.handleDragMove(event, d))\n            .on(\"end\", (event, d) => this.handleDragEnd(event, d));\n        \n        // Apply to nodes\n        this.visualizer.nodeElements.call(connectionDrag);\n    }\n    \n    /**\n     * Removes the connection drag mechanism\n     */\n    removeConnectionDrag() {\n        if (!this.visualizer.nodeElements) return;\n        \n        // Remove connection drag\n        this.visualizer.nodeElements.on('.drag', null);\n    }\n\n    /**\n     * Handles the start of a connection drag\n     */\n    handleDragStart(event, d) {\n        if (!this.isConnectionModeActive) return;\n        \n        // Set source system\n        this.sourceSystem = d;\n        \n        // Visually mark\n        d3.select(event.sourceEvent.target.closest('.node')).classed('connection-source', true);\n        \n        // Create temporary connection line\n        this.createTempLink(d);\n    }\n\n    /**\n     * Handles movement during a connection drag\n     */\n    handleDragMove(event, d) {\n        if (!this.isConnectionModeActive || !this.tempLink) return;\n        \n        // Update temporary line\n        this.tempLink.attr('d', `M${this.sourceSystem.x},${this.sourceSystem.y} L${event.x},${event.y}`);\n    }\n\n    /**\n     * Handles the end of a connection drag\n     */\n    handleDragEnd(event, d) {\n        if (!this.isConnectionModeActive || !this.sourceSystem) return;\n\n        // Verbesserte Touch-Erkennung: Event-Position sichern\n        const clientX = event.sourceEvent.type.startsWith('touch') \n            ? event.sourceEvent.changedTouches[0].clientX \n            : event.sourceEvent.clientX;\n        \n        const clientY = event.sourceEvent.type.startsWith('touch') \n            ? event.sourceEvent.changedTouches[0].clientY \n            : event.sourceEvent.clientY;\n        \n        // Check if released over another node\n        const targetElement = document.elementFromPoint(clientX, clientY);\n        const targetNode = targetElement ? targetElement.closest('.node') : null;\n        \n        if (targetNode) {\n            const targetSystemId = targetNode.getAttribute('data-system-id');\n            const targetSystem = this.dataManager.getData().systems.find(sys => sys.id === targetSystemId);\n            \n            if (targetSystem && targetSystem.id !== this.sourceSystem.id) {\n                // Create connection with default values\n                this.createConnection(this.sourceSystem, targetSystem);\n            } else if (targetSystem && targetSystem.id === this.sourceSystem.id) {\n                // Same node used as target\n                (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Source and target system cannot be identical.', 'warning');\n            }\n        }\n        \n        // Cleanup\n        this.resetConnectionState();\n    }\n\n    /**\n     * Creates a temporary connection line from the source system\n     */\n    createTempLink(sourceSystem) {\n        // Create temporary line\n        this.tempLink = this.visualizer.svg.select('g').append('path')\n            .attr('class', 'temp-link')\n            .attr('d', `M${sourceSystem.x},${sourceSystem.y} L${sourceSystem.x},${sourceSystem.y}`);\n    }\n\n    /**\n     * Creates a new connection with default values\n     */\n    createConnection(sourceSystem, targetSystem) {\n        // Create new dependency with default values\n        const newDependency = {\n            source: sourceSystem.id,\n            target: targetSystem.id,\n            type: this.defaultConnectionType,\n            description: `Connection from ${sourceSystem.name} to ${targetSystem.name}`,\n            protocol: this.defaultConnectionProtocol\n        };\n        \n        // Add dependency via DataManager\n        const success = this.dataManager.addDependency(newDependency);\n        \n        if (success) {\n            // Success message\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)(\n                `Connection from \"${sourceSystem.name}\" to \"${targetSystem.name}\" has been created`,\n                'success'\n            );\n        } else {\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Error creating connection', 'danger');\n        }\n    }\n\n    /**\n     * Resets the connection state\n     */\n    resetConnectionState() {\n        // Reset source system\n        if (this.sourceSystem) {\n            d3.selectAll('.node').classed('connection-source', false);\n            this.sourceSystem = null;\n        }\n        \n        // Remove temporary line\n        if (this.tempLink) {\n            this.tempLink.remove();\n            this.tempLink = null;\n        }\n    }\n\n    /**\n     * Shows the delete control for a connection\n     */\n    showLinkControls(event, linkData) {\n        // Do not show controls in connection mode\n        if (this.isConnectionModeActive) return;\n        \n        // Remove existing controls\n        this.hideLinkControls();\n        \n        // Create new controls\n        const controls = document.createElement('div');\n        controls.className = 'link-controls';\n        controls.innerHTML = `\n            <button class=\"link-delete-btn\" title=\"Delete connection\">\n                <i class=\"bi bi-trash\"></i>\n            </button>\n        `;\n        \n        // Set position\n        controls.style.left = `${event.pageX}px`;\n        controls.style.top = `${event.pageY}px`;\n        \n        // Add to DOM\n        document.body.appendChild(controls);\n        \n        // Store link data in attribute\n        controls.setAttribute('data-source', linkData.source.id || linkData.source);\n        controls.setAttribute('data-target', linkData.target.id || linkData.target);\n        \n        // Event listener for delete button\n        controls.querySelector('.link-delete-btn').addEventListener('click', () => {\n            this.showDeleteDependencyConfirmation(linkData);\n            this.hideLinkControls();\n        });\n        \n        // Show controls\n        controls.style.display = 'block';\n        \n        // Click outside to close\n        document.addEventListener('click', (e) => {\n            if (!controls.contains(e.target) && e.target !== event.target) {\n                this.hideLinkControls();\n            }\n        }, { once: true });\n    }\n\n    /**\n     * Hides the link controls\n     */\n    hideLinkControls() {\n        const existingControls = document.querySelector('.link-controls');\n        if (existingControls) {\n            existingControls.remove();\n        }\n    }\n\n    /**\n     * Shows a confirmation prompt to delete a dependency\n     */\n    showDeleteDependencyConfirmation(linkData) {\n        const sourceId = linkData.source.id || linkData.source;\n        const targetId = linkData.target.id || linkData.target;\n        \n        const sourceSystem = this.dataManager.getData().systems.find(sys => sys.id === sourceId);\n        const targetSystem = this.dataManager.getData().systems.find(sys => sys.id === targetId);\n        \n        if (!sourceSystem || !targetSystem) return;\n        \n        // Confirmation message\n        const message = `Do you really want to delete the connection from \"${sourceSystem.name}\" to \"${targetSystem.name}\"?`;\n        \n        document.getElementById('confirm-message').innerHTML = message;\n        document.getElementById('confirm-action').setAttribute('data-action', 'delete-dependency');\n        document.getElementById('confirm-action').setAttribute('data-source', sourceId);\n        document.getElementById('confirm-action').setAttribute('data-target', targetId);\n        \n        // Show modal\n        const modal = new bootstrap.Modal(document.getElementById('confirm-modal'));\n        modal.show();\n    }\n\n    /**\n     * Deletes a dependency\n     */\n    deleteDependency(sourceId, targetId) {\n        // Find systems for notification\n        const sourceSystem = this.dataManager.getData().systems.find(sys => sys.id === sourceId);\n        const targetSystem = this.dataManager.getData().systems.find(sys => sys.id === targetId);\n        \n        if (!sourceSystem || !targetSystem) return;\n        \n        // Delete dependency via DataManager\n        const success = this.dataManager.deleteDependency({\n            source: sourceId,\n            target: targetId\n        });\n        \n        if (success) {\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)(\n                `Connection from \"${sourceSystem.name}\" to \"${targetSystem.name}\" has been deleted`,\n                'success'\n            );\n        } else {\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Error deleting connection', 'danger');\n        }\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/dependency-manager.js?");

/***/ }),

/***/ "./src/event-emitter.js":
/*!******************************!*\
  !*** ./src/event-emitter.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter)\n/* harmony export */ });\n/**\n * A simple EventEmitter class for managing custom events.\n *\n * @class\n * @example\n * const emitter = new EventEmitter();\n * emitter.on('event', data => console.log(data));\n * emitter.emit('event', { foo: 'bar' });\n */\nclass EventEmitter {\n    /**\n     * Initializes the EventEmitter instance.\n     * @constructor\n     */\n    constructor() {\n        this.events = {};\n    }\n\n    /**\n     * Registers a callback for the specified event.\n     * @param {string} eventName - The name of the event.\n     * @param {Function} callback - The callback function to register.\n     * @returns {EventEmitter} The instance for chaining.\n     */\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(callback);\n        return this; // for chaining\n    }\n\n    /**\n     * Removes a callback for the specified event.\n     * If no callback is provided, removes all callbacks for the event.\n     * @param {string} eventName - The name of the event.\n     * @param {Function} [callback] - The callback function to remove.\n     * @returns {EventEmitter} The instance for chaining.\n     */\n    off(eventName, callback) {\n        if (!this.events[eventName]) return this;\n\n        if (callback) {\n            this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);\n        } else {\n            delete this.events[eventName];\n        }\n        return this;\n    }\n\n    /**\n     * Emits an event, calling all registered callbacks with the provided arguments.\n     * @param {string} eventName - The name of the event.\n     * @param {...any} args - Arguments to pass to the callbacks.\n     * @returns {boolean} True if the event had listeners, false otherwise.\n     */\n    emit(eventName, ...args) {\n        if (!this.events[eventName]) return false;\n\n        this.events[eventName].forEach(callback => {\n            callback(...args);\n        });\n        return true;\n    }\n\n    /**\n     * Registers a callback that is called at most once for the specified event.\n     * @param {string} eventName - The name of the event.\n     * @param {Function} callback - The callback function to register.\n     * @returns {EventEmitter} The instance for chaining.\n     */\n    once(eventName, callback) {\n        const onceCallback = (...args) => {\n            this.off(eventName, onceCallback);\n            callback(...args);\n        };\n\n        return this.on(eventName, onceCallback);\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/event-emitter.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _data_manager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data-manager.js */ \"./src/data-manager.js\");\n/* harmony import */ var _visualizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./visualizer.js */ \"./src/visualizer.js\");\n/* harmony import */ var _dependency_manager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dependency-manager.js */ \"./src/dependency-manager.js\");\n/* harmony import */ var _system_manager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./system-manager.js */ \"./src/system-manager.js\");\n/* harmony import */ var _llm_integration_manager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./llm-integration-manager.js */ \"./src/llm-integration-manager.js\");\n/* harmony import */ var _data_loader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data-loader.js */ \"./src/data-loader.js\");\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utilities.js */ \"./src/utilities.js\");\n\n\n\n\n\n\n\n\ndocument.addEventListener('DOMContentLoaded', async () => {\n    // Systemdaten laden und DataManager initialisieren\n    const dataManager = new _data_manager_js__WEBPACK_IMPORTED_MODULE_0__.DataManager();\n    console.log('Systemdaten geladen:', dataManager.data);\n\n    // Visualizer erstellen und mit DataManager verknüpfen\n    const visualizer = new _visualizer_js__WEBPACK_IMPORTED_MODULE_1__.SystemVisualizer('visualization-container', dataManager);\n    visualizer.initialize();\n\n    // DependencyManager initialisieren\n    const dependencyManager = new _dependency_manager_js__WEBPACK_IMPORTED_MODULE_2__.DependencyManager();\n    dependencyManager.initialize(dataManager, visualizer);\n\n    // Visualizer Dependency-Klick an Dependency-Manager weitergeben übergeben\n    visualizer.on('dependencyClick', (ref) => {\n        const { event, data } = ref;\n        dependencyManager.showLinkControls(event, data)\n    });\n    window.vis = visualizer;\n\n    // SystemManager initialisieren\n    const systemManager = new _system_manager_js__WEBPACK_IMPORTED_MODULE_3__.SystemManager();\n    systemManager.initialize(dataManager);\n\n    // LLM-Integration initialisieren (NEU)\n    const llmManager = new _llm_integration_manager_js__WEBPACK_IMPORTED_MODULE_4__.LlmIntegrationManager({\n        apiKey: (await (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.retrieveAndDecrypt)(\"llmApiKey\")) || \"\", // API-Key aus localStorage\n        llmType: localStorage.getItem(\"llmType\") || \"\", // claude, openai, custom\n        llmModel: localStorage.getItem(\"llmModel\") || \"\", // Modell je nach LLM-Typ, e.g. claude-3-7-sonnet-20250219\n        llmSystemPrompt: localStorage.getItem(\"llmSystemPrompt\") || \"\", // Modell je nach LLM-Typ, e.g. claude-3-7-sonnet-20250219\n        llmPromptPrefix: localStorage.getItem(\"llmPromptPrefix\") || \"\", // Modell je nach LLM-Typ, e.g. claude-3-7-sonnet-20250219\n        // llmUrl: \"https://deine-custom-api-url.com\", // Nur für custom-Typ\n    });\n    llmManager.initialize(dataManager);\n\n    // Chat-Interface einrichten (NEU)\n    setupLlmChatInterface(llmManager);\n\n    window.llm = llmManager; // Optional: Für Zugriff über die Konsole\n\n    setupGroupsUI(systemManager);\n\n    // Toggle-Buttons für die Overlays\n    document.getElementById('toggle-search').addEventListener('click', () => toggleOverlay('search-panel'));\n    document.getElementById('toggle-filters').addEventListener('click', () => toggleOverlay('filter-panel'));\n    document.getElementById('toggle-legend').addEventListener('click', () => toggleOverlay('legend-panel'));\n\n    // Event-Listener für den Upload-Button\n    document.getElementById('upload-data').addEventListener('click', () => (0,_data_loader_js__WEBPACK_IMPORTED_MODULE_5__.uploadSystemData)(dataManager));\n\n    // Event-Listener für den Download-Button\n    document.getElementById('download-data').addEventListener('click', () => (0,_data_loader_js__WEBPACK_IMPORTED_MODULE_5__.downloadSystemData)(dataManager));\n\n    // Event-Listener für den Add-System-Button\n    document.getElementById('add-system').addEventListener('click', () => systemManager.showSystemModal());\n\n    // \"System speichern\"-Button Event im Modal\n    document.getElementById('save-system').addEventListener('click', () => systemManager.saveSystem());\n\n    // \"System speichern\"-Button Event im Modal\n    document.getElementById('clear-data').addEventListener('click', () => {\n        // Öffne das Reset-Modal\n        const resetModal = new bootstrap.Modal(document.getElementById('reset-modal'));\n        resetModal.show();\n\n        // Handler entfernen, um Mehrfachbindung zu vermeiden\n        document.getElementById('reset-modal-llm-action').onclick = null;\n        document.getElementById('reset-modal-data-action').onclick = null;\n        document.getElementById('reset-modal-all-action').onclick = null;\n\n        // Nur LLM-Konfiguration zurücksetzen\n        document.getElementById('reset-modal-llm-action').onclick = () => {\n            localStorage.removeItem(\"llmType\");\n            localStorage.removeItem(\"llmModel\");\n            localStorage.removeItem(\"llmSystemPrompt\");\n            localStorage.removeItem(\"llmPromptPrefix\");\n            localStorage.removeItem(\"llmApiKey\", \"\"); // Leeren Key speichern\n            llmManager.updateConfig();\n            document.getElementById('llm-chat-container').style.display = 'none';\n            resetModal.hide();\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.showNotification)(\"LLM-Konfiguration wurde zurückgesetzt.\", \"info\");\n        };\n\n        // Nur Daten zurücksetzen\n        document.getElementById('reset-modal-data-action').onclick = () => {\n            dataManager.clearData();\n            visualizer.nodeCache.clear(true);\n            resetModal.hide();\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.showNotification)(\"Daten wurden zurückgesetzt.\", \"info\");\n        };\n\n        // Alles zurücksetzen\n        document.getElementById('reset-modal-all-action').onclick = () => {\n            dataManager.clearData();\n            visualizer.nodeCache.clear(true);\n            localStorage.clear();\n            llmManager.updateConfig();\n            document.getElementById('llm-chat-container').style.display = 'none';\n            resetModal.hide();\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.showNotification)(\"All data and configurations have been deleted.\", \"info\");\n        };\n    });\n\n    // Event-Handler für Bearbeiten- und Löschen-Buttons in der Detailansicht\n    document.querySelector('.edit-system-btn').addEventListener('click', () => {\n        const systemId = document.getElementById('detail-title').getAttribute('data-system-id');\n        if (systemId) {\n            systemManager.showSystemModal(systemId);\n        }\n    });\n\n    document.querySelector('.delete-system-btn').addEventListener('click', () => {\n        const systemId = document.getElementById('detail-title').getAttribute('data-system-id');\n        if (systemId) {\n            systemManager.showDeleteConfirmation(systemId);\n        }\n    });\n\n    // Event-Handler für Bestätigungs-Modal\n    document.getElementById('confirm-action').addEventListener('click', () => {\n        const confirmAction = document.getElementById('confirm-action').getAttribute('data-action');\n        const confirmId = document.getElementById('confirm-action').getAttribute('data-id');\n\n        if (confirmAction === 'delete-system' && confirmId) {\n            systemManager.deleteSystem(confirmId);\n            bootstrap.Modal.getInstance(document.getElementById('confirm-modal')).hide();\n        } else if (confirmAction === 'delete-dependency') {\n            const sourceId = document.getElementById('confirm-action').getAttribute('data-source');\n            const targetId = document.getElementById('confirm-action').getAttribute('data-target');\n            if (sourceId && targetId) {\n                dependencyManager.deleteDependency(sourceId, targetId);\n                bootstrap.Modal.getInstance(document.getElementById('confirm-modal')).hide();\n            }\n        }\n    });\n\n    document.querySelector('.toggle-fix-btn').addEventListener('click', () => {\n        const systemId = document.getElementById('detail-title').getAttribute('data-system-id');\n        if (systemId) {\n            const isNowFixed = visualizer.toggleNodeFixed(systemId);\n        }\n    });\n\n    visualizer.on('toggleFixed', (data) => {\n        const systemId = document.getElementById('detail-title').getAttribute('data-system-id');\n        const { id, state } = data;\n\n        if (id !== systemId) return;\n\n        const toggleButton = document.querySelector('.toggle-fix-btn');\n        if (state) {\n            toggleButton.classList.add('active');\n            toggleButton.title = 'Release position';\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.showNotification)('Position has been fixed', 'info');\n        } else {\n            toggleButton.classList.remove('active');\n            toggleButton.title = 'Fix position';\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.showNotification)('Position has been released', 'info');\n        }\n    });\n\n    // Close-Buttons in den Overlays\n    document.querySelectorAll('.close-overlay').forEach(btn => {\n        btn.addEventListener('click', () => {\n            const targetId = btn.getAttribute('data-close-target');\n            document.getElementById(targetId).classList.remove('active');\n        });\n    });\n\n    // Overlay-Funktion\n    function toggleOverlay(id) {\n        const panel = document.getElementById(id);\n\n        // Alle anderen Overlays schließen\n        document.querySelectorAll('.overlay').forEach(overlay => {\n            if (overlay.id !== id) overlay.classList.remove('active');\n        });\n\n        // Ausgewähltes Overlay umschalten\n        panel.classList.toggle('active');\n    }\n});\nfunction setupGroupsUI(systemManager) {\n    const groupInput = document.getElementById('system-groups-input');\n    const addButton = document.getElementById('add-group-btn');\n\n    // Event-Listener für das Hinzufügen von Gruppen mit dem Button\n    addButton.addEventListener('click', () => {\n        const value = groupInput.value.trim();\n        if (value) {\n            // Wenn Kommas enthalten sind, mehrere Gruppen gleichzeitig hinzufügen\n            if (value.includes(',')) {\n                const groups = value.split(',').map(g => g.trim()).filter(g => g !== '');\n                groups.forEach(group => systemManager.addGroupBadge(group));\n            } else {\n                systemManager.addGroupBadge(value);\n            }\n            groupInput.value = '';\n        }\n    });\n\n    // Event-Listener für das Hinzufügen von Gruppen mit Enter\n    groupInput.addEventListener('keydown', (event) => {\n        if (event.key === 'Enter') {\n            event.preventDefault();\n            addButton.click();\n        }\n    });\n\n    // Auto-Vervollständigung bei Komma\n    groupInput.addEventListener('input', () => {\n        const value = groupInput.value;\n        if (value.endsWith(',')) {\n            const newGroup = value.slice(0, -1).trim();\n            if (newGroup) {\n                systemManager.addGroupBadge(newGroup);\n                groupInput.value = '';\n            }\n        }\n    });\n}\n// Diese Funktion nach der LlmIntegrationManager-Initialisierung aufrufen\nfunction setupLlmChatInterface(llmManager) {\n    // UI-Elemente\n    const chatContainer = document.getElementById('llm-chat-container');\n    const chatMessages = document.getElementById('llm-chat-messages');\n    const chatInput = document.getElementById('llm-chat-input');\n    const sendButton = document.getElementById('llm-chat-send');\n    const closeButton = document.getElementById('llm-chat-close');\n    const loadingIndicator = document.getElementById('llm-chat-loading');\n    const toggleLlmChat = document.getElementById('toggle-llm-chat');\n    const saveLlmConfig = document.getElementById('save-llm-config');\n    const cancelLlmConfig = document.getElementById('cancel-llm-config');\n\n    function isVisible() {\n        return !chatContainer.classList.contains('active');\n    }\n\n    // Toggle-Button zur Controls-Leiste hinzufügen\n    const controlsOverlay = document.querySelector('.controls-overlay .btn-group');\n    if (controlsOverlay) {\n        // Event-Listener für den Toggle-Button\n        toggleLlmChat.addEventListener('click', toggleChat);\n    }\n\n    const hiddenKeyIfNotEmpty = \"-----hidden-----\";\n    const configModal = new bootstrap.Modal(document.getElementById('llm-config-modal'));\n    function changeLlmConfig() {\n        // Felder mit gespeicherter Konfiguration befüllen\n        document.getElementById('llm-type').value = localStorage.getItem(\"llmType\") || \"claude\";\n        document.getElementById('llm-api-key').value = localStorage.getItem(\"llmApiKey\") ? hiddenKeyIfNotEmpty : \"\";\n        document.getElementById('llm-model').value = localStorage.getItem(\"llmModel\") || \"\";\n        document.getElementById('llm-system-prompt').value = localStorage.getItem(\"llmSystemPrompt\") || llmManager.getDefaultSystemPrompt();\n        document.getElementById('llm-prompt-prefix').value = localStorage.getItem(\"llmPromptPrefix\") || llmManager.getDefaultPromptPrefix();\n        configModal.show();\n    }\n\n    function checkIfConfiguratedOrCloseChat() {\n        if (!llmManager.isConfigurated()) {\n            if (isVisible()) {\n                chatContainer.style.display = 'none';\n                toggleLlmChat.classList.remove('active');\n                (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.showNotification)(\"Please configure the chat assistant.\", \"warning\");\n            }\n            return false;\n        }\n        return true;\n    }\n\n    if (!llmManager.isConfigurated()) {\n        chatContainer.style.display = 'none';\n    }\n\n    function addWelcome() {\n        if (chatMessages.children.length === 0) {\n            addSystemMessage(\"How can I assist you with managing your IT infrastructure? You can describe changes to me, and I will update the model for you.\");\n        }\n    }\n\n    function saveConfig() {\n        const llmType = document.getElementById('llm-type').value;\n        const llmApiKey = document.getElementById('llm-api-key').value;\n        const llmModel = document.getElementById('llm-model').value;\n        const llmSystemPrompt = document.getElementById('llm-system-prompt').value;\n        const llmPromptPrefix = document.getElementById('llm-prompt-prefix').value;\n\n        // Konfiguration speichern\n        localStorage.setItem(\"llmType\", llmType);\n        if (llmApiKey !== hiddenKeyIfNotEmpty) {\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_6__.encryptAndStore)(\"llmApiKey\", llmApiKey).then(() => {\n                console.log(\"API key saved\");\n            }).catch((error) => {\n                console.error(\"Error saving API key:\", error);\n            });\n        }\n        localStorage.setItem(\"llmModel\", llmModel);\n        localStorage.setItem(\"llmSystemPrompt\", llmSystemPrompt);\n        localStorage.setItem(\"llmPromptPrefix\", llmPromptPrefix);\n        llmManager.updateConfig(llmType, llmModel, llmApiKey, llmSystemPrompt, llmPromptPrefix);\n        if (checkIfConfiguratedOrCloseChat()) {\n            chatContainer.style.display = 'flex';\n            if (isVisible()) {\n                chatInput.focus();\n                addWelcome();\n            }\n        }\n        configModal.hide();\n    }\n\n    document.getElementById('llm-chat-settings').addEventListener('click', changeLlmConfig);\n    document.querySelector('#llm-config-modal .btn-close').addEventListener('click', () => {\n        checkIfConfiguratedOrCloseChat();\n    });\n    cancelLlmConfig.addEventListener('click', () => {\n        checkIfConfiguratedOrCloseChat();\n    });\n    saveLlmConfig.addEventListener('click', () => {\n        saveConfig();\n    });\n\n    // Chat öffnen/schließen\n    function toggleChat() {\n        const wasVisible = isVisible();\n        if (wasVisible) {\n            chatContainer.classList.add('active');\n            toggleLlmChat.classList.remove('active');\n        } else {\n            chatContainer.classList.remove('active');\n            toggleLlmChat.classList.add('active');\n        }\n\n        if (!wasVisible) {\n            if (!llmManager.isConfigurated()) {\n                changeLlmConfig();\n            } else {\n                chatInput.focus();\n                addWelcome();\n            }\n        }\n    }\n\n    chatInput.addEventListener('focus', () => {\n        if (chatContainer.classList.contains('active')) {\n            chatContainer.classList.remove('active');\n            if (!llmManager.isConfigurated()) {\n                changeLlmConfig();\n            } else {\n                addWelcome();\n            }\n        }\n    });\n\n    // Let chat input grow (chatInput)\n    chatInput.addEventListener('input', () => {\n        chatInput.style.height = 'auto';\n        const maxRows = 3;\n        const lines = chatInput.value.split('\\n').length;\n        const rows = Math.min(lines, maxRows);\n        chatInput.rows = rows;\n    });\n\n    // Close-Button\n    closeButton.addEventListener('click', () => {\n        chatContainer.classList.add('active');\n        document.getElementById('toggle-llm-chat').classList.remove('active');\n    });\n\n    // Send messages\n    sendButton.addEventListener('click', sendMessage);\n\n    // Enter key to send (without Shift)\n    chatInput.addEventListener('keydown', (event) => {\n        if (event.key === 'Enter' && !event.shiftKey) {\n            event.preventDefault();\n            sendMessage();\n        }\n    });\n\n    // Send message and process LLM response\n    async function sendMessage() {\n        const userInput = chatInput.value.trim();\n        if (!userInput) return;\n\n        // Display user input\n        addUserMessage(userInput);\n        chatInput.value = '';\n\n        // Show loading indicator\n        loadingIndicator.style.display = 'flex';\n\n        // Build current message in the UI\n        let currentAssistantMessage = '';\n        const messageElement = addAssistantMessage('');\n\n        // Process LLM request\n        let currentResult = \"\";\n        const result = await llmManager.processUserInput(userInput, (token) => {\n            currentResult += token;\n            messageElement.innerHTML = marked ? marked.parse(currentResult) : currentResult;\n        });\n        console.log(result);\n\n        // Hide loading indicator\n        loadingIndicator.style.display = 'none';\n\n        // Display response\n        messageElement.innerHTML = marked ? marked.parse(result.originalResponse) : result.originalResponse;\n\n        // If YAML response with changes\n        if (result.success && result.yamlData) {\n            showUpdateConfirmation(result.yamlData, result.differences);\n        }\n    }\n\n    // Shows confirmation dialog for changes\n    function showUpdateConfirmation(newData, differences) {\n        // Only show confirmation if there are changes\n        if (\n            differences.added.systems.length === 0 &&\n            differences.modified.systems.length === 0 &&\n            differences.removed.systems.length === 0 &&\n            differences.added.dependencies.length === 0 &&\n            differences.modified.dependencies.length === 0 &&\n            differences.removed.dependencies.length === 0\n        ) {\n            return;\n        }\n\n        // Create summary of changes\n        let summaryText = \"The following changes were detected:\\n\\n\";\n\n        // Systems\n        if (differences.added.systems.length > 0) {\n            summaryText += `➕ ${differences.added.systems.length} new systems: ${differences.added.systems.map(s => s.name).join(', ')}\\n`;\n        }\n        if (differences.modified.systems.length > 0) {\n            summaryText += `✏️ ${differences.modified.systems.length} modified systems: ${differences.modified.systems.map(s => s.name).join(', ')}\\n`;\n        }\n        if (differences.removed.systems.length > 0) {\n            summaryText += `❌ ${differences.removed.systems.length} removed systems: ${differences.removed.systems.map(s => s.name).join(', ')}\\n`;\n        }\n\n        // Dependencies\n        if (differences.added.dependencies.length > 0) {\n            summaryText += `➕ ${differences.added.dependencies.length} new connections\\n`;\n        }\n        if (differences.modified.dependencies.length > 0) {\n            summaryText += `✏️ ${differences.modified.dependencies.length} modified connections\\n`;\n        }\n        if (differences.removed.dependencies.length > 0) {\n            summaryText += `❌ ${differences.removed.dependencies.length} removed connections\\n`;\n        }\n\n        // Create message\n        const messageElement = document.createElement('div');\n        messageElement.className = 'llm-chat-message llm-system-message';\n        messageElement.textContent = summaryText;\n\n        // Add action buttons\n        const actionsDiv = document.createElement('div');\n        actionsDiv.className = 'llm-update-actions';\n\n        const applyButton = document.createElement('button');\n        applyButton.className = 'btn btn-primary';\n        applyButton.textContent = 'Apply changes';\n        applyButton.addEventListener('click', () => {\n            // Update data in DataManager\n            llmManager.applyChanges(differences);\n\n            // Show feedback\n            addSystemMessage(\"The changes have been applied successfully.\");\n\n            // Remove button container\n            messageElement.removeChild(actionsDiv);\n        });\n\n        const cancelButton = document.createElement('button');\n        cancelButton.className = 'btn btn-outline-secondary';\n        cancelButton.textContent = 'Discard';\n        cancelButton.addEventListener('click', () => {\n            addSystemMessage(\"The changes have been discarded.\");\n\n            // Remove button container\n            messageElement.removeChild(actionsDiv);\n        });\n\n        actionsDiv.appendChild(applyButton);\n        actionsDiv.appendChild(cancelButton);\n        messageElement.appendChild(actionsDiv);\n\n        // Add to chat\n        chatMessages.appendChild(messageElement);\n        chatMessages.scrollTop = chatMessages.scrollHeight;\n    }\n\n    function addUserMessage(message) {\n        const messageElement = document.createElement('div');\n        messageElement.className = 'llm-chat-message llm-user-message';\n        messageElement.textContent = message;\n        chatMessages.appendChild(messageElement);\n        chatMessages.scrollTop = chatMessages.scrollHeight;\n        return messageElement;\n    }\n\n    function addAssistantMessage(message) {\n        const messageElement = document.createElement('div');\n        messageElement.className = 'llm-chat-message llm-assistant-message';\n        messageElement.innerHTML = message;\n        chatMessages.appendChild(messageElement);\n        chatMessages.scrollTop = chatMessages.scrollHeight;\n        return messageElement;\n    }\n\n    function addSystemMessage(message) {\n        const messageElement = document.createElement('div');\n        messageElement.className = 'llm-chat-message llm-system-message';\n        messageElement.textContent = message;\n        chatMessages.appendChild(messageElement);\n        chatMessages.scrollTop = chatMessages.scrollHeight;\n        return messageElement;\n    }\n\n    function setupImageExport() {\n        const downloadButton = document.getElementById('download-image');\n\n        if (!downloadButton) {\n            console.warn('Download image button not found');\n            return;\n        }\n\n        // Track whether the dropup is currently visible\n        let dropupVisible = false;\n        let dropupMenu = null;\n\n        // Event listener for the button\n        downloadButton.addEventListener('click', function (event) {\n            event.stopPropagation();\n\n            // If the menu is already shown, remove it\n            if (dropupVisible && dropupMenu) {\n                document.body.removeChild(dropupMenu);\n                dropupVisible = false;\n                return;\n            }\n\n            // Create a dropdown menu below the button\n            dropupMenu = document.createElement('div');\n            dropupMenu.className = 'dropdown-menu show';\n            dropupMenu.style.position = 'absolute';\n\n            // Calculate position (below the button as a dropdown)\n            const buttonRect = downloadButton.getBoundingClientRect();\n            dropupMenu.style.top = (buttonRect.bottom + 5) + 'px'; // 5px gap to the button\n            dropupMenu.style.left = buttonRect.left + 'px';\n            dropupMenu.style.minWidth = '140px';\n            dropupMenu.style.backgroundColor = '#fff';\n            dropupMenu.style.border = '1px solid rgba(0,0,0,.15)';\n            dropupMenu.style.borderRadius = '.25rem';\n            dropupMenu.style.padding = '.5rem 0';\n            dropupMenu.style.zIndex = '1000';\n            dropupMenu.style.boxShadow = '0 0.5rem 1rem rgba(0, 0, 0, 0.15)';\n\n            // Add menu items\n            dropupMenu.innerHTML = `\n            <a class=\"dropdown-item px-3 py-2\" href=\"#\" id=\"download-svg\">\n                <i class=\"bi bi-filetype-svg me-2\"></i>As SVG\n            </a>\n            <a class=\"dropdown-item px-3 py-2\" href=\"#\" id=\"download-png\">\n                <i class=\"bi bi-filetype-png me-2\"></i>As PNG\n            </a>\n        `;\n\n            // Add to body\n            document.body.appendChild(dropupMenu);\n            dropupVisible = true;\n\n            // Event listeners for menu items\n            document.getElementById('download-svg').addEventListener('click', function (e) {\n                e.preventDefault();\n                (0,_data_loader_js__WEBPACK_IMPORTED_MODULE_5__.downloadVisualizationAsSVG)();\n                document.body.removeChild(dropupMenu);\n                dropupVisible = false;\n            });\n\n            document.getElementById('download-png').addEventListener('click', function (e) {\n                e.preventDefault();\n                (0,_data_loader_js__WEBPACK_IMPORTED_MODULE_5__.downloadVisualizationAsPNG)();\n                document.body.removeChild(dropupMenu);\n                dropupVisible = false;\n            });\n\n            // Clicking outside the menu closes it\n            document.addEventListener('click', function closeDropup(e) {\n                if (dropupVisible && !dropupMenu.contains(e.target) && e.target !== downloadButton) {\n                    document.body.removeChild(dropupMenu);\n                    dropupVisible = false;\n                    document.removeEventListener('click', closeDropup);\n                }\n            });\n        });\n\n        console.log('Image export functionality has been added');\n    }\n\n    setupImageExport();\n}\n\n//# sourceURL=webpack://infravis/./src/index.js?");

/***/ }),

/***/ "./src/llm-integration-manager.js":
/*!****************************************!*\
  !*** ./src/llm-integration-manager.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LlmIntegrationManager: () => (/* binding */ LlmIntegrationManager)\n/* harmony export */ });\n/* harmony import */ var _completion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./completion.js */ \"./src/completion.js\");\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utilities.js */ \"./src/utilities.js\");\n\n\n\n/**\n * LlmIntegrationManager - Manages the integration of an LLM into the system visualization.\n * Focuses on the core functionality of LLM communication and data model updates.\n */\nclass LlmIntegrationManager {\n    constructor(options = {}) {\n        this.dataManager = null;\n        this.initialized = false;\n        this.isProcessing = false;\n\n        // Configuration with default values\n        this.config = {\n            apiKey: options.apiKey || \"\",\n            llmType: options.llmType || \"\", // claude, openai, custom\n            llmModel: options.llmModel || \"\", // like claude-3-7-sonnet-20250219\n            llmUrl: options.llmUrl || \"\", // Only needed for custom\n            systemPrompt: options.systemPrompt || \"\",\n            promptPrefix: options.promptPrefix || \"\",\n            onMessageReceived: options.onMessageReceived || null,\n            onTyping: options.onTyping || null\n        };\n    }\n\n    /**\n     * Updates the LLM integration configuration with the provided parameters.\n     *\n     * @param {string} llmType - The type of the language model (e.g., 'openai', 'anthropic').\n     * @param {string} llmModel - The specific model to use (e.g., 'gpt-4', 'claude-2').\n     * @param {string} llmApiKey - The API key for authenticating requests to the LLM service.\n     * @param {string} [llmSystemPrompt] - Optional system prompt to use; defaults to the class's default if not provided.\n     * @param {string} [llmPromptPrefix] - Optional prefix to prepend to prompts; defaults to an empty string if not provided.\n     */\n    updateConfig(llmType = undefined, llmModel = undefined, llmApiKey = undefined, llmSystemPrompt = undefined, llmPromptPrefix = undefined) {\n        this.config.llmType = llmType;\n        this.config.llmModel = llmModel;\n        this.config.apiKey = llmApiKey;\n        this.config.systemPrompt = llmSystemPrompt || this.getDefaultSystemPrompt();\n        this.config.promptPrefix = llmPromptPrefix || this.getDefaultPromptPrefix();\n\n        if(this.isConfigurated()) {\n            this.createLlmGenerator();\n        }\n    }\n\n    /**\n     * Checks if the configuration is complete by verifying the presence of\n     * `apiKey`, `llmType`, and `llmModel` properties in the config object.\n     *\n     * @returns {boolean} Returns `true` if all required configuration properties are set; otherwise, `false`.\n     */\n    isConfigurated() {\n        return this.config.apiKey && this.config.llmType && this.config.llmModel;\n    }\n\n    /**\n     * Initializes the LlmIntegrationManager\n     * @param {DataManager} dataManager - The DataManager for data management\n     */\n    initialize(dataManager) {\n        if (this.initialized) return;\n\n        if (!dataManager) {\n            console.error(\"No DataManager provided\");\n            return;\n        }\n\n        this.dataManager = dataManager;\n\n        this.initialized = true;\n        console.log(\"LlmIntegrationManager has been initialized\");\n    }\n\n    /**\n     * Creates the LLM generator based on the configuration\n     */\n    createLlmGenerator() {\n        const variables = {\n            example: this.getExampleDataAsPromptBlock(),\n            dataStructure: this.getDataStructureAsPromptBlock()\n        };\n\n        // Create generator using the createGenerator function\n        const generator = (0,_completion_js__WEBPACK_IMPORTED_MODULE_0__.createGenerator)(\n            variables,\n            this.config.systemPrompt || this.getDefaultSystemPrompt(),\n            this.config.promptPrefix || this.getDefaultPromptPrefix(),\n            {\n                llmType: this.config.llmType,\n                llmModel: this.config.llmModel,\n                llmApiKey: this.config.apiKey,\n                llmUrl: this.config.llmUrl\n            }\n        );\n\n        if (!generator) {\n            console.error(\"Error creating the LLM generator\");\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(\"LLM integration could not be initialized\", \"danger\");\n        }\n\n        return generator;\n    }\n\n    /**\n     * Processes a user request and sends it to the LLM\n     * @param {string} userInput - The user input\n     * @returns {Promise<Object>} - Processing result with response and data changes\n     */\n    async processUserInput(userInput, callback) {\n        if (!this.isConfigurated()) {\n            return { success: false, message: \"Missing configuration for connecting to ChatBot provider\" };\n        }\n\n        let generator;\n        try {\n            generator = this.createLlmGenerator();\n        } catch (error) {\n            console.error(\"Error creating the LLM generator:\", error);\n            return { success: false, message: \"Error creating the LLM generator\" };\n        }\n\n        if (!userInput || this.isProcessing) {\n            return { success: false, message: \"Input cannot be processed\" };\n        }\n\n        this.isProcessing = true;\n        let result = {\n            success: false,\n            message: \"\",\n            originalResponse: \"\",\n            yamlData: null,\n            differences: null\n        };\n\n        try {\n            // Aktuelle Daten vorbereiten\n            const currentData = this.dataManager.getData();\n\n            // Nachricht an das LLM senden\n            generator.attachMessageAsUserUsingPrefix({\n                userInput: userInput,\n                currentData: this.getCurrentDataAsPromptBlock(currentData),\n                example: this.getExampleDataAsPromptBlock(),\n            });\n\n            // Stream-Antwort verarbeiten\n            const response = await (0,_completion_js__WEBPACK_IMPORTED_MODULE_0__.handleSse)(\n                generator,\n                (error, token) => {\n                    if (error) {\n                        console.error(\"Stream-Error:\", error);\n                        return;\n                    }\n\n                    // Token an Handler übergeben, falls definiert\n                    if (this.config.onTyping && token) {\n                        this.config.onTyping(token);\n                    }\n                    if (callback && token) {\n                        callback(token);\n                    }\n                }\n            );\n\n            // Vollständige Antwort speichern\n            result.originalResponse = response;\n            generator.attachMessageAsAssistant(response);\n\n            // Antwort parsen und YAML extrahieren\n            const yamlContent = this.extractYamlFromResponse(response);\n\n            if (yamlContent) {\n                try {\n                    // YAML parsen\n                    const parsedData = jsyaml.load(yamlContent);\n\n                    // Daten validieren\n                    if (this.validateSystemData(parsedData)) {\n                        result.yamlData = parsedData;\n\n                        // Unterschiede berechnen\n                        result.differences = this.calculateDifferences(currentData, parsedData);\n                        result.success = true;\n                    } else {\n                        result.message = \"The YAML structure is invalid\";\n                    }\n                } catch (error) {\n                    console.error(\"Error parsing the YAML response:\", error);\n                    result.message = \"The YAML response could not be processed\";\n                }\n            } else {\n                // Normale Konversation ohne YAML-Änderungen\n                result.success = true;\n                result.message = \"No infrastructure changes detected\";\n            }\n\n            // Falls ein Callback für empfangene Nachrichten definiert ist, diesen aufrufen\n            if (this.config.onMessageReceived) {\n                this.config.onMessageReceived(result);\n            }\n\n            return result;\n        } catch (error) {\n            console.error(\"Error during LLM processing:\", error);\n            result.message = \"An error occurred during processing\";\n            return result;\n        } finally {\n            this.isProcessing = false;\n        }\n    }\n\n    /**\n     * Erstellt einen YAML-Markdown-Block für die aktuelle Infrastruktur\n     * @param {Object} currentData - Aktuelle Infrastrukturdaten\n     * @returns {string} - Die formatierte Nachricht mit Kontext\n     */\n    getCurrentDataAsPromptBlock(currentData) {\n        return `\n\\`\\`\\`yaml\nsystems:\n${currentData.systems.map(sys => `  - id: ${sys.id}\n    name: ${sys.name}\n    description: ${sys.description}\n    category: ${sys.category}${this.formatGroups(sys)}\n    status: ${sys.status}\n    knownUsage: ${sys.knownUsage}${sys.tags && sys.tags.length > 0 ? `\\n    tags:\\n${sys.tags.map(tag => `      - ${tag}`).join('\\n')}` : ''}\n`).join('\\n')}\n\ndependencies:\n${currentData.dependencies.map(dep => `  - source: ${dep.source}\n    target: ${dep.target}\n    type: ${dep.type}\n    description: ${dep.description || 'No Description'}\n    protocol: ${dep.protocol || 'API'}\n`).join('\\n')}\n\\`\\`\\`\n`;\n    }\n\n    /**\n     * Erstellt einen YAML-Markdown-Block als Beispiel für den Prompt\n     * @returns {string} - Die formatierte Nachricht mit Kontext\n     */\n    getDataStructureAsPromptBlock() {\n        return `\n\\`\\`\\`yaml\nsystems:\n  - id: systemId\n    name: System Name\n    description: Description for the system\n    category: core/legacy/data/service/external\n    groups:\n      - gruppe1\n      - gruppe2\n    status: active/planned/deprecated/retired\n    knownUsage: true/false\n    delete: true/false\n    tags:\n      - tag1\n      - tag2\n\ndependencies:\n  - source: sourceSystemId\n    target: targetSystemId\n    type: data/integration/authentication/monitoring\n    description: Description for the dependency\n    delete: true/false\n    protocol: Name of Protocol\n\\`\\`\\`\n`;\n    }\n\n    /**\n     * Creates a YAML markdown block as an example for the prompt\n     * @returns {string} - The formatted message with context\n     */\n    getExampleDataAsPromptBlock() {\n        return `\n\\`\\`\\`yaml\nsystems:\n  - id: system1\n    name: System Name\n    description: Some description for the system\n    category: core\n    groups:\n      - group1\n      - group2\n    status: active\n    delete: false\n    knownUsage: true\n\ndependencies:\n  - source: system1\n    target: system2\n    type: data\n    description: Some description for the dependency\n    delete: false\n    protocol: Protocol\n\\`\\`\\`\n`;\n    }\n    /**\n     * Helper function to format the groups information for the YAML representation\n     * @param {Object} system - The system object\n     * @returns {string} - Formatted groups information\n     */\n    formatGroups(system) {\n        let groupsText = '';\n\n        // System has a groups array with entries\n        if (Array.isArray(system.groups) && system.groups.length > 0) {\n            groupsText = '\\n    groups:';\n            system.groups.forEach(group => {\n                groupsText += `\\n      - ${group}`;\n            });\n        }\n\n        return groupsText;\n    }\n\n    /**\n     * Applies data changes to the data model\n     * @param {Object} differences - The changed data\n     * @returns {boolean} - True on success\n     */\n    applyChanges(differences) {\n        try {\n            // Update data in the DataManager\n            this.dataManager.applyBatch(differences);\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(\"Changes have been successfully applied\", \"success\");\n            return true;\n        } catch (error) {\n            console.error(\"Error applying changes:\", error);\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(\"Error applying changes\", \"danger\");\n            return false;\n        }\n    }\n\n    /**\n     * Calculates the differences between two data models\n     * @param {Object} currentData - Current data\n     * @param {Object} newData - New data\n     * @returns {Object} Differences (added, modified, removed)\n     */\n    calculateDifferences(currentData, newData) {\n        const differences = {\n            added: {\n                systems: [],\n                dependencies: []\n            },\n            modified: {\n                systems: [],\n                dependencies: []\n            },\n            removed: {\n                systems: [],\n                dependencies: []\n            }\n        };\n\n        // Compare systems\n        const currentSystemIds = new Set(currentData.systems.map(s => s.id));\n\n        // Added and removed systems\n        newData.systems.forEach(newSystem => {\n            // Removed systems\n            if (newSystem.delete) {\n                differences.removed.systems.push(newSystem);\n                return;\n            }\n            if (!currentSystemIds.has(newSystem.id)) {\n                differences.added.systems.push(newSystem);\n            } else {\n                // Modified systems\n                const currentSystem = currentData.systems.find(s => s.id === newSystem.id);\n                if (!this.areSystemsEqual(currentSystem, newSystem)) {\n                    differences.modified.systems.push(newSystem);\n                }\n            }\n        });\n\n        // Compare dependencies\n        const currentDepKeys = new Set(currentData.dependencies.map(d => `${d.source}-${d.target}`));\n\n        // Added and removed dependencies\n        newData.dependencies.forEach(newDep => {\n            if (newDep.delete) {\n                differences.removed.dependencies.push(newDep);\n                return;\n            }\n            const key = `${newDep.source}-${newDep.target}`;\n            if (!currentDepKeys.has(key)) {\n                differences.added.dependencies.push(newDep);\n            } else {\n                // Modified dependencies\n                const currentDep = currentData.dependencies.find(d =>\n                    d.source === newDep.source && d.target === newDep.target);\n                if (!this.areDependenciesEqual(currentDep, newDep)) {\n                    differences.modified.dependencies.push(newDep);\n                }\n            }\n        });\n\n        return differences;\n    }\n\n    /**\n     * Compares two systems for equality, adapted for multi-group support\n     * @param {Object} system1 - First system\n     * @param {Object} system2 - Second system\n     * @returns {boolean} True if the systems are equal\n     */\n    areSystemsEqual(system1, system2) {\n        if (!system1 || !system2) return false;\n\n        // Compare main properties\n        if (system1.name !== system2.name ||\n            system1.description !== system2.description ||\n            system1.category !== system2.category ||\n            system1.status !== system2.status ||\n            system1.knownUsage !== system2.knownUsage) {\n            return false;\n        }\n\n        // Compare groups\n        const groups1 = this.getSystemGroups(system1);\n        const groups2 = this.getSystemGroups(system2);\n\n        if (groups1.length !== groups2.length) {\n            return false;\n        }\n\n        // Check if all groups match (order does not matter)\n        for (const group of groups1) {\n            if (!groups2.includes(group)) {\n                return false;\n            }\n        }\n\n        // Compare tags (if present)\n        if (Array.isArray(system1.tags) && Array.isArray(system2.tags)) {\n            if (system1.tags.length !== system2.tags.length) {\n                return false;\n            }\n\n            for (let i = 0; i < system1.tags.length; i++) {\n                if (!system2.tags.includes(system1.tags[i])) {\n                    return false;\n                }\n            }\n        } else if ((system1.tags && !system2.tags) || (!system1.tags && system2.tags)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Helper function to extract all groups of a system\n     * @param {Object} system - The system object\n     * @returns {Array} Array with all group names\n     */\n    getSystemGroups(system) {\n        let groups = [];\n\n        if (Array.isArray(system.groups) && system.groups.length > 0) {\n            groups = [...system.groups];\n        } else if (system.group && typeof system.group === 'string') {\n            groups = [system.group];\n        }\n\n        return groups;\n    }\n\n    /**\n     * Compares two dependencies for equality\n     * @param {Object} dep1 - First dependency\n     * @param {Object} dep2 - Second dependency\n     * @returns {boolean} True if the dependencies are equal\n     */\n    areDependenciesEqual(dep1, dep2) {\n        if (!dep1 || !dep2) return false;\n\n        return dep1.type === dep2.type &&\n            dep1.description === dep2.description &&\n            dep1.protocol === dep2.protocol;\n    }\n\n    /**\n     * Validates the data structure\n     * @param {Object} data - The data structure to validate\n     * @returns {boolean} True if the data is valid\n     */\n    validateSystemData(data) {\n        // Check if the basic structure exists\n        if (!data || (!Array.isArray(data.systems) && !Array.isArray(data.dependencies))) {\n            return false;\n        }\n\n        data.systems = data.systems || [];\n        data.dependencies = data.dependencies || [];\n\n        // Check if all systems have an ID\n        const allSystemsHaveId = data.systems.every(system => !!system.id);\n        if (!allSystemsHaveId) {\n            return false;\n        }\n\n        // Check if all dependencies have valid source and target\n        const currentData = this.dataManager.getData();\n        const allDependenciesValid = data.dependencies.every(dep =>\n            !!dep.source && !!dep.target &&\n            (data.systems.some(sys => sys.id === dep.source) || currentData.systems.some(sys => sys.id === dep.source)) &&\n            (data.systems.some(sys => sys.id === dep.target) || currentData.systems.some(sys => sys.id === dep.target))\n        );\n\n        return allDependenciesValid;\n    }\n\n    /**\n     * Extracts YAML content from an LLM response\n     * @param {string} response - The LLM response\n     * @returns {string|null} The extracted YAML content or null\n     */\n    extractYamlFromResponse(response) {\n        // Search for YAML blocks in the response (with Markdown code block)\n        const yamlRegex = /```(?:yaml)?\\s*([\\s\\S]*?)\\s*```/i;\n        const match = response.match(yamlRegex);\n\n        if (match && match[1]) {\n            return match[1].trim();\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the default system prompt\n     * @returns {string} The default system prompt\n     */\n    getDefaultSystemPrompt() {\n        const isGerman = typeof navigator !== \"undefined\" && navigator.language && navigator.language.startsWith(\"de\");\n        if (isGerman) {\n            return `Du bist ein Infrastruktur-Assistent, der dabei hilft, IT-Systeme und deren Abhängigkeiten zu verwalten. IT-Systeme bestehen aus id, name, description, category, status, knownUsage, groups (array, optional) und tags (array, optional). Abhängigkeiten zwischen Systemen haben die Attribute source, target, type, description und protocol. Du analysierst Benutzeranfragen und wandelst sie in strukturierte YAML-Definitionen um.\n\nAkzeptable Kategorien (category) für Systeme sind:\n- core: Zentrale Systeme\n- legacy: Veraltete Systeme\n- data: Datenspeicher und -verarbeitung\n- service: Dienste und Anwendungen\n- external: Externe Systeme\n\nVerbindungstypen (type) zwischen Systemen können sein:\n- data: Datenaustausch\n- integration: Systemintegration\n- authentication: Authentifizierung\n- monitoring: Überwachung\n\nStatus-Werte (status) für Systeme:\n- active: Aktiv im Einsatz\n- planned: Geplant\n- deprecated: Veraltet\n- retired: Außer Betrieb\n\nWenn der Benutzer dich bittet, die Infrastruktur zu ändern (z.B. Systeme hinzuzufügen, zu bearbeiten oder zu löschen), \nantworte mit den neuen, geänderten und gelöschten Elementen in der YAML-Struktur. Gelöschte Elemente werden mit dem Attribut \\`delete: true\\` markiert. \nFüge keine Erklärungen innerhalb des YAML-Blocks hinzu.\n\nHalte dich an dieses Format:\n\n{{dataStructure}}\n\nWenn du nach allgemeinen Informationen über die Infrastrukturvisualisierung gefragt wirst, \nantworte mit hilfreichen Erklärungen, ohne YAML zurückzugeben.`;\n        } else {\n            return `You are an infrastructure assistant that helps manage IT systems and their dependencies. IT systems consist of id, name, description, category, status, knownUsage, groups (array, optional), and tags (array, optional). Dependencies between systems have the attributes source, target, type, description, and protocol. You analyze user requests and convert them into structured YAML definitions.\n\nAcceptable categories (category) for systems are:\n- core: Core systems\n- legacy: Legacy systems\n- data: Data storage and processing\n- service: Services and applications\n- external: External systems\n\nConnection types (type) between systems can be:\n- data: Data exchange\n- integration: System integration\n- authentication: Authentication\n- monitoring: Monitoring\n\nStatus values (status) for systems:\n- active: Active in use\n- planned: Planned\n- deprecated: Deprecated\n- retired: Retired\n\nIf the user asks you to change the infrastructure (e.g., add, edit, or delete systems), \nrespond with the new, changed, and deleted elements in the YAML structure. Deleted elements are marked with the attribute \\`delete: true\\`. \nDo not include explanations inside the YAML block.\n\nStick to this format:\n\n{{dataStructure}}\n\nIf you are asked general questions about infrastructure visualization, \nrespond with helpful explanations without returning YAML.`;\n        }\n    }\n\n    /**\n     * Creates the default prompt header, use {{currentData}}, {{userInput}} and {{example}} as placeholders\n     * \n     * @returns {string} - The formatted message with context\n     */\n    getDefaultPromptPrefix() {\n        const isGerman = typeof navigator !== \"undefined\" && navigator.language && navigator.language.startsWith(\"de\");\n        if (isGerman) {\n            return `\nHier ist die aktuelle YAML-Darstellung der Infrastruktur:\n\n{{currentData}}\n\nBenutzeranfrage:\n\n{{userInput}}\n\nWenn du Änderungen an der Infrastruktur vornehmen sollst, gib die neuen, aktualisierten oder zu löschenden Elemente in YAML im folgenden Format zurück:\n\n{{example}}\n\nWenn keine Änderungen erforderlich sind, antworte mit normaler Konversation. Gib YAML nur zurück, wenn Infrastrukturänderungen angefordert wurden.\n`;\n        } else {\n            return `\nHere is the current YAML representation of the infrastructure:\n\n{{currentData}}\n\nUser request:\n\n{{userInput}}\n\nIf you are asked to make changes to the infrastructure, return the new, updated, or deleted elements in YAML using the following format:\n\n{{example}}\n\nIf no changes are required, respond with a normal conversation. Only return YAML if infrastructure changes are requested.\n`;\n        }\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/llm-integration-manager.js?");

/***/ }),

/***/ "./src/node-cache.js":
/*!***************************!*\
  !*** ./src/node-cache.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NodeCache: () => (/* binding */ NodeCache)\n/* harmony export */ });\n/**\n * NodeCache - Manages the persistence of node positions in the diagram\n * Continuously stores positions and can load them from various sources\n */\nclass NodeCache {\n    constructor(options = {}) {\n        this.positions = new Map();\n        this.options = {\n            useLocalStorage: options.useLocalStorage || false,\n            localStorageKey: options.localStorageKey || 'system_visualizer_node_positions',\n            debounceTime: options.debounceTime || 500, // ms between local saves\n            persistGroups: options.persistGroups || true\n        };\n\n        // Debounce timer for LocalStorage updates\n        this.saveTimer = null;\n\n        // Load from LocalStorage on initialization\n        if (this.options.useLocalStorage) {\n            this.loadFromLocalStorage();\n        }\n    }\n\n    /**\n     * Stores the position of a node\n     * @param {string} id - The ID of the node\n     * @param {Object} position - The position {x, y, vx, vy} and optionally other properties\n     */\n    set(id, position) {\n        if (!id) return;\n\n        // Set current position\n        this.positions.set(id, {\n            x: position.x,\n            y: position.y,\n            vx: position.vx || 0,\n            vy: position.vy || 0,\n            // Optionally more metadata\n            lastUpdated: Date.now(),\n            isFixed: position.isFixed || false,\n        });\n\n        this.saveToLocalStorage();\n    }\n\n    /**\n     * Updates multiple nodes at once\n     * @param {Array} nodes - Array of nodes with id and position data\n     */\n    updateBatch(nodes) {\n        if (!Array.isArray(nodes)) return;\n\n        let updated = false;\n        nodes.forEach(node => {\n            if (node.id && (node.x !== undefined && node.y !== undefined)) {\n                this.positions.set(node.id, {\n                    x: node.x,\n                    y: node.y,\n                    vx: node.vx || 0,\n                    vy: node.vy || 0,\n                    lastUpdated: Date.now(),\n                    isFixed: node.isFixed || false,\n                });\n                updated = true;\n            }\n        });\n\n        if (updated) {\n            this.saveToLocalStorage();\n        }\n    }\n\n    /**\n     * Retrieves the stored position of a node\n     * @param {string} id - The ID of the node\n     * @returns {Object|null} The stored position or null\n     */\n    get(id) {\n        return this.positions.get(id) || null;\n    }\n\n    /**\n     * Checks if a position exists for a node\n     * @param {string} id - The ID of the node\n     * @returns {boolean} True if position exists\n     */\n    has(id) {\n        return this.positions.has(id);\n    }\n\n    /**\n     * Removes an entry from the cache\n     * @param {string} id - The ID of the node\n     */\n    remove(id) {\n        this.positions.delete(id);\n        this.saveToLocalStorage();\n    }\n\n    saveToLocalStorage() {\n        if (this.options.useLocalStorage) {\n            clearTimeout(this.saveTimer);\n            this.saveTimer = setTimeout(() => {\n                this.doSaveToLocalStorage();\n            }, this.options.debounceTime);\n        }\n    }\n\n    /**\n     * Save to LocalStorage\n     */\n    doSaveToLocalStorage() {\n        if (!this.options.useLocalStorage) return;\n\n        try {\n            // Convert the Map to an array of [id, data] pairs\n            const positionsArray = Array.from(this.positions);\n            localStorage.setItem(\n                this.options.localStorageKey,\n                JSON.stringify(positionsArray)\n            );\n        } catch (error) {\n            console.warn('Error saving positions:', error);\n        }\n    }\n\n    /**\n     * Load from LocalStorage\n     */\n    loadFromLocalStorage() {\n        if (!this.options.useLocalStorage) return;\n\n        try {\n            const stored = localStorage.getItem(this.options.localStorageKey);\n            if (stored) {\n                // Convert array of [id, data] pairs back to Map\n                const positionsArray = JSON.parse(stored);\n                this.positions = new Map(positionsArray);\n            }\n        } catch (error) {\n            console.warn('Error loading positions:', error);\n        }\n    }\n\n    /**\n     * Clear cache\n     * @param {boolean} alsoLocalStorage - If true, also clear LocalStorage\n     */\n    clear(alsoLocalStorage = false) {\n        this.positions.clear();\n\n        if (alsoLocalStorage && this.options.useLocalStorage) {\n            localStorage.removeItem(this.options.localStorageKey);\n        }\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/node-cache.js?");

/***/ }),

/***/ "./src/simulation.js":
/*!***************************!*\
  !*** ./src/simulation.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SimulationManager: () => (/* binding */ SimulationManager)\n/* harmony export */ });\n/* harmony import */ var _event_emitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-emitter.js */ \"./src/event-emitter.js\");\n\n\n/**\n * SimulationManager - Handles d3 force simulation logic separate from visualization\n */\nclass SimulationManager extends _event_emitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor(options = {}) {\n        super();\n        this.options = {\n            linkDistance: options.linkDistance || 150,\n            chargeStrength: options.chargeStrength || -300,\n            collisionRadius: options.collisionRadius || 60,\n            groupForceStrength: options.groupForceStrength || 0.5,\n            ...options\n        };\n\n        this.simulation = null;\n        this.nodeCache = options.nodeCache || null;\n        this.width = options.width || 800;\n        this.height = options.height || 600;\n\n        // For throttling cache updates\n        this.lastCacheUpdate = 0;\n        this.cacheUpdateInterval = options.cacheUpdateInterval || 300;\n\n        // Callbacks\n        this.onTick = options.onTick || (() => { });\n        this.onEnd = options.onEnd || (() => { });\n        this.onToggleFixed = options.onToggleFixed || (() => { });\n    }\n\n    /**\n     * Returns the node with the given ID from the current simulation\n     * @param {string} systemId - The ID of the system to find\n     * @returns {Object|null} The node object or null if not found\n     */\n    getNodeById(systemId) {\n        return this.simulation.nodes().find(node => node.id === systemId);\n    }\n\n    /**\n     * Checks if a node is fixed\n     * @param {string} systemId - The ID of the system to check\n     * @returns {boolean} True if the node is fixed, false otherwise or if not found\n     */\n    isNodeFixed(systemId, curNode = undefined) {\n        const node = curNode || this.getNodeById(systemId);\n        return node ? !!node.isFixed : false;\n    }\n\n    /**\n     * Toggles the fixed state of a node identified by systemId.\n     *\n     * @param {string|number} systemId - The unique identifier of the node to toggle.\n     * @param {Object} [curNode=undefined] - The current node object (optional). If not provided, the node will be retrieved by systemId.\n     * @returns {null|undefined} Returns null if the node is not found; otherwise, returns undefined.\n     */\n    toggleNodeFixed(systemId, curNode = undefined) {\n        const node = curNode || this.getNodeById(systemId);\n        if (!node) return null;\n        const isFixed = this.isNodeFixed(systemId, node);\n        const newState = !isFixed;\n        this.setNodeFixed(systemId, newState, node);\n    }\n\n    /**\n     * Sets or removes the fixed position of a node in the simulation.\n     *\n     * @param {string|number} systemId - The unique identifier of the node to fix or unfix.\n     * @param {boolean} state - If true, fixes the node at its current position; if false, releases the node.\n     * @param {Object} [curNode=undefined] - (Optional) The node object to operate on. If not provided, the node is retrieved by systemId.\n     * @returns {boolean|null} Returns the node's fixed state after the operation, or null if the node was not found.\n     */\n    setNodeFixed(systemId, state, curNode = undefined) {\n        const node = curNode || this.getNodeById(systemId);\n        if (!node) return null;\n\n        const stateBefore = node.isFixed;\n        if (!state) {\n            // Remove fixation\n            node.isFixed = false;\n            node.fx = null;\n            node.fy = null;\n        } else {\n            // Fix node at current position\n            node.isFixed = true;\n            node.fx = node.x;\n            node.fy = node.y;\n        }\n\n        // Update cache\n        if (this.nodeCache && node.id) {\n            this.nodeCache.set(node.id, {\n                x: node.x,\n                y: node.y,\n                vx: node.vx || 0,\n                vy: node.vy || 0,\n                isFixed: node.isFixed\n            });\n        }\n\n        // Slightly restart simulation\n        this.restart(0.1);\n\n        this.onToggleFixed && state != stateBefore && this.onToggleFixed(systemId, state);\n\n        return node.isFixed;\n    }\n\n    /**\n     * Initialize simulation with nodes and links\n     */\n    initialize(nodes, links, groups) {\n        // Apply cached positions before simulation starts\n        if (this.nodeCache) {\n            this.applyNodePositionsFromCache(nodes);\n        }\n\n        // Calculate initial positions for nodes without cache positions\n        this.applyInitialPositions(nodes);\n\n        // Create simulation\n        this.simulation = d3.forceSimulation(nodes)\n            .force(\"link\", d3.forceLink(links)\n                .id(d => d.id)\n                .distance(this.options.linkDistance))\n            .force(\"charge\", d3.forceManyBody()\n                .strength(this.options.chargeStrength))\n            .force(\"center\", d3.forceCenter(this.width / 2, this.height / 2))\n            .force(\"collision\", d3.forceCollide()\n                .radius(this.options.collisionRadius));\n\n        // Add group force if groups are provided\n        if (groups && Object.keys(groups).length > 0) {\n            this.simulation.force(\"group\", d3.forceClusterMultiGroup()\n                .centers(groups)\n                .strength(this.options.groupForceStrength));\n        }\n\n        // Add containment force to keep nodes within bounds\n        this.simulation.force(\"containment\", this.createContainmentForce());\n\n        // Register tick handler\n        this.simulation.on(\"tick\", () => {\n            // Update node cache periodically during simulation\n            this.throttledUpdateNodeCache();\n\n            // Call external tick handler\n            this.onTick();\n        });\n\n        // Register end handler\n        this.simulation.on(\"end\", () => {\n            // Save final positions to cache\n            if (this.nodeCache) {\n                this.nodeCache.updateBatch(this.simulation.nodes());\n            }\n\n            // Call external end handler\n            this.onEnd();\n        });\n\n        return this.simulation;\n    }\n\n    /**\n     * Retrieves the groups associated with a node.\n     *\n     * If the node has a non-empty `groups` array, it returns that array.\n     * If the node has a `group` property as a string, it returns an array containing that string.\n     * Otherwise, it returns an empty array.\n     *\n     * @param {Object} node - The node object to extract groups from.\n     * @param {Array<string>} [node.groups] - An optional array of group names.\n     * @param {string} [node.group] - An optional single group name.\n     * @returns {Array<string>} An array of group names associated with the node.\n     */\n    getNodeGroups(node) {\n        if (Array.isArray(node.groups) && node.groups.length > 0) {\n            return node.groups;\n        } else if (node.group && typeof node.group === 'string') {\n            return [node.group];\n        }\n        return [];\n    }\n\n    /**\n     * Create a force that keeps nodes within the container bounds\n     */\n    createContainmentForce() {\n        // Add padding to prevent nodes from touching the edge\n        const padding = 50;\n\n        return () => {\n            for (let node of this.simulation.nodes()) {\n                // Gradually increase force as node approaches boundaries\n                if (node.x < padding) {\n                    node.vx += (padding - node.x) * 0.1;\n                } else if (node.x > this.width - padding) {\n                    node.vx -= (node.x - (this.width - padding)) * 0.1;\n                }\n\n                if (node.y < padding) {\n                    node.vy += (padding - node.y) * 0.1;\n                } else if (node.y > this.height - padding) {\n                    node.vy -= (node.y - (this.height - padding)) * 0.1;\n                }\n\n                // Dampen velocity for stable movement\n                node.vx *= 0.9;\n                node.vy *= 0.9;\n            }\n        };\n    }\n\n    /**\n     * Applies cached positions and velocities to a list of nodes.\n     * \n     * For each node with a matching entry in the node cache, updates its position (`x`, `y`),\n     * velocity (`vx`, `vy`), and temporarily fixes its position (`fx`, `fy`) for visual stability.\n     * If the node is not marked as fixed, releases the fixed position after a short delay.\n     * \n     * @param {Array<Object>} nodes - Array of node objects to update. Each node should have an `id` property.\n     * @returns {number} The number of nodes that had their positions updated from the cache.\n     */\n    applyNodePositionsFromCache(nodes) {\n        if (!nodes || !this.nodeCache) return 0;\n\n        let cacheHits = 0;\n        nodes.forEach(node => {\n            if (node.id) {\n                const cachedPosition = this.nodeCache.get(node.id);\n                if (cachedPosition) {\n                    // Position from cache\n                    node.x = cachedPosition.x;\n                    node.y = cachedPosition.y;\n\n                    // Reduced velocity for smoother transitions\n                    node.vx = (cachedPosition.vx || 0) * 0.3;\n                    node.vy = (cachedPosition.vy || 0) * 0.3;\n\n                    // Briefly fix position for visual stability\n                    node.fx = cachedPosition.x;\n                    node.fy = cachedPosition.y;\n\n                    // Schedule release of fixed position\n                    node.isFixed = !!cachedPosition.isFixed;\n                    if(!node.isFixed) {\n                        setTimeout(() => {\n                            node.fx = null;\n                            node.fy = null;\n                        }, 500);\n                    }\n\n                    cacheHits++;\n                }\n            }\n        });\n\n        return cacheHits;\n    }\n\n    /**\n     * Assigns initial positions and velocities to nodes that lack position data.\n     * \n     * For each node without a position, this method:\n     * - Attempts to find reference nodes in the same group(s) (if any), or falls back to all positioned nodes.\n     * - Calculates a target position near the center of the reference nodes, with a random offset.\n     * - Places the node at a random angle and distance from the target position.\n     * - Sets an initial velocity pointing gently toward the target position.\n     * \n     * @param {Array<Object>} nodes - Array of node objects. Each node may have `x`, `y`, `vx`, `vy` properties and group information.\n     */\n    applyInitialPositions(nodes) {\n        // Find nodes without position\n        const nodesWithoutPosition = nodes.filter(node =>\n            node.x === undefined || node.y === undefined);\n\n        if (nodesWithoutPosition.length === 0) return;\n\n        // Get positioned nodes\n        const positionedNodes = nodes.filter(node =>\n            node.x !== undefined && node.y !== undefined);\n\n        // For each new node\n        nodesWithoutPosition.forEach(node => {\n            let referenceNodes = [];\n            let targetPosition;\n\n            // Reference nodes based on groups or all nodes\n            const nodeGroups = this.getNodeGroups(node);\n\n            if (nodeGroups.length > 0) {\n                // Collect all reference nodes for all groups of the node\n                nodeGroups.forEach(group => {\n                    const groupNodes = positionedNodes.filter(n => {\n                        const nGroups = this.getNodeGroups(n);\n                        return nGroups.includes(group);\n                    });\n\n                    referenceNodes = [...referenceNodes, ...groupNodes];\n                });\n\n                // Remove duplicates\n                referenceNodes = Array.from(new Set(referenceNodes));\n            }\n\n            if (referenceNodes.length === 0) {\n                referenceNodes = positionedNodes;\n            }\n\n            // Calculate target position (between all group centers)\n            if (referenceNodes.length > 0) {\n                let sumX = 0, sumY = 0;\n                referenceNodes.forEach(refNode => {\n                    sumX += refNode.x;\n                    sumY += refNode.y;\n                });\n\n                // Group center with offset\n                const isGroupCentered = referenceNodes !== positionedNodes;\n                const offset = isGroupCentered ? 50 : 150;\n\n                targetPosition = {\n                    x: (sumX / referenceNodes.length) + (Math.random() - 0.5) * offset,\n                    y: (sumY / referenceNodes.length) + (Math.random() - 0.5) * offset\n                };\n            } else {\n                // If no references, use screen center\n                targetPosition = {\n                    x: this.width / 2 + (Math.random() - 0.5) * 200,\n                    y: this.height / 2 + (Math.random() - 0.5) * 200\n                };\n            }\n\n            // Starting position at group center edge\n            const distanceFromCenter = referenceNodes.length > 0 ? 100 : 200;\n            const angle = Math.random() * Math.PI * 2;  // Random angle\n\n            node.x = targetPosition.x + Math.cos(angle) * distanceFromCenter;\n            node.y = targetPosition.y + Math.sin(angle) * distanceFromCenter;\n\n            // Initial velocity toward target position\n            const dx = targetPosition.x - node.x;\n            const dy = targetPosition.y - node.y;\n\n            // Gentle movement toward center\n            const speedFactor = 0.01;  // Very low for gentle movement\n            node.vx = dx * speedFactor;\n            node.vy = dy * speedFactor;\n        });\n    }\n\n    /**\n     * Update node cache throttled\n     */\n    throttledUpdateNodeCache() {\n        const now = Date.now();\n        if (this.nodeCache && now - this.lastCacheUpdate > this.cacheUpdateInterval) {\n            this.lastCacheUpdate = now;\n            this.nodeCache.updateBatch(this.simulation.nodes());\n        }\n    }\n\n    /**\n     * Restart simulation with alpha\n     */\n    restart(alpha = 0.3) {\n        if (this.simulation) {\n            this.simulation.alpha(alpha).restart();\n        }\n    }\n\n    /**\n     * Stop simulation\n     */\n    stop() {\n        if (this.simulation) {\n            this.simulation.stop();\n        }\n    }\n\n    /**\n     * Update simulation size\n     */\n    updateSize(width, height) {\n        this.width = width;\n        this.height = height;\n\n        if (this.simulation) {\n            this.simulation.force(\"center\", d3.forceCenter(width / 2, height / 2));\n            // Restart with low alpha to adjust positions\n            this.restart(0.1);\n        }\n    }\n\n    /**\n     * Create drag behavior\n     */\n    createDragBehavior() {\n        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n        return d3.drag()\n            .on(\"start\", (event, d) => {\n                if (isTouchDevice && event.sourceEvent) {\n                    event.sourceEvent.preventDefault();\n                }\n                this.dragstarted(event, d);\n            })\n            .on(\"start\", (event, d) => this.dragstarted(event, d))\n            .on(\"drag\", (event, d) => this.dragged(event, d))\n            .on(\"end\", (event, d) => this.dragended(event, d))\n            .touchable(true)\n            .filter(function(event) {\n                if (isTouchDevice) return true;\n                return !event.ctrlKey && !event.button;\n            });\n    }\n\n    /**\n     * Handle drag start\n     */\n    dragstarted(event, d) {\n        if (!event.active) this.simulation.alphaTarget(0.3).restart();\n        d.fx = d.x;\n        d.fy = d.y;\n        this.setNodeFixed(d.id, true, d);\n    }\n\n    /**\n     * Handle dragging\n     */\n    dragged(event, d) {\n        d.fx = event.x;\n        d.fy = event.y;\n    }\n\n    /**\n     * Handle drag end\n     */\n    dragended(event, d) {\n        if (!event.active) this.simulation.alphaTarget(0);\n\n        // Only persist position in cache if dragged\n        if (this.nodeCache && d.id) {\n            this.nodeCache.set(d.id, {\n                x: d.x,\n                y: d.y,\n                vx: 0,\n                vy: 0,\n                isFixed: d.isFixed || false\n            });\n        }\n    }\n}\n\nd3.forceClusterMultiGroup = function () {\n    let strength = 0.1;\n    let centers = {};\n    let nodes = [];\n\n    // Weight for each group (1/number of groups of a node)\n    // So that nodes with fewer groups are more strongly attracted to their groups\n    function getGroupWeight(node) {\n        const nodeGroups = getNodeGroups(node);\n        return nodeGroups.length > 0 ? 1 / nodeGroups.length : 0;\n    }\n\n    // Helper function to extract all groups of a node\n    function getNodeGroups(node) {\n        if (Array.isArray(node.groups) && node.groups.length > 0) {\n            return node.groups;\n        } else if (node.group && typeof node.group === 'string') {\n            return [node.group];\n        }\n        return [];\n    }\n\n    function force(alpha) {\n        // For each node\n        nodes.forEach(d => {\n            const nodeGroups = getNodeGroups(d);\n            if (nodeGroups.length === 0) return; // Skip if no group\n\n            // Vector for the total force on the node\n            let totalForceX = 0;\n            let totalForceY = 0;\n            let totalWeight = 0;\n\n            // Calculate force from each group\n            nodeGroups.forEach(groupName => {\n                const groupCenter = centers[groupName];\n                if (!groupCenter) return;\n\n                // Weight for this group\n                const weight = getGroupWeight(d);\n                totalWeight += weight;\n\n                // Adjust force depending on the number of groups the node is in\n                const k = strength * alpha * weight;\n\n                // Force towards the group center\n                totalForceX += (groupCenter.x - d.x) * k;\n                totalForceY += (groupCenter.y - d.y) * k;\n            });\n\n            // Apply total force to the node\n            if (totalWeight > 0) {\n                d.vx += totalForceX;\n                d.vy += totalForceY;\n            }\n        });\n    }\n\n    force.initialize = function (_) {\n        nodes = _;\n    };\n\n    force.centers = function (_) {\n        return arguments.length ? (centers = _, force) : centers;\n    };\n\n    force.strength = function (_) {\n        return arguments.length ? (strength = _, force) : strength;\n    };\n\n    return force;\n};\n\n//# sourceURL=webpack://infravis/./src/simulation.js?");

/***/ }),

/***/ "./src/system-manager.js":
/*!*******************************!*\
  !*** ./src/system-manager.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemManager: () => (/* binding */ SystemManager)\n/* harmony export */ });\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities.js */ \"./src/utilities.js\");\n\n\n/**\n * System Manager - Manages adding, editing, and deleting systems\n */\nclass SystemManager {\n    constructor() {\n        this.initialized = false;\n        this.currentEditingSystem = null;\n    }\n\n    /**\n     * Initializes the SystemManager\n     */\n    initialize(dataManager) {\n        this.dataManager = dataManager;\n\n        if (this.initialized) return;\n\n        // React to data changes\n        this.dataManager.on('dataChanged', () => {\n            // Optional: Update the UI on data changes\n        });\n\n        this.initialized = true;\n        console.log('SystemManager has been initialized');\n    }\n\n    /**\n     * Shows the system modal for adding or editing\n     * @param {string} systemId - The ID of the system to edit (null for adding)\n     */\n    showSystemModal(systemId = null) {\n        // Set modal title depending on action (add or edit)\n        document.getElementById('system-modal-label').textContent =\n            systemId ? 'Edit System' : 'Add System';\n\n        const form = document.getElementById('system-form');\n\n        // Reset form\n        form.reset();\n\n        // Clear groups container\n        const groupsContainer = document.getElementById('system-groups-container');\n        if (groupsContainer) {\n            groupsContainer.innerHTML = '';\n        }\n\n        const groupsValueField = document.getElementById('system-groups-value');\n        if (groupsValueField) {\n            groupsValueField.value = '';\n        }\n\n        // If systemId exists, fill form data with system data\n        if (systemId) {\n            const system = this.dataManager.getData().systems.find(sys => sys.id === systemId);\n            if (system) {\n                this.currentEditingSystem = system;\n\n                // Fill form with system data\n                document.getElementById('system-id').value = system.id;\n                document.getElementById('system-name').value = system.name;\n                document.getElementById('system-description').value = system.description;\n                document.getElementById('system-category').value = system.category;\n                document.getElementById('system-status').value = system.status;\n                document.getElementById('system-known-usage').checked = system.knownUsage;\n\n                // Add groups as badges\n                const groups = [];\n                if (Array.isArray(system.groups)) {\n                    system.groups.forEach(group => this.addGroupBadge(group));\n                    groups.push(...system.groups);\n                } else if (system.group && typeof system.group === 'string') {\n                    this.addGroupBadge(system.group);\n                    groups.push(system.group);\n                }\n\n                // Store groups in hidden field\n                if (groupsValueField) {\n                    groupsValueField.value = groups.join(',');\n                }\n\n                // Display tags as comma-separated list\n                if (system.tags && Array.isArray(system.tags)) {\n                    document.getElementById('system-tags').value = system.tags.join(', ');\n                } else {\n                    document.getElementById('system-tags').value = '';\n                }\n            }\n        } else {\n            // New system, clear ID field\n            document.getElementById('system-id').value = '';\n            this.currentEditingSystem = null;\n        }\n\n        // Fill group list (for datalist)\n        const groupList = document.getElementById('group-list');\n        if (groupList) {\n            groupList.innerHTML = '';\n\n            // Collect existing groups\n            const groups = this.dataManager.getAllGroups ?\n                this.dataManager.getAllGroups() : this.getExistingGroups();\n\n            // Fill group list\n            groups.forEach(group => {\n                const option = document.createElement('option');\n                option.value = group;\n                groupList.appendChild(option);\n            });\n        }\n\n        // Show modal\n        const modal = new bootstrap.Modal(document.getElementById('system-modal'));\n        modal.show();\n    }\n\n    /**\n     * Saves a new or edited system\n     */\n    saveSystem() {\n        // Collect form data\n        const systemId = document.getElementById('system-id').value;\n        const name = document.getElementById('system-name').value;\n        const description = document.getElementById('system-description').value;\n        const category = document.getElementById('system-category').value;\n        const status = document.getElementById('system-status').value;\n        const knownUsage = document.getElementById('system-known-usage').checked;\n\n        // Create groups array - support for old and new UI format\n        let groups = [];\n\n        // New UI (with system-groups-value as hidden field)\n        const groupsValueField = document.getElementById('system-groups-value');\n        if (groupsValueField) {\n            groups = groupsValueField.value\n                ? groupsValueField.value.split(',').map(g => g.trim()).filter(g => g !== '')\n                : [];\n        }\n        // Old UI (with system-group as direct input)\n        else {\n            const groupField = document.getElementById('system-group');\n            if (groupField && groupField.value.trim() !== '') {\n                // Check for commas (for manual multi-group input)\n                if (groupField.value.includes(',')) {\n                    groups = groupField.value.split(',').map(g => g.trim()).filter(g => g !== '');\n                } else {\n                    groups = [groupField.value.trim()];\n                }\n            }\n        }\n\n        // Convert tags from comma-separated list to array\n        const tagsString = document.getElementById('system-tags').value;\n        const tags = tagsString\n            ? tagsString.split(',').map(tag => tag.trim()).filter(tag => tag)\n            : [];\n\n        // Form validation\n        if (!name || !description || !category || !status) {\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Please fill in all required fields', 'warning');\n            return;\n        }\n\n        // Create new system object\n        const updatedSystem = {\n            id: systemId || this.dataManager.generateUniqueId(),\n            name,\n            description,\n            category,\n            status,\n            knownUsage,\n            tags,\n            groups // New multi-group array\n        };\n\n        // For backward compatibility also set the single group field\n        if (groups.length > 0) {\n            updatedSystem.group = groups[0];\n        }\n\n        // Add or update the system\n        if (!systemId) {\n            // Add new system\n            this.dataManager.addSystem(updatedSystem);\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)(`System \"${name}\" has been added`, 'success');\n        } else {\n            // Update existing system\n            this.dataManager.updateSystem(updatedSystem);\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)(`System \"${name}\" has been updated`, 'success');\n        }\n\n        // Close modal\n        bootstrap.Modal.getInstance(document.getElementById('system-modal')).hide();\n    }\n\n    /**\n     * Adds a group as a badge to the container\n     * @param {string} groupName - Name of the group\n     */\n    addGroupBadge(groupName) {\n        if (!groupName || groupName.trim() === '') return;\n\n        const container = document.getElementById('system-groups-container');\n        const hiddenField = document.getElementById('system-groups-value');\n\n        if (!container || !hiddenField) {\n            console.warn('Group UI elements not found. Multi-group UI may not be initialized.');\n            return;\n        }\n\n        // Check if the group has already been added\n        const currentGroups = hiddenField.value ? hiddenField.value.split(',') : [];\n        if (currentGroups.includes(groupName)) return;\n\n        // Create badge\n        const badge = document.createElement('span');\n        badge.className = 'badge bg-primary d-flex align-items-center';\n        badge.innerHTML = `\n        ${groupName}\n        <button type=\"button\" class=\"btn-close btn-close-white ms-2\" \n                aria-label=\"Remove\" style=\"font-size: 0.5rem;\"></button>\n    `;\n\n        // Delete button\n        badge.querySelector('.btn-close').addEventListener('click', () => {\n            container.removeChild(badge);\n\n            // Remove value from hidden field\n            const groups = hiddenField.value.split(',');\n            const index = groups.indexOf(groupName);\n            if (index !== -1) {\n                groups.splice(index, 1);\n                hiddenField.value = groups.join(',');\n            }\n        });\n\n        // Add to container\n        container.appendChild(badge);\n\n        // Add to hidden field\n        const newGroups = [...currentGroups, groupName];\n        hiddenField.value = newGroups.join(',');\n    }\n\n    /**\n     * Helper function to collect all existing groups\n     * (Only needed if getAllGroups is not implemented in DataManager)\n     * @returns {Array} Array of unique group names\n     */\n    getExistingGroups() {\n        const groups = new Set();\n\n        this.dataManager.getData().systems.forEach(system => {\n            if (Array.isArray(system.groups)) {\n                system.groups.forEach(group => {\n                    if (group && group.trim() !== '') {\n                        groups.add(group);\n                    }\n                });\n            } else if (system.group && typeof system.group === 'string') {\n                groups.add(system.group);\n            }\n        });\n\n        return Array.from(groups).sort();\n    }\n\n    /**\n     * Shows the delete confirmation for a system\n     * @param {string} systemId - The ID of the system to delete\n     */\n    showDeleteConfirmation(systemId) {\n        const system = this.dataManager.getData().systems.find(sys => sys.id === systemId);\n        if (!system) return;\n\n        // Check if the system is used in dependencies\n        const data = this.dataManager.getData();\n        const incomingDeps = data.dependencies.filter(dep => dep.target === systemId);\n        const outgoingDeps = data.dependencies.filter(dep => dep.source === systemId);\n\n        let message = `Do you really want to delete the system \"${system.name}\"?`;\n\n        if (incomingDeps.length > 0 || outgoingDeps.length > 0) {\n            message += `<br><br><div class=\"alert alert-warning\">\n                <strong>Warning:</strong> This system has ${incomingDeps.length + outgoingDeps.length} \n                dependencies that will also be deleted.\n            </div>`;\n        }\n\n        document.getElementById('confirm-message').innerHTML = message;\n        document.getElementById('confirm-action').setAttribute('data-action', 'delete-system');\n        document.getElementById('confirm-action').setAttribute('data-id', systemId);\n\n        // Show modal\n        const modal = new bootstrap.Modal(document.getElementById('confirm-modal'));\n        modal.show();\n    }\n\n    /**\n     * Deletes a system and its dependencies\n     * @param {string} systemId - The ID of the system to delete\n     */\n    deleteSystem(systemId) {\n        // Find system and store name for notification\n        const system = this.dataManager.getData().systems.find(sys => sys.id === systemId);\n        if (!system) return;\n\n        const systemName = system.name;\n\n        // Delete system via DataManager\n        this.dataManager.deleteSystem(systemId);\n\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)(`System \"${systemName}\" and related dependencies have been deleted`, 'success');\n\n        // Close details panel\n        document.getElementById('details-panel').classList.remove('active');\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/system-manager.js?");

/***/ }),

/***/ "./src/utilities.js":
/*!**************************!*\
  !*** ./src/utilities.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encryptAndStore: () => (/* binding */ encryptAndStore),\n/* harmony export */   retrieveAndDecrypt: () => (/* binding */ retrieveAndDecrypt),\n/* harmony export */   showNotification: () => (/* binding */ showNotification)\n/* harmony export */ });\n/**\n * Displays a notification at the top of the screen\n * @param {string} message - The message to display\n * @param {string} type - The Bootstrap type (success, danger, warning, info)\n */\nfunction showNotification(message, type = 'info') {\n    // Check if a notification container exists\n    let notificationContainer = document.getElementById('notification-container');\n    \n    if (!notificationContainer) {\n        // Create a new container if none exists\n        notificationContainer = document.createElement('div');\n        notificationContainer.id = 'notification-container';\n        notificationContainer.style.position = 'fixed';\n        notificationContainer.style.top = '10px';\n        notificationContainer.style.left = '50%';\n        notificationContainer.style.transform = 'translateX(-50%)';\n        notificationContainer.style.zIndex = '9999';\n        document.body.appendChild(notificationContainer);\n    }\n    \n    // Create the notification\n    const notification = document.createElement('div');\n    notification.className = `alert alert-${type} alert-dismissible fade show`;\n    notification.role = 'alert';\n    notification.innerHTML = `\n        ${message}\n        <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\" aria-label=\"Close\"></button>\n    `;\n    \n    // Add the notification to the container\n    notificationContainer.appendChild(notification);\n    \n    // Remove the notification after 5 seconds\n    setTimeout(() => {\n        notification.classList.remove('show');\n        setTimeout(() => {\n            notificationContainer.removeChild(notification);\n        }, 300);\n    }, 5000);\n}\n\n/**\n * Initialisiert einen client-spezifischen Verschlüsselungsschlüssel\n * Falls noch nicht vorhanden, wird ein neuer generiert und gespeichert\n * @returns {string} Verschlüsselungsschlüssel für diesen Client\n */\nfunction getOrCreateClientKey(recreate = false) {\n  // Prüfen, ob bereits ein Client-Key existiert\n  let clientKey = localStorage.getItem('_client_encryption_salt');\n  \n  // Falls nicht, einen neuen erstellen und speichern\n  if (!clientKey || recreate) {\n    // 32 zufällige Bytes generieren und als Hex-String speichern\n    const randomBytes = crypto.getRandomValues(new Uint8Array(32));\n    clientKey = Array.from(randomBytes)\n      .map(b => b.toString(16).padStart(2, '0'))\n      .join('');\n    \n    localStorage.setItem('_client_encryption_salt', clientKey);\n  }\n  \n  // Kombination aus dem gespeicherten Salt und einigen browserspezifischen Daten\n  const browserFingerprint = navigator.userAgent + navigator.language + screen.colorDepth;\n  \n  // Einfache (nicht kryptografische) Kombination der Werte\n  return clientKey + '_' + browserFingerprint.split('').reduce((hash, char) => {\n    return ((hash << 5) - hash) + char.charCodeAt(0);\n  }, 0);\n}\n\n/**\n * Stores a value encrypted in localStorage\n * @param {string} storageKey - Key for localStorage \n * @param {string} value - Value to store (e.g. API Key)\n * @param {string} password - Password for encryption\n * @returns {Promise<void>}\n */\nasync function encryptAndStore(storageKey, value) {\n    try {\n        const password = getOrCreateClientKey();\n        // Salt and IV for more security\n        const salt = crypto.getRandomValues(new Uint8Array(16));\n        const iv = crypto.getRandomValues(new Uint8Array(12));\n        \n        // Derive a cryptographic key from the password\n        const passwordKey = await crypto.subtle.importKey(\n            'raw', \n            new TextEncoder().encode(password),\n            { name: 'PBKDF2' },\n            false, \n            ['deriveBits', 'deriveKey']\n        );\n        \n        const aesKey = await crypto.subtle.deriveKey(\n            {\n                name: 'PBKDF2',\n                salt: salt,\n                iterations: 100000,\n                hash: 'SHA-256'\n            },\n            passwordKey,\n            { name: 'AES-GCM', length: 256 },\n            false,\n            ['encrypt']\n        );\n        \n        // Encrypt value\n        const encrypted = await crypto.subtle.encrypt(\n            { name: 'AES-GCM', iv: iv },\n            aesKey,\n            new TextEncoder().encode(value)\n        );\n        \n        // Combine everything into an object and store as JSON in localStorage\n        const encryptedObj = {\n            salt: Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join(''),\n            iv: Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join(''),\n            data: Array.from(new Uint8Array(encrypted)).map(b => b.toString(16).padStart(2, '0')).join('')\n        };\n        \n        const jsonString = JSON.stringify(encryptedObj);\n        const jsonStringBase64 = btoa(encodeURIComponent(jsonString).replace(/%([0-9A-F]{2})/g, (_, p1) => String.fromCharCode('0x' + p1)));\n        localStorage.setItem(storageKey, jsonStringBase64);\n    } catch (error) {\n        console.error('Encryption error:', error);\n    }\n}\n\n/**\n * Reads an encrypted value from localStorage and decrypts it\n * @param {string} storageKey - Key for localStorage\n * @param {string} password - Password for decryption\n * @returns {Promise<string|null>} - Decrypted value or null on error\n */\nasync function retrieveAndDecrypt(storageKey) {\n    try {\n        const password = getOrCreateClientKey();\n        // Get encrypted data from localStorage\n        const storedData = localStorage.getItem(storageKey);\n        if (!storedData) return null;\n        // Decode base64 to JSON string\n        const jsonString = decodeURIComponent(Array.prototype.map.call(atob(storedData), c => \n            '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)\n        ).join(''));\n        const encryptedObj = JSON.parse(jsonString);\n        if (!encryptedObj) return null;\n        \n        // Convert hex strings back to Uint8Arrays\n        const salt = new Uint8Array(encryptedObj.salt.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n        const iv = new Uint8Array(encryptedObj.iv.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n        const encryptedData = new Uint8Array(encryptedObj.data.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n        \n        // Derive a cryptographic key from the password (same process as when storing)\n        const passwordKey = await crypto.subtle.importKey(\n            'raw', \n            new TextEncoder().encode(password),\n            { name: 'PBKDF2' },\n            false, \n            ['deriveBits', 'deriveKey']\n        );\n        \n        const aesKey = await crypto.subtle.deriveKey(\n            {\n                name: 'PBKDF2',\n                salt: salt,\n                iterations: 100000,\n                hash: 'SHA-256'\n            },\n            passwordKey,\n            { name: 'AES-GCM', length: 256 },\n            false,\n            ['decrypt']\n        );\n        \n        // Decrypt\n        const decrypted = await crypto.subtle.decrypt(\n            { name: 'AES-GCM', iv: iv },\n            aesKey,\n            encryptedData\n        );\n        \n        // Return as string\n        return new TextDecoder().decode(decrypted);\n    } catch (error) {\n        console.error('Decryption error:', error);\n        return null;\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/utilities.js?");

/***/ }),

/***/ "./src/visualizer.js":
/*!***************************!*\
  !*** ./src/visualizer.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemVisualizer: () => (/* binding */ SystemVisualizer)\n/* harmony export */ });\n/* harmony import */ var _simulation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simulation.js */ \"./src/simulation.js\");\n/* harmony import */ var _node_cache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node-cache.js */ \"./src/node-cache.js\");\n/* harmony import */ var _event_emitter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event-emitter.js */ \"./src/event-emitter.js\");\n\n\n\n\n/**\n * SystemVisualizer - Visualizes IT systems and their dependencies as an interactive graph\n */\nclass SystemVisualizer extends _event_emitter_js__WEBPACK_IMPORTED_MODULE_2__.EventEmitter {\n    constructor(containerId, dataManager) {\n        super();\n        this.containerId = containerId;\n        this.dataManager = dataManager;\n\n        // Getter for access to current data\n        Object.defineProperty(this, 'data', {\n            get: () => this.dataManager.getData()\n        });\n\n        // D3 visualization variables\n        this.svg = null;\n        this.width = 0;\n        this.height = 0;\n        this.zoom = null;\n\n        // UI states\n        this.searchResults = [];\n        this.activeFilters = {\n            categories: [\"core\", \"legacy\", \"data\", \"service\", \"external\"],\n            knownUsage: [\"known\", \"unknown\"]\n        };\n\n        // Color scales\n        this.colorScale = d3.scaleOrdinal()\n            .domain([\"core\", \"legacy\", \"data\", \"service\", \"external\"])\n            .range([\"#0d6efd\", \"#6c757d\", \"#198754\", \"#ffc107\", \"#dc3545\"]);\n        this.groupColorScale = d3.scaleOrdinal(d3.schemeCategory10);\n\n        // Create node cache\n        this.nodeCache = new _node_cache_js__WEBPACK_IMPORTED_MODULE_1__.NodeCache({\n            useLocalStorage: true,\n            localStorageKey: 'system_visualizer_node_positions',\n            debounceTime: 250\n        });\n\n        // SimulationManager (will be initialized later)\n        this.simulationManager = null;\n\n        // Visualization elements\n        this.nodeElements = null;\n        this.linkElements = null;\n        this.groupHulls = null;\n        this.groupLabels = null;\n    }\n\n    /**\n     * Initializes the visualization\n     */\n    initialize() {\n        if (!this.data) {\n            console.error(\"No data available for visualization\");\n            return;\n        }\n\n        this.createVisualization();\n        this.setupZoom();\n        this.attachEventListeners();\n\n        // React to data changes\n        this.dataManager.on('dataChanged', () => {\n            // Recreate visualization\n            const container = document.getElementById(this.containerId);\n            if (container) {\n                container.innerHTML = '';\n                this.createVisualization();\n                this.setupZoom();\n            }\n        });\n\n        // Update details panel on data changes\n        this.dataManager.on('dataChanged', () => {\n            const detailsPanel = document.getElementById('details-panel');\n            if (detailsPanel && detailsPanel.classList.contains('active')) {\n                const systemId = document.getElementById('detail-title').getAttribute('data-system-id');\n                if (systemId) {\n                    const updatedSystem = this.dataManager.getData().systems.find(sys => sys.id === systemId);\n                    if (updatedSystem) {\n                        this.showSystemDetails(updatedSystem);\n                    } else {\n                        detailsPanel.classList.remove('active');\n                    }\n                }\n            }\n        });\n\n        // Event listener for window resize\n        window.addEventListener('resize', this.handleResize.bind(this));\n\n        // Update cache before leaving\n        window.addEventListener('beforeunload', () => {\n            if (this.simulationManager) {\n                this.simulationManager.stop();\n            }\n        });\n    }\n\n    /**\n     * Creates the D3.js visualization\n     */\n    createVisualization() {\n        const container = document.getElementById(this.containerId);\n\n        if (!container) {\n            console.error(`Container with ID \"${this.containerId}\" not found`);\n            return;\n        }\n\n        // Size and margins (fullscreen)\n        this.width = container.clientWidth;\n        this.height = container.clientHeight;\n\n        // Create SVG\n        this.svg = d3.select(container)\n            .append(\"svg\")\n            .attr(\"width\", this.width)\n            .attr(\"height\", this.height);\n\n        // Group for zoom\n        const g = this.svg.append(\"g\");\n\n        // Create tooltip\n        // Find or create tooltip element (as D3 selection)\n        let tooltip = d3.select(\"body\").select(\".tooltip\");\n        if (tooltip.empty()) {\n            tooltip = d3.select(\"body\").append(\"div\")\n                .attr(\"class\", \"tooltip\")\n                .style(\"opacity\", 0);\n        }\n\n        // Prepare and filter graph data\n        const nodes = this.getFilteredNodes();\n        const links = this.getFilteredLinks(nodes);\n\n        // Identify groupings\n        const groups = this.identifyGroups(nodes);\n\n        // Create SimulationManager\n        this.simulationManager = new _simulation_js__WEBPACK_IMPORTED_MODULE_0__.SimulationManager({\n            width: this.width,\n            height: this.height,\n            nodeCache: this.nodeCache,\n            linkDistance: 150,\n            chargeStrength: -300,\n            collisionRadius: 60,\n            groupForceStrength: 0.5,\n            onTick: () => this.onSimulationTick(),\n            onToggleFixed:(id, state) => {\n                this.emit('toggleFixed', { id, state });\n            },\n        });\n\n        // Arrowheads for the links\n        g.append(\"defs\").selectAll(\"marker\")\n            .data([\"data\", \"integration\", \"authentication\", \"monitoring\"])\n            .enter().append(\"marker\")\n            .attr(\"id\", d => `arrowhead-${d}`)\n            .attr(\"viewBox\", \"0 -5 10 10\")\n            .attr(\"refX\", 8)  // No offset - arrowhead starts at end of path\n            .attr(\"refY\", 0)  // No offset\n            .attr(\"markerWidth\", 6)\n            .attr(\"markerHeight\", 6)\n            .attr(\"orient\", \"auto\")\n            .append(\"path\")\n            .attr(\"d\", \"M0,-5L10,0L0,5\")\n            .attr(\"fill\", d => {\n                switch (d) {\n                    case \"data\": return \"#0d6efd\";\n                    case \"integration\": return \"#198754\";\n                    case \"authentication\": return \"#dc3545\";\n                    case \"monitoring\": return \"#6c757d\";\n                    default: return \"#999\";\n                }\n            });\n\n        // Draw group hulls (before nodes and links)\n        this.groupHulls = g.append(\"g\")\n            .attr(\"class\", \"groups\")\n            .selectAll(\".group-hull\")\n            .data(Object.entries(groups).filter(([name]) => name !== \"ungrouped\")) // filter out \"undefined\" group\n            .enter().append(\"path\")\n            .attr(\"class\", \"group-hull\")\n            .attr(\"data-group\", d => d[0])\n            .style(\"fill\", d => this.groupColorScale(d[0]))\n            .style(\"stroke\", d => d3.rgb(this.groupColorScale(d[0])).darker())\n            .style(\"stroke-width\", 1.5)\n            .style(\"fill-opacity\", 0.2)\n            .style(\"stroke-opacity\", 0.4);\n\n        // Draw links\n        const that = this;\n        this.linkElements = g.append(\"g\")\n            .attr(\"class\", \"links\")\n            .selectAll(\"path\")\n            .data(links)\n            .enter().append(\"path\")\n            .attr(\"class\", \"link\")\n            .attr(\"marker-end\", d => `url(#arrowhead-${d.type})`)\n            .attr(\"data-type\", d => d.type)\n            .attr(\"data-link-index\", d => d.linkIndex)\n            .attr(\"data-total-links\", d => d.totalLinks)\n            .on(\"mouseover\", function (event, d) {\n                if (that.dragDisabled) return;\n                tooltip.transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n\n                const sourceSystem = nodes.find(n => n.id === d.source.id || n.id === d.source);\n                const targetSystem = nodes.find(n => n.id === d.target.id || n.id === d.target);\n\n                tooltip.html(`\n                    <strong>${sourceSystem ? sourceSystem.name : 'Unknown'} → ${targetSystem ? targetSystem.name : 'Unknown'}</strong><br>\n                    ${d.description || 'No description'}<br>\n                    <em>Protocol: ${d.protocol || 'Not specified'}</em>\n                `);\n\n                // Position tooltip centered below the mouse pointer\n                const tooltipNode = tooltip.node();\n                // Temporarily make visible to measure width\n                tooltip.style(\"opacity\", 0).style(\"display\", \"block\");\n                const tooltipWidth = tooltipNode.offsetWidth;\n                tooltip.style(\"display\", null); // reset\n\n                tooltip\n                    .style(\"left\", (event.pageX - tooltipWidth / 2) + \"px\")\n                    .style(\"top\", (event.pageY + 16) + \"px\")\n                    .transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n            })\n            .on(\"mouseout\", function () {\n                tooltip.transition()\n                    .duration(500)\n                    .style(\"opacity\", 0);\n            })\n            .on(\"click\", (event, data) => {\n                this.emit('dependencyClick', { event, data });\n                event.stopPropagation();\n            });\n\n        // Create nodes\n        const nodeGroup = g.append(\"g\")\n            .attr(\"class\", \"nodes\");\n\n        this.nodeElements = nodeGroup.selectAll(\".node\")\n            .data(nodes)\n            .enter().append(\"g\")\n            .attr(\"class\", d => {\n                const classes = [\"node\"];\n                if (!d.knownUsage) classes.push(\"unknown-usage\");\n\n                // Add multiple group classes\n                const nodeGroups = this.getNodeGroups(d);\n                nodeGroups.forEach(group => {\n                    classes.push(`group-${group}`);\n                });\n\n                return classes.join(\" \");\n            })\n            .attr(\"data-system-id\", d => d.id)\n            .attr(\"data-groups\", d => this.getNodeGroups(d).join(\",\"));\n\n        if (!this.dragDisabled) {\n            this.nodeElements.call(this.simulationManager.createDragBehavior())\n        }\n\n        // Circles for the systems\n        const radius = 30;\n        this.nodeElements.append(\"circle\")\n            .attr(\"r\", radius)\n            .attr(\"fill\", d => this.colorScale(d.category))\n            .attr(\"stroke\", d => {\n                const nodeGroups = this.getNodeGroups(d);\n                if (nodeGroups.length > 0) {\n                    // For multiple groups, create a multi-color stroke (could be dashed)\n                    return nodeGroups.length > 1 ?\n                        \"url(#multigroup-gradient-\" + d.id + \")\" : // ID for gradient\n                        this.groupColorScale(nodeGroups[0]); // Single group\n                }\n                return \"#fff\"; // Default without group\n            })\n            .attr(\"stroke-width\", d => this.getNodeGroups(d).length > 0 ? 3 : 2)\n            .attr(\"stroke-dasharray\", d => this.getNodeGroups(d).length > 1 ? \"5,3\" : null)\n            .on(\"mouseover\", function (event, d) {\n                if (that.dragDisabled) return;\n                tooltip.transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n                tooltip.html(`\n                    <strong>${d.name}</strong><br>\n                    ${d.description}<br>\n                    ${d.group ? '<span class=\"badge bg-info\">Group: ' + d.group + '</span>' : ''}\n                `);\n\n                // Temporarily make visible to measure width and height\n                tooltip.style(\"opacity\", 0).style(\"display\", \"block\");\n                const tooltipNode = tooltip.node();\n                const tooltipWidth = tooltipNode.offsetWidth;\n                tooltip.style(\"display\", null); // reset\n\n                // Determine height of the circle (SVG circle has r=30)\n                const circleRadius = radius;\n                // Optionally: If the circle radius is dynamic, you could get it like this:\n                // const circleRadius = d3.select(this).attr(\"r\");\n\n                tooltip\n                    .style(\"left\", (event.pageX - tooltipWidth / 2) + \"px\")\n                    .style(\"top\", (event.pageY + Number(circleRadius) + 8) + \"px\") // 8px below the circle\n                    .transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n            })\n            .on(\"mouseout\", function () {\n                tooltip.transition()\n                    .duration(500)\n                    .style(\"opacity\", 0);\n            })\n            .on(\"click\", (event, d) => this.showSystemDetails(d));\n\n        // Text labels\n        this.nodeElements.append(\"text\")\n            .attr(\"dy\", -40)\n            .attr(\"text-anchor\", \"middle\")\n            .text(d => d.name)\n            .attr(\"fill\", \"#333\")\n            .style(\"user-select\", \"none\")\n            .style(\"pointer-events\", \"none\");\n\n        // Add group labels\n        this.groupLabels = g.append(\"g\")\n            .attr(\"class\", \"group-labels\")\n            .selectAll(\".group-label\")\n            .data(Object.entries(groups).filter(([name]) => name !== \"ungrouped\"))\n            .enter().append(\"text\")\n            .attr(\"class\", \"group-label\")\n            .attr(\"text-anchor\", \"middle\")\n            .style(\"font-size\", \"16px\")\n            .style(\"font-weight\", \"bold\")\n            .style(\"fill\", d => d3.rgb(this.groupColorScale(d[0])).darker(2))\n            .style(\"user-select\", \"none\")\n            .style(\"pointer-events\", \"none\")\n            .text(d => {\n                // Display for merged groups\n                if (d[1].allGroups && d[1].allGroups.length > 1) {\n                    return `${d[0]} (+${d[1].allGroups.length - 1})`;\n                }\n                return d[0];\n            });\n        this.groupLabels.append(\"title\") // Tooltip for details\n            .text(d => {\n                if (d[1].allGroups && d[1].allGroups.length > 1) {\n                    return `Merged groups:\\n${d[1].allGroups.join('\\n')}`;\n                }\n                return d[0];\n            });\n\n        const defs = g.select(\"defs\");\n        nodes.forEach(d => {\n            const nodeGroups = this.getNodeGroups(d);\n            if (nodeGroups.length > 1) {\n                const gradient = defs.append(\"linearGradient\")\n                    .attr(\"id\", \"multigroup-gradient-\" + d.id)\n                    .attr(\"x1\", \"0%\")\n                    .attr(\"y1\", \"0%\")\n                    .attr(\"x2\", \"100%\")\n                    .attr(\"y2\", \"100%\");\n\n                // Add color stops for each group\n                nodeGroups.forEach((group, i) => {\n                    gradient.append(\"stop\")\n                        .attr(\"offset\", (i / (nodeGroups.length - 1) * 100) + \"%\")\n                        .attr(\"stop-color\", this.groupColorScale(group));\n                });\n            }\n        });\n\n        // Start simulation\n        this.simulationManager.initialize(nodes, links, groups);\n    }\n\n    /**\n    * Returns filtered links based on the filtered nodes\n    */\n    getFilteredLinks(nodes) {\n        const nodeIds = nodes.map(node => node.id);\n\n        // Initialize link counters\n        const linkCounts = {};\n\n        // First filter the links\n        const filteredLinks = this.data.dependencies.filter(dep => {\n            return nodeIds.includes(dep.source) && nodeIds.includes(dep.target);\n        });\n\n        // Count and index links\n        filteredLinks.forEach(dep => {\n            const key = `${dep.source}-${dep.target}`;\n            const reverseKey = `${dep.target}-${dep.source}`;\n\n            // Initialize counter for this direction\n            if (!linkCounts[key]) {\n                linkCounts[key] = 0;\n            }\n\n            // Increment counter and assign to link\n            linkCounts[key]++;\n            dep.linkIndex = linkCounts[key] - 1; // 0-based index\n\n            // Store total number of links in this direction\n            dep.totalLinks = filteredLinks.filter(d =>\n                (d.source === dep.source && d.target === dep.target)\n            ).length;\n        });\n\n        // Return links with additional information\n        return filteredLinks.map(dep => ({\n            source: dep.source,\n            target: dep.target,\n            linkIndex: dep.linkIndex,\n            totalLinks: dep.totalLinks,\n            ...dep\n        }));\n    }\n\n    /**\n     * Called on every simulation tick\n     */\n    onSimulationTick() {\n        if (!this.linkElements || !this.nodeElements || !this.groupHulls || !this.groupLabels) {\n            return;\n        }\n\n        // Update links\n        this.linkElements.attr(\"d\", this.linkArc);\n\n        // Update nodes\n        this.nodeElements.attr(\"transform\", d => `translate(${d.x},${d.y})`);\n\n        // Update group hulls\n        this.groupHulls.attr(\"d\", d => {\n            const groupName = d[0];\n            const simulation = this.simulationManager.simulation;\n\n            // Find all nodes that belong to this group\n            // IMPORTANT DIFFERENCE: Now we check if a node belongs to ANY of the original groups\n            const groupNodes = simulation.nodes().filter(n => {\n                const nodeGroups = this.getNodeGroups(n);\n\n                // Check if the node belongs to any of the original groups\n                // that were mapped to this representative group\n                if (d[1].allGroups) {\n                    // For a merged group, check if the node belongs to any of the original groups\n                    return nodeGroups.some(ng => d[1].allGroups.includes(ng));\n                } else {\n                    // For a single group, check normally\n                    return nodeGroups.includes(groupName);\n                }\n            });\n\n            // If no nodes or only one node, draw a small circle around it\n            if (groupNodes.length === 0) {\n                return \"\"; // No hull if no nodes\n            }\n\n            if (groupNodes.length === 1) {\n                // For only one node: draw a circle around it\n                const node = groupNodes[0];\n                return `M${node.x + 60},${node.y} \n                    A60,60 0 1,1 ${node.x - 60},${node.y} \n                    A60,60 0 1,1 ${node.x + 60},${node.y}`;\n            }\n\n            // Calculate centroid of the group\n            const points = groupNodes.map(n => [n.x, n.y]);\n            const centroid = this.getCentroid(points);\n\n            // Calculate radius (with extra padding)\n            const maxDist = Math.max(40, this.getMaxDistanceFromCentroid(points, centroid) + 40);\n\n            // Draw a circular hull around the group\n            return this.createHullPath(centroid, maxDist, 24);\n        });\n\n        // Update group labels\n        this.groupLabels.attr(\"transform\", d => {\n            const groupName = d[0];\n            const simulation = this.simulationManager.simulation;\n\n            // Use the same filter logic as for the hulls\n            const groupNodes = simulation.nodes().filter(n => {\n                const nodeGroups = this.getNodeGroups(n);\n\n                if (d[1].allGroups) {\n                    return nodeGroups.some(ng => d[1].allGroups.includes(ng));\n                } else {\n                    return nodeGroups.includes(groupName);\n                }\n            });\n\n            if (groupNodes.length === 0) return \"translate(0,0)\";\n\n            const points = groupNodes.map(n => [n.x, n.y]);\n            const centroid = this.getCentroid(points);\n\n            return `translate(${centroid[0]},${centroid[1] - 60})`;\n        });\n    }\n\n    /**\n     * Sets up zoom functionality\n     */\n    setupZoom() {\n        this.zoom = d3.zoom()\n            .scaleExtent([0.1, 4])\n            .on(\"zoom\", (event) => {\n                this.svg.select(\"g\").attr(\"transform\", event.transform);\n            });\n\n        this.svg.call(this.zoom);\n\n        // Reset zoom button\n        document.getElementById(\"reset-zoom\").addEventListener(\"click\", () => {\n            this.svg.transition().duration(750).call(\n                this.zoom.transform,\n                d3.zoomIdentity\n            );\n        });\n\n        // Save viewport state after zoom or pan\n        this.zoom.on('end', () => {\n            this.saveViewportState();\n        });\n\n        // Restore viewport state\n        this.restoreViewportState();\n    }\n\n    /**\n     * Optimized linkArc function with adjusted distribution for even number of links\n     */\n    linkArc(d) {\n        // Node radius\n        const nodeRadius = 32;\n\n        // Extract source and target coordinates\n        const sourceX = d.source.x;\n        const sourceY = d.source.y;\n        const targetX = d.target.x;\n        const targetY = d.target.y;\n\n        // Calculate distance and base angle between nodes\n        const dx = targetX - sourceX;\n        const dy = targetY - sourceY;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        const baseAngle = Math.atan2(dy, dx);\n\n        // Determine angle offsets\n        const totalLinks = d.totalLinks || 1;\n        const linkIndex = d.linkIndex || 0;\n\n        // Maximum angle offset in degrees (±15°), converted to radians\n        const maxOffsetDegrees = 15;\n        const maxOffset = (maxOffsetDegrees * Math.PI) / 180;\n\n        // Calculate angle offset - with adjustment for even number of links\n        let angleOffset = 0;\n\n        if (totalLinks > 1) {\n            if (totalLinks % 2 === 0) {\n                // For even number: shift to avoid the center\n                // e.g. for 4 links: -0.75, -0.25, +0.25, +0.75 instead of -1, -0.33, +0.33, +1\n                const step = 1 / totalLinks;\n                angleOffset = ((linkIndex / (totalLinks - 1)) * 2 - 1 + step) * maxOffset;\n            } else {\n                // For odd number: normal distribution\n                angleOffset = ((linkIndex / (totalLinks - 1)) * 2 - 1) * maxOffset;\n            }\n        }\n\n        // Start point on the source node\n        const startAngle = baseAngle + angleOffset;\n        const startX = sourceX + Math.cos(startAngle) * nodeRadius;\n        const startY = sourceY + Math.sin(startAngle) * nodeRadius;\n\n        // End point on the target node with mirrored angle offset\n        const endAngle = baseAngle + Math.PI - angleOffset;\n        const endX = targetX + Math.cos(endAngle) * nodeRadius;\n        const endY = targetY + Math.sin(endAngle) * nodeRadius;\n\n        // Minimal angle offset for curvature (even for single links)\n        // Single links get a slight curve instead of a straight line\n        const minCurvatureAngle = (3 * Math.PI) / 180;  // 3 degrees in radians\n\n        // Effective angle offset for curvature calculation\n        const effectiveAngleOffset = Math.max(Math.abs(angleOffset), minCurvatureAngle);\n\n        // Arc direction based on the sign of the angle offset\n        // For single links: default to clockwise\n        const sweep = (totalLinks === 1 || angleOffset >= 0) ? 1 : 0;\n\n        // Curvature factor based on angle offset and distance\n        // Minimum 0.15 for slight curve, maximum 0.5 for strong curve\n        let curvature = 0.15 + (effectiveAngleOffset / maxOffset) * 0.35;\n\n        // Orthogonal direction vectors for the control point\n        const tangentX = (endX - startX) / distance;\n        const tangentY = (endY - startY) / distance;\n        const perpX = -tangentY;\n        const perpY = tangentX;\n\n        // Calculate midpoint\n        const midX = (startX + endX) / 2;\n        const midY = (startY + endY) / 2;\n\n        // Control point with direction based on sweep\n        const ctrlFactor = (sweep === 1 ? 1 : -1) * curvature * distance;\n        const ctrlX = midX + perpX * ctrlFactor;\n        const ctrlY = midY + perpY * ctrlFactor;\n\n        // Quadratic Bézier curve\n        return `M${startX},${startY}Q${ctrlX},${ctrlY} ${endX},${endY}`;\n    }\n\n    /**\n     * Identifies all groups and prepares them for d3.js\n     * Optimized to merge groups with identical nodes\n     */\n    identifyGroups(nodes) {\n        // Step 1: Create initial grouping\n        const initialGroupMap = {};\n        const UNGROUPED_GROUP_NAME = \"ungrouped\";\n\n        // Data structure: group -> associated nodes\n        nodes.forEach(node => {\n            const nodeGroups = this.getNodeGroups(node);\n\n            if (nodeGroups.length > 0) {\n                nodeGroups.forEach(groupName => {\n                    if (!initialGroupMap[groupName]) {\n                        initialGroupMap[groupName] = {\n                            nodes: [],\n                            nodeIds: new Set(),\n                            x: 0,\n                            y: 0\n                        };\n                    }\n                    initialGroupMap[groupName].nodes.push(node);\n                    initialGroupMap[groupName].nodeIds.add(node.id);\n                });\n            } else {\n                if (!initialGroupMap[UNGROUPED_GROUP_NAME]) {\n                    initialGroupMap[UNGROUPED_GROUP_NAME] = {\n                        nodes: [],\n                        nodeIds: new Set(),\n                        x: 0,\n                        y: 0\n                    };\n                }\n                initialGroupMap[UNGROUPED_GROUP_NAME].nodes.push(node);\n                initialGroupMap[UNGROUPED_GROUP_NAME].nodeIds.add(node.id);\n            }\n        });\n\n        // Step 2: Identify groups with identical nodes\n        const groupSignatures = {};  // Signature -> groups with this signature\n\n        Object.entries(initialGroupMap).forEach(([groupName, groupData]) => {\n            if (groupName === UNGROUPED_GROUP_NAME) return;\n\n            // Create a unique signature based on node IDs\n            const signature = Array.from(groupData.nodeIds).sort().join(',');\n\n            if (!groupSignatures[signature]) {\n                groupSignatures[signature] = [];\n            }\n\n            groupSignatures[signature].push(groupName);\n        });\n\n        // Step 3: Create final group map\n        const finalGroupMap = {};\n\n        // Mapping from original groups to representative groups\n        // IMPORTANT: We store this as a global/class instance variable\n        this.groupMap = {};\n\n        // First add the ungrouped group if present\n        if (initialGroupMap[UNGROUPED_GROUP_NAME]) {\n            finalGroupMap[UNGROUPED_GROUP_NAME] = initialGroupMap[UNGROUPED_GROUP_NAME];\n        }\n\n        // Then the merged groups\n        Object.entries(groupSignatures).forEach(([signature, groups]) => {\n            // Use the first group as the representative group\n            const primaryGroup = groups[0];\n\n            // Add group to the final map\n            finalGroupMap[primaryGroup] = initialGroupMap[primaryGroup];\n\n            // Store all original groups as metadata\n            if (groups.length > 1) {\n                finalGroupMap[primaryGroup].allGroups = groups;\n                console.log(`Merged identical groups: ${groups.join(', ')} -> ${primaryGroup}`);\n\n                // Create bidirectional mapping\n                groups.forEach(originalGroup => {\n                    this.groupMap[originalGroup] = primaryGroup;\n                });\n            } else {\n                // Also create mapping for single groups\n                this.groupMap[primaryGroup] = primaryGroup;\n            }\n        });\n\n        // Step 4: Calculate initial positions\n        Object.entries(finalGroupMap).forEach(([groupName, group], index) => {\n            // Distribute positions evenly around the center\n            const angle = (index / Object.keys(finalGroupMap).length) * 2 * Math.PI;\n            const radius = Math.min(this.width, this.height) * 0.4;\n\n            group.x = this.width / 2 + radius * Math.cos(angle);\n            group.y = this.height / 2 + radius * Math.sin(angle);\n        });\n\n        return finalGroupMap;\n    }\n\n    /**\n     * Helper function to check if two arrays contain the same elements\n     * (Order is ignored)\n     */\n    arraysHaveSameElements(arr1, arr2) {\n        if (arr1.length !== arr2.length) return false;\n\n        const set1 = new Set(arr1);\n        for (const item of arr2) {\n            if (!set1.has(item)) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Helper function to extract all groups of a node\n     * Supports new groups arrays and legacy group fields\n     */\n    getNodeGroups(node) {\n        if (Array.isArray(node.groups) && node.groups.length > 0) {\n            return node.groups;\n        } else if (node.group && typeof node.group === 'string') {\n            return [node.group];\n        }\n        return [];\n    }\n\n    /**\n     * Calculates the centroid of a group of points\n     */\n    getCentroid(points) {\n        const n = points.length;\n        if (n === 0) return [0, 0];\n\n        const sumX = points.reduce((sum, p) => sum + p[0], 0);\n        const sumY = points.reduce((sum, p) => sum + p[1], 0);\n\n        return [sumX / n, sumY / n];\n    }\n\n    /**\n     * Calculates the maximum distance from the centroid to any point in the group\n     */\n    getMaxDistanceFromCentroid(points, centroid) {\n        if (points.length === 0) return 0;\n\n        return Math.max(...points.map(p =>\n            Math.sqrt(Math.pow(p[0] - centroid[0], 2) + Math.pow(p[1] - centroid[1], 2))\n        ));\n    }\n\n    /**\n     * Creates a path for the group hull\n     */\n    createHullPath(center, radius, segments) {\n        const angleStep = (2 * Math.PI) / segments;\n        let path = `M${center[0] + radius},${center[1]}`;\n\n        for (let i = 1; i <= segments; i++) {\n            const angle = i * angleStep;\n            const x = center[0] + radius * Math.cos(angle);\n            const y = center[1] + radius * Math.sin(angle);\n            path += ` L${x},${y}`;\n        }\n\n        return path + \"Z\";\n    }\n\n    /**\n     * Returns the node with the given ID from the current simulation\n     * @param {string} systemId - The ID of the system to find\n     * @returns {Object|null} The node object or null if not found\n     */\n    getNodeById(systemId) {\n        return this.simulationManager.getNodeById(systemId);\n    }\n\n    /**\n     * Checks if a node is fixed\n     * @param {string} systemId - The ID of the system to check\n     * @returns {boolean} True if the node is fixed, false otherwise or if not found\n     */\n    isNodeFixed(systemId) {\n        return this.simulationManager.isNodeFixed(systemId);\n    }\n\n    /**\n     * Toggles the fixed state of a node\n     * @param {string} systemId - The ID of the system to change\n     * @returns {boolean} The new fixed state or null if the node was not found\n     */\n    toggleNodeFixed(systemId) {\n        return this.simulationManager.toggleNodeFixed(systemId);\n    }\n\n    /**\n     * Displays the system details in the overlay\n     */\n    showSystemDetails(system) {\n        const detailsPanel = document.getElementById('details-panel');\n        const detailsDiv = document.getElementById('system-details');\n        const detailTitle = document.getElementById('detail-title');\n\n        if (!detailsDiv || !detailsPanel || !detailTitle) {\n            console.error('Details container not found');\n            return;\n        }\n\n        // Set title\n        detailTitle.textContent = system.name;\n        detailTitle.setAttribute('data-system-id', system.id);\n\n        // Find incoming and outgoing dependencies\n        const incomingDeps = this.data.dependencies.filter(dep => dep.target === system.id);\n        const outgoingDeps = this.data.dependencies.filter(dep => dep.source === system.id);\n\n        let html = `\n        <div class=\"system-detail-card\">\n            <p class=\"mb-1\">${system.description}</p>\n            <div class=\"badge bg-${this.getCategoryClass(system.category)} mb-2\">${system.category}</div>\n            <p><strong>Status:</strong> ${system.status}</p>\n            <p><strong>Known Usage:</strong> ${system.knownUsage ? 'Yes' : 'No'}</p>\n    `;\n\n        // Add group information - multi-group support\n        const groups = [];\n        if (Array.isArray(system.groups) && system.groups.length > 0) {\n            groups.push(...system.groups);\n        } else if (system.group && typeof system.group === 'string') {\n            groups.push(system.group);\n        }\n\n        if (groups.length > 0) {\n            html += `<p><strong>Groups:</strong> ${groups.map(group =>\n                `<span class=\"badge bg-info\">${group}</span>`).join(' ')}</p>`;\n        }\n\n        if (system.tags && system.tags.length > 0) {\n            html += `<p><strong>Tags:</strong> ${system.tags.map(tag =>\n                `<span class=\"badge bg-secondary\">${tag}</span>`).join(' ')}</p>`;\n        }\n\n        if (incomingDeps.length > 0) {\n            html += `<h6 class=\"mt-3\">Incoming Connections</h6><ul class=\"list-group\">`;\n            incomingDeps.forEach(dep => {\n                const source = this.data.systems.find(s => s.id === dep.source);\n                html += `\n                <li class=\"list-group-item\">\n                    <div class=\"d-flex w-100 justify-content-between\">\n                        <strong>${source ? source.name : 'Unknown'}</strong>\n                        <span class=\"badge bg-secondary\">${dep.protocol || 'Unknown'}</span>\n                    </div>\n                    <small>${dep.description || 'No description'}</small>\n                </li>`;\n            });\n            html += `</ul>`;\n        }\n\n        if (outgoingDeps.length > 0) {\n            html += `<h6 class=\"mt-3\">Outgoing Connections</h6><ul class=\"list-group\">`;\n            outgoingDeps.forEach(dep => {\n                const target = this.data.systems.find(s => s.id === dep.target);\n                html += `\n                <li class=\"list-group-item\">\n                    <div class=\"d-flex w-100 justify-content-between\">\n                        <strong>${target ? target.name : 'Unknown'}</strong>\n                        <span class=\"badge bg-secondary\">${dep.protocol || 'Unknown'}</span>\n                    </div>\n                    <small>${dep.description || 'No description'}</small>\n                </li>`;\n            });\n            html += `</ul>`;\n        }\n\n        if (incomingDeps.length === 0 && outgoingDeps.length === 0) {\n            html += `<div class=\"alert alert-warning mt-3\">This system has no known connections.</div>`;\n        }\n\n        html += `</div>`;\n\n        detailsDiv.innerHTML = html;\n\n        // Show details panel\n        detailsPanel.classList.add('active');\n\n        // Adjust button state\n        const toggleFixButton = document.querySelector('.toggle-fix-btn');\n        const isFixed = this.isNodeFixed(system.id);\n        if (toggleFixButton) {\n            if (isFixed) {\n                toggleFixButton.classList.add('active');\n                toggleFixButton.title = 'Release position';\n            } else {\n                toggleFixButton.classList.remove('active');\n                toggleFixButton.title = 'Fix position';\n            }\n        }\n    }\n\n    /**\n     * Helper function to determine the Bootstrap color for categories\n     */\n    getCategoryClass(category) {\n        switch (category) {\n            case 'core': return 'primary';\n            case 'legacy': return 'secondary';\n            case 'data': return 'success';\n            case 'service': return 'warning';\n            case 'external': return 'danger';\n            default: return 'info';\n        }\n    }\n\n    /**\n     * Handles window resize events\n     */\n    handleResize() {\n        const container = document.getElementById(this.containerId);\n        if (container && this.svg) {\n            // Get new size\n            this.width = container.clientWidth;\n            this.height = container.clientHeight;\n\n            // Update SVG size\n            this.svg\n                .attr(\"width\", this.width)\n                .attr(\"height\", this.height);\n\n            // Inform simulation manager about new size\n            if (this.simulationManager) {\n                this.simulationManager.updateSize(this.width, this.height);\n            }\n        }\n    }\n\n    /**\n     * Adds event listeners for UI elements\n     */\n    attachEventListeners() {\n        // Filter for system categories\n        const categoryFilters = document.querySelectorAll('.category-filter');\n        if (categoryFilters.length > 0) {\n            categoryFilters.forEach(filter => {\n                filter.addEventListener('change', () => {\n                    const checkedCategories = Array.from(document.querySelectorAll('.category-filter:checked'))\n                        .map(checkbox => checkbox.value);\n                    this.activeFilters.categories = checkedCategories;\n                });\n            });\n        }\n\n        // Filter for system status\n        const statusFilters = document.querySelectorAll('.status-filter');\n        if (statusFilters.length > 0) {\n            statusFilters.forEach(filter => {\n                filter.addEventListener('change', () => {\n                    const checkedStatuses = Array.from(document.querySelectorAll('.status-filter:checked'))\n                        .map(checkbox => checkbox.value);\n                    this.activeFilters.knownUsage = checkedStatuses;\n                });\n            });\n        }\n\n        // Apply filters\n        const applyFiltersButton = document.getElementById('apply-filters');\n        if (applyFiltersButton) {\n            applyFiltersButton.addEventListener('click', () => {\n                this.applyFilters();\n                document.getElementById('filter-panel').classList.remove('active');\n            });\n        }\n\n        // Search field\n        const searchInput = document.getElementById('system-search');\n        if (searchInput) {\n            searchInput.addEventListener('input', () => this.performSearch(searchInput.value));\n        }\n    }\n\n    /**\n     * Applies filters to the visualization\n     */\n    applyFilters() {\n        if (this.svg) {\n            this.svg.remove();\n            this.createVisualization();\n            this.setupZoom();\n        }\n    }\n\n    /**\n     * Returns filtered nodes\n     */\n    getFilteredNodes() {\n        return this.data.systems.filter(system => {\n            // Category filter\n            if (!this.activeFilters.categories.includes(system.category)) {\n                return false;\n            }\n\n            // Status filter (known/unknown usage)\n            const usageType = system.knownUsage ? 'known' : 'unknown';\n            if (!this.activeFilters.knownUsage.includes(usageType)) {\n                return false;\n            }\n\n            return true;\n        }).map(system => ({ ...system }));\n    }\n\n    /**\n     * Performs a search and displays the results\n     */\n    performSearch(query) {\n        const resultsContainer = document.getElementById('search-results');\n\n        if (!resultsContainer) {\n            console.error('Search results container not found');\n            return;\n        }\n\n        if (!query || query.trim() === '') {\n            resultsContainer.innerHTML = '';\n            return;\n        }\n\n        const searchTerm = query.toLowerCase().trim();\n\n        // Search systems\n        const results = this.data.systems.filter(system => {\n            return (\n                system.name.toLowerCase().includes(searchTerm) ||\n                system.description.toLowerCase().includes(searchTerm) ||\n                (system.tags && system.tags.some(tag => tag.toLowerCase().includes(searchTerm))) ||\n                (system.group && system.group.toLowerCase().includes(searchTerm)) // Also search in groups\n            );\n        });\n\n        // Display results\n        if (results.length === 0) {\n            resultsContainer.innerHTML = '<div class=\"alert alert-info\">No systems found.</div>';\n        } else {\n            let html = '';\n\n            results.forEach(system => {\n                html += `\n                    <button class=\"list-group-item list-group-item-action\" data-system-id=\"${system.id}\">\n                        <div class=\"d-flex w-100 justify-content-between\">\n                            <h6 class=\"mb-1\">${system.name}</h6>\n                            <span class=\"badge bg-${this.getCategoryClass(system.category)}\">${system.category}</span>\n                        </div>\n                        <small>${system.description}</small>\n                        ${system.group ? `<br><small><span class=\"badge bg-info\">Group: ${system.group}</span></small>` : ''}\n                    </button>\n                `;\n            });\n\n            resultsContainer.innerHTML = html;\n\n            // Event listeners for clicks on search results\n            const resultItems = resultsContainer.querySelectorAll('.list-group-item');\n            resultItems.forEach(item => {\n                item.addEventListener('click', () => {\n                    const systemId = item.getAttribute('data-system-id');\n                    const system = this.data.systems.find(s => s.id === systemId);\n\n                    if (system) {\n                        this.showSystemDetails(system);\n                        document.getElementById('search-panel').classList.remove('active');\n                    }\n                });\n            });\n        }\n    }\n\n    \n    /**\n     * Saves the current viewport's zoom and pan state to localStorage.\n     * The state includes the x and y translation, as well as the zoom scale (k),\n     * and is stored under the key 'system_visualizer_transform'.\n     * Requires the presence of an SVG element and d3.zoomTransform.\n     */\n    saveViewportState() {\n        if (this.svg) {\n            const currentTransform = d3.zoomTransform(this.svg.node());\n            localStorage.setItem('system_visualizer_transform', JSON.stringify({\n                x: currentTransform.x,\n                y: currentTransform.y,\n                k: currentTransform.k\n            }));\n        }\n    }\n\n    \n    /**\n     * Restores the viewport state of the SVG element by retrieving the last saved\n     * zoom and pan transform from localStorage and applying it using D3's zoom behavior.\n     * If the stored transform is not available or an error occurs, a warning is logged.\n     *\n     * @returns {void}\n     */\n    restoreViewportState() {\n        try {\n            const storedTransform = localStorage.getItem('system_visualizer_transform');\n            if (storedTransform && this.svg && this.zoom) {\n                const t = JSON.parse(storedTransform);\n                const transform = d3.zoomIdentity.translate(t.x, t.y).scale(t.k);\n                this.svg.call(this.zoom.transform, transform);\n            }\n        } catch (e) {\n            console.warn('Fehler beim Wiederherstellen des Viewports:', e);\n        }\n    }\n\n    /**\n     * Disables the drag functionality for nodes\n     */\n    disableDrag() {\n        if (this.nodeElements) {\n            this.nodeElements.on('.drag', null);\n        }\n        this.dragDisabled = true;\n    }\n\n    /**\n     * Enables the drag functionality for nodes again\n     */\n    enableDrag() {\n        if (this.nodeElements && this.simulationManager) {\n            this.nodeElements.call(this.simulationManager.createDragBehavior());\n        }\n        this.dragDisabled = false;\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/visualizer.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;