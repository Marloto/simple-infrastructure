/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/completion.js":
/*!***************************!*\
  !*** ./src/completion.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGenerator: () => (/* binding */ createGenerator),\n/* harmony export */   handleSse: () => (/* binding */ handleSse)\n/* harmony export */ });\nclass PromptTemplate {\n    constructor(template) {\n        this.template = template;\n    }\n\n    // Methode 1: Template Literals (moderne ES6+ Syntax)\n    formatWithTemplateString(variables) {\n        return new Function(...Object.keys(variables), `return \\`${this.template}\\`;`)(...Object.values(variables));\n    }\n\n    // Methode 2: Named Parameters mit {{name}}\n    formatWithNamedParams(variables) {\n        return this.template.replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => variables[key] || \"\");\n    }\n}\n\nclass AbstractLlmApi {\n    async generate() {\n        throw new Error(\"Not implemented\");\n    }\n\n    setSystemPrompt(systemPrompt) {\n        this.systemPrompt = systemPrompt; \n    }\n\n    getSystemPrompt() {\n        return this.systemPrompt;\n    }\n\n    attachMessage(role, content) {\n        if(!this.messages) {\n            this.reset();\n        }\n        this.messages.push({ role, content });\n    }\n\n    attachMessageAsAssistant(content) {\n        this.attachMessage(this.getAssistantRole(), content);\n    }\n\n    attachMessageAsUser(content) {\n        this.attachMessage(this.getUserRole(), content);\n    }\n\n    reset() {\n        this.messages = [];\n    }\n\n    extractMessages(line) {\n        throw new Error(\"Not implemented\");\n    }\n\n    getAssistantRole() {\n        return \"assistant\";\n    }\n    getUserRole() {\n        return \"user\";\n    }\n    getDetails() {\n        return {\"type\": \"unknown\"};\n    }\n}\n\nclass ClaudeApi extends AbstractLlmApi {\n    constructor(apiKey, model) {\n        super();\n        this.apiKey = apiKey;\n        this.model = model;\n    }\n\n    getDetails() {\n        return {\"type\": \"claude\", \"model\": this.model};\n    }\n\n    async generate() {\n        try {\n            const body = JSON.stringify({\n                model: this.model || \"claude-3-5-sonnet-20241022\",\n                max_tokens: 1024,\n                stream: true,\n                system: [{\n                    type: \"text\",\n                    cache_control: {\"type\": \"ephemeral\"},\n                    text: this.systemPrompt\n                }],\n                messages: this.messages\n            });\n\n            const response = await fetch('https://api.anthropic.com/v1/messages', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'x-api-key': this.apiKey,\n                    'anthropic-version': '2023-06-01',\n                    'anthropic-dangerous-direct-browser-access': 'true'\n                },\n                body\n            });\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(`API error: ${response.status} ${response.statusText}\\nDetails: ${errorText}`);\n            }\n\n            return response.body;\n        } catch (error) {\n            throw new Error(`Failed to generate alternative: ${error.message}`);\n        }\n    }\n\n    extractMessages(line) {\n        if (!line || line.trim() === '') {\n            return '';\n        }\n        //console.log(`Message: ${line}`);\n        const parsedData = JSON.parse(line);\n\n        // We got a valid JSON message, but it might be an error\n        if (parsedData.type === \"error\") {\n            const error = new Error(`Stream error: ${parsedData.error?.type} - ${parsedData.error?.message}`);\n            error.isStreamError = true;\n            error.errorData = parsedData.error;\n            throw error;\n        }\n\n        // We got a valid JSON message and it looks like a delta\n        if (parsedData.delta && parsedData.delta.text) {\n            return parsedData.delta.text;\n        }\n        \n        return '';\n    }\n}\n\nclass OpenAiApi extends AbstractLlmApi {\n    constructor(apiKey, model) {\n        super();\n        this.apiKey = apiKey;\n        this.model = model;\n    }\n\n    getDetails() {\n        return {\"type\": \"openai\", \"model\": this.model};\n    }\n\n    reset() {\n        this.messages = [];\n        if (this.systemPrompt) {\n            this.attachMessage(\"system\", this.systemPrompt);\n        }\n    }\n\n    async generate() {\n        try {\n            const body = JSON.stringify({\n                model: this.model || \"gpt-4-turbo-preview\",\n                messages: this.messages,\n                max_tokens: 1024,\n                temperature: 0.7,\n                stream: true\n            });\n\n            const response = await fetch('https://api.openai.com/v1/chat/completions', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${this.apiKey}`\n                },\n                body\n            });\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(`API error: ${response.status} ${response.statusText}\\nDetails: ${errorText}`);\n            }\n\n            return response.body;\n        } catch (error) {\n            throw new Error(`Failed to generate alternative: ${error.message}`);\n        }\n    }\n\n    extractMessages(line) {\n        const parsedData = JSON.parse(line);\n        const token = parsedData.choices[0].delta.content || '';\n        return token;\n    }\n}\n\nclass CustomBasedOnOpenAiApi extends AbstractLlmApi {\n    constructor(apiKey, model, url) {\n        super();\n        this.apiKey = apiKey;\n        this.model = model;\n        this.url = url.endsWith('/') ? url.slice(0, -1) : url;\n    }\n\n    getDetails() {\n        return {\"type\": \"custom\", \"model\": this.model, \"url\": this.url};\n    }\n\n    reset() {\n        this.messages = [];\n        if (this.systemPrompt) {\n            this.attachMessage(\"system\", this.systemPrompt);\n        }\n    }\n\n    async generate() {\n        const body = JSON.stringify({\n            model: this.model || \"\",\n            messages: this.messages,\n            max_tokens: 1024,\n            temperature: 0.7,\n            stream: true\n        });\n\n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        if (this.apiKey) {\n            headers['Authorization'] = `Bearer ${this.apiKey}`;\n        }\n        let response;\n        const url = `${this.url}/v1/chat/completions`;\n        try {\n            response = await fetch(url, {\n                method: 'POST',\n                headers,\n                body\n            });\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(`API error: ${response.status} ${response.statusText}\\nDetails: ${errorText}`);\n            }\n\n            return response.body;\n        } catch (error) {\n            throw new Error(`Failed to generate alternative: ${error.message}\\nRequest Details: ${JSON.stringify({ url, body, headers, response }, null, 2)}`);\n        }\n    }\n\n    extractMessages(line) {\n        const parsedData = JSON.parse(line);\n        const token = parsedData.choices[0].delta.content || '';\n        return token;\n    }\n}\n\nclass Generator {\n    constructor(api, systemPrompt, promptPrefix, variables) {\n        this.api = api;\n        this.systemPrompt = systemPrompt;\n        this.promptPrefix = promptPrefix;\n        this.variables = variables;\n\n        this.reset();\n    }\n\n    getApiDetails() {\n        return this.api.getDetails();\n    }\n\n    reset() {\n        // Create prompt templates to replace them with information from variables\n        const systemPromptTemplate = new PromptTemplate(this.systemPrompt);\n        const codePromptTemplate = new PromptTemplate(this.promptPrefix);\n\n        // Set current system prompt\n        this.api.setSystemPrompt(systemPromptTemplate.formatWithNamedParams(this.variables));\n\n        // Reset message history, some providers might require to add this to the message list\n        this.api.reset();\n\n        // Attach initial prompt\n        this.api.attachMessageAsUser(codePromptTemplate.formatWithNamedParams(this.variables));\n    }\n\n    attachMessageAsAssistant(text) {\n        this.api.attachMessageAsAssistant(text);\n    }\n\n    attachMessageAsUser(text) {\n        this.api.attachMessageAsUser(text);\n    }\n\n    async generate() {\n        return await this.api.generate();\n    }\n\n    extractMessages(line) {\n        return this.api.extractMessages(line);\n    }\n\n    getMessages() {\n        return this.api.messages.map(el => {\n            let role = el.role;\n            if(el.role === this.api.getUserRole()) {\n                role = \"user\";\n            } else if(el.role === this.api.getAssistantRole()) {\n                role = \"assistant\";\n            }\n            return {\n                role,\n                content: el.content\n            }\n        });\n    }\n\n    restoreMessages(messages) {\n        this.api.messages = messages.map(el => {\n            let role = el.role;\n            if (el.role === \"user\") {\n                role = this.api.getUserRole();\n            } else if (el.role === \"assistant\") {\n                role = this.api.getAssistantRole();\n            }\n            return {\n                role,\n                content: el.content\n            };\n        });\n    }\n\n    getSystemPrompt() {\n        return this.api.getSystemPrompt();\n    }\n}\n\nfunction createGenerator(variables, systemPrompt = \"\", promptPrefix = \"\", options = {}) {\n    const llmType = options.llmType;\n    const llmModel = options.llmModel;\n    const llmApiKey = options.llmApiKey;\n\n    let api;\n    if (llmType === 'claude') {\n        api = new ClaudeApi(llmApiKey, llmModel);\n    } else if (llmType === 'openai') {\n        api = new OpenAiApi(llmApiKey, llmModel);\n    } else if (llmType === 'custom') {\n        const llmUrl = options.llmUrl;\n        api = new CustomBasedOnOpenAiApi(llmApiKey, llmModel, llmUrl);\n    } else {\n        throw new Error(`Unknown LLM type: ${llmType}`);\n    }\n\n    return new Generator(api, systemPrompt, promptPrefix, variables);\n}\n\nasync function handleSse(generator, callback) {\n    const stream = await generator.generate();\n    const reader = stream.getReader();\n    const decoder = new TextDecoder();\n\n    let result = '';\n    let buffer = '';\n    \n    try {\n        reading: while (true) {\n            const { done, value } = await reader.read();\n\n            if (done) {\n                break;\n            }\n\n            // Decodiere den Chunk und füge ihn zum Buffer hinzu\n            buffer += decoder.decode(value, { stream: true });\n\n            let pos;\n            while ((pos = buffer.indexOf('\\n\\n')) >= 0) {\n                const event = buffer.substring(0, pos);\n                buffer = buffer.substring(pos + 2);\n\n                const lines = event.split('\\n');\n                let data = '';\n                \n                for (const line of lines) {\n                    if (line.startsWith('data:')) {\n                        data += line.substring(5).trim();\n                    }\n                }\n\n                if (data === '[DONE]') {\n                    break reading;\n                }\n\n                if (data) {\n                    try {\n                        const token = generator.extractMessages(data);\n                        result += token;\n                        if (callback) {\n                            callback(undefined, token);\n                        }\n                    } catch (error) {\n                        if (error.isStreamError) {\n                            console.error(`Stream error: ${error.message}`);\n                            if (callback) {\n                                callback(JSON.stringify({\n                                    error: true,\n                                    type: error.errorData?.type,\n                                    message: error.errorData?.message\n                                }));\n                            }\n                            break reading;\n                        }\n                        console.error('Failed to parse JSON:', error);\n                    }\n                }\n            }\n        }\n    } catch (error) {\n        console.error('Stream processing error:', error);\n    }\n    \n    return result;\n}\n\n//# sourceURL=webpack://infravis/./src/completion.js?");

/***/ }),

/***/ "./src/data-manager.js":
/*!*****************************!*\
  !*** ./src/data-manager.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataManager: () => (/* binding */ DataManager)\n/* harmony export */ });\n/**\n * Lädt die Systemdaten aus der YAML-Datei\n * @returns {Promise<Object>} Das geparste Datenobjekt\n */\nfunction loadSystemData() {\n    try {\n        // YAML-Datei laden\n        const yamlText = localStorage.getItem('systems_yaml');\n        if (!yamlText) {\n            throw new Error('Konnte Systemdaten nicht aus dem lokalen Speicher laden');\n        }\n\n        // YAML zu JavaScript-Objekt parsen\n        const parsedData = jsyaml.load(yamlText);\n\n        return parsedData;\n    } catch (error) {\n        console.error('Fehler beim Laden der Daten:', error);\n        showNotification('Fehler beim Laden der Daten', 'danger');\n        return {\n            systems: [],\n            dependencies: []\n        };\n    }\n}\n\n/**\n * Speichert die Systemdaten als YAML im lokalen Speicher\n * @param {Object} data - Die zu speichernden Systemdaten\n */\nfunction saveSystemData(data) {\n    try {\n        const yamlText = jsyaml.dump(data);\n        localStorage.setItem('systems_yaml', yamlText);\n        showNotification('Daten erfolgreich gespeichert', 'success');\n    } catch (error) {\n        console.error('Fehler beim Speichern der Daten:', error);\n        showNotification('Fehler beim Speichern der Daten', 'danger');\n    }\n}\n\n\n/**\n * DataManager - Zentrale Klasse zur Verwaltung der Systemdaten\n * Dient als Single Source of Truth für alle anderen Komponenten\n */\nclass DataManager {\n    constructor() {\n        this.data = loadSystemData();\n        this.eventListeners = {\n            'dataChanged': []\n        };\n\n        let saveTimeout = null;\n        this.addEventListener('dataChanged', () => {\n            if (saveTimeout) clearTimeout(saveTimeout);\n            saveTimeout = setTimeout(() => {\n                saveSystemData(this.data);\n                saveTimeout = null;\n            }, 500);\n        });\n    }\n\n    /**\n     * Initialisiert den DataManager mit Daten\n     * @param {Object} data - Die initialien Systemdaten\n     */\n    initialize(data) {\n        if (data && data.systems && data.dependencies) {\n            this.data = data;\n        }\n        this.notifyListeners('dataChanged');\n    }\n\n    /**\n     * Gibt die aktuellen Systemdaten zurück\n     * @returns {Object} Die Systemdaten\n     */\n    getData() {\n        return this.data;\n    }\n\n    /**\n     * Aktualisiert die Systemdaten vollständig\n     * @param {Object} newData - Die neuen Systemdaten\n     */\n    setData(newData, notify = true) {\n        if (newData && newData.systems && newData.dependencies) {\n            this.data = newData;\n            notify && this.notifyListeners('dataChanged');\n        }\n    }\n\n    /**\n     * Gibt alle einzigartigen Gruppen zurück, die in den Systemdaten vorhanden sind\n     * @returns {Array} Array mit einzigartigen Gruppennamen\n     */\n    getAllGroups() {\n        const groups = new Set();\n\n        this.data.systems.forEach(system => {\n            if (Array.isArray(system.groups)) {\n                system.groups.forEach(group => {\n                    if (group && group.trim() !== '') {\n                        groups.add(group);\n                    }\n                });\n            } else if (system.group && typeof system.group === 'string') {\n                groups.add(system.group);\n            }\n        });\n\n        return Array.from(groups).sort();\n    }\n\n    /**\n     * Hilfsfunktion zur Sicherstellung, dass jedes System ein 'groups'-Array hat\n     * Konvertiert einzelne 'group'-Strings in Arrays falls notwendig (Abwärtskompatibilität)\n     * @param {Object} system - Das zu überprüfende System\n     */\n    ensureGroupsArray(system) {\n        // Fall 1: system hat bereits ein groups-Array -> nichts tun\n        if (Array.isArray(system.groups)) {\n            // Entferne leere Werte und doppelte Einträge\n            system.groups = system.groups\n                .filter(group => group && group.trim() !== '')\n                .filter((group, index, self) => self.indexOf(group) === index);\n\n            // Legacy group-Feld entfernen, wenn vorhanden\n            delete system.group;\n            return;\n        }\n\n        // Fall 2: system hat ein group-Feld -> konvertieren zu groups-Array\n        if (typeof system.group === 'string' && system.group.trim() !== '') {\n            // Wenn group ein Komma-separierter String ist, teilen\n            if (system.group.includes(',')) {\n                system.groups = system.group.split(',')\n                    .map(g => g.trim())\n                    .filter(g => g !== '');\n            } else {\n                system.groups = [system.group];\n            }\n            delete system.group;\n            return;\n        }\n\n        // Fall 3: system hat weder group noch groups\n        if (!system.groups) {\n            system.groups = [];\n            delete system.group; // Sicherstellen, dass kein leeres group-Feld existiert\n        }\n    }\n\n    /**\n     * Fügt ein neues System hinzu\n     * @param {Object} system - Das neue System\n     * @returns {string} Die ID des hinzugefügten Systems\n     */\n    addSystem(system, notify = true) {\n        if (!system.id) {\n            system.id = this.generateUniqueId();\n        }\n\n        // Kompatibilitätshandling für die Konvertierung von 'group' zu 'groups'\n        this.ensureGroupsArray(system);\n\n        this.data.systems.push(system);\n        notify && this.notifyListeners('dataChanged');\n        return system.id;\n    }\n\n    /**\n     * Aktualisiert ein bestehendes System\n     * @param {Object} updatedSystem - Das aktualisierte System\n     * @returns {boolean} True, wenn das System gefunden und aktualisiert wurde\n     */\n    updateSystem(updatedSystem, notify = true) {\n        const index = this.data.systems.findIndex(sys => sys.id === updatedSystem.id);\n        if (index !== -1) {\n            // Kompatibilitätshandling für die Konvertierung von 'group' zu 'groups'\n            this.ensureGroupsArray(updatedSystem);\n\n            this.data.systems[index] = updatedSystem;\n            notify && this.notifyListeners('dataChanged');\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Löscht ein System und zugehörige Abhängigkeiten\n     * @param {string} systemId - Die ID des zu löschenden Systems\n     * @returns {boolean} True, wenn das System gefunden und gelöscht wurde\n     */\n    deleteSystem(systemId, notify = true) {\n        const systemIndex = this.data.systems.findIndex(sys => sys.id === systemId);\n        if (systemIndex === -1) return false;\n\n        // System löschen\n        this.data.systems.splice(systemIndex, 1);\n\n        // Zugehörige Abhängigkeiten löschen\n        this.data.dependencies = this.data.dependencies.filter(\n            dep => dep.source !== systemId && dep.target !== systemId\n        );\n\n        notify && this.notifyListeners('dataChanged');\n        return true;\n    }\n\n    /**\n     * Fügt eine neue Abhängigkeit hinzu\n     * @param {Object} dependency - Die neue Abhängigkeit\n     * @returns {boolean} True bei Erfolg\n     */\n    addDependency(dependency, notify = true) {\n        // Prüfen, ob Quell- und Zielsystem existieren\n        const sourceExists = this.data.systems.some(sys => sys.id === dependency.source);\n        const targetExists = this.data.systems.some(sys => sys.id === dependency.target);\n\n        if (!sourceExists || !targetExists) return false;\n\n        this.data.dependencies.push(dependency);\n        notify && this.notifyListeners('dataChanged');\n        return true;\n    }\n\n    /**\n     * Löscht eine Abhängigkeit\n     * @param {Object} dependency - Die zu löschende Abhängigkeit (muss source und target enthalten)\n     * @returns {boolean} True, wenn die Abhängigkeit gefunden und gelöscht wurde\n     */\n    deleteDependency(dependency, notify = true) {\n        const index = this.data.dependencies.findIndex(\n            dep => dep.source === dependency.source && dep.target === dependency.target\n        );\n\n        if (index !== -1) {\n            this.data.dependencies.splice(index, 1);\n            notify && this.notifyListeners('dataChanged');\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Wendet einen Batch von Änderungen auf einmal an und löst nur ein einziges Update-Event aus\n     * @param {Object} differences - Objekt mit added, modified und removed Arrays für systems und dependencies\n     * @returns {boolean} True bei Erfolg\n     */\n    applyBatch(differences) {\n        if (!differences) return false;\n\n        try {\n            // Systeme entfernen\n            if (differences.removed && differences.removed.systems) {\n                differences.removed.systems.forEach(system => {\n                    this.deleteSystem(system.id, false);\n                });\n            }\n\n            // Systeme aktualisieren\n            if (differences.modified && differences.modified.systems) {\n                differences.modified.systems.forEach(modifiedSystem => {\n                    this.updateSystem(modifiedSystem, false);\n                });\n            }\n\n            // Neue Systeme hinzufügen\n            if (differences.added && differences.added.systems) {\n                differences.added.systems.forEach(newSystem => {\n                    this.addSystem(newSystem, false);\n                });\n            }\n\n            // Abhängigkeiten entfernen\n            if (differences.removed && differences.removed.dependencies) {\n                differences.removed.dependencies.forEach(dependency => {\n                    this.deleteDependency(dependency, false);\n                });\n            }\n\n            // Abhängigkeiten aktualisieren\n            if (differences.modified && differences.modified.dependencies) {\n                differences.modified.dependencies.forEach(modifiedDep => {\n                    // Löschen und neu hinzufügen, da updateDependency nicht existiert\n                    this.deleteDependency(modifiedDep, false);\n                    this.addDependency(modifiedDep, false);\n                });\n            }\n\n            // Neue Abhängigkeiten hinzufügen\n            if (differences.added && differences.added.dependencies) {\n                differences.added.dependencies.forEach(newDep => {\n                    this.addDependency(newDep, false);\n                });\n            }\n\n            // Nur einmal alle Listener benachrichtigen\n            this.notifyListeners('dataChanged');\n\n            return true;\n        } catch (error) {\n            console.error(\"Fehler beim Anwenden der Batch-Änderungen:\", error);\n            return false;\n        }\n    }\n\n    /**\n     * Generiert eine eindeutige ID\n     * @returns {string} Eine eindeutige ID\n     */\n    generateUniqueId() {\n        const timestamp = new Date().getTime();\n        const randomPart = Math.floor(Math.random() * 10000);\n        return `sys_${timestamp}_${randomPart}`;\n    }\n\n    /**\n     * Fügt einen Event-Listener hinzu\n     * @param {string} event - Der Event-Name (z.B. 'dataChanged')\n     * @param {Function} callback - Die Callback-Funktion\n     */\n    addEventListener(event, callback) {\n        if (this.eventListeners[event]) {\n            this.eventListeners[event].push(callback);\n        }\n    }\n\n    /**\n     * Benachrichtigt alle Listener über ein Event\n     * @param {string} event - Der Event-Name\n     */\n    notifyListeners(event) {\n        if (this.eventListeners[event]) {\n            this.eventListeners[event].forEach(callback => callback(this.data));\n        }\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/data-manager.js?");

/***/ }),

/***/ "./src/dependency-manager.js":
/*!***********************************!*\
  !*** ./src/dependency-manager.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DependencyManager: () => (/* binding */ DependencyManager)\n/* harmony export */ });\n/**\n * DependencyManager - Verwaltet das Hinzufügen und Löschen von Abhängigkeiten\n */\nclass DependencyManager {\n    constructor() {\n        this.initialized = false;\n        this.isConnectionModeActive = false;\n        this.sourceSystem = null;\n        this.tempLink = null;\n        this.mousePosition = { x: 0, y: 0 };\n        \n        // Standardwerte für neue Verbindungen\n        this.defaultConnectionType = \"data\";\n        this.defaultConnectionProtocol = \"API\";\n    }\n\n    /**\n     * Initialisiert den DependencyManager\n     */\n    initialize(dataManager, visualizer) {\n        if (this.initialized) return;\n        \n        this.dataManager = dataManager;\n        this.visualizer = visualizer;\n        \n        // Event-Listener für Verbindungsmodus-Toggle\n        document.getElementById('toggle-connection-mode').addEventListener('click', () => {\n            this.toggleConnectionMode();\n        });\n        \n        // Event-Listener für Datenänderungen, um den Verbindungsmodus beizubehalten\n        this.dataManager.addEventListener('dataChanged', () => {\n            if (this.isConnectionModeActive) {\n                // Kurze Verzögerung, um die UI-Aktualisierung abzuwarten\n                setTimeout(() => {\n                    this.setupConnectionDrag();\n                }, 100);\n            }\n        });\n        \n        this.initialized = true;\n        console.log('DependencyManager wurde initialisiert');\n    }\n\n    /**\n     * Schaltet den Verbindungsmodus ein/aus\n     */\n    toggleConnectionMode() {\n        this.isConnectionModeActive = !this.isConnectionModeActive;\n        const toggleButton = document.getElementById('toggle-connection-mode');\n        \n        if (this.isConnectionModeActive) {\n            document.body.classList.add('connection-mode');\n            toggleButton.classList.add('active');\n            toggleButton.title = 'Verbindungsmodus verlassen';\n            toggleButton.querySelector('i').className = 'bi bi-link-45deg';\n            \n            // Standarddrag deaktivieren und stattdessen Verbindungsdrag aktivieren\n            this.visualizer.disableDrag(); // Flag setzen\n            this.setupConnectionDrag();\n            \n            showNotification('Verbindungsmodus aktiviert: Ziehen Sie von einem System zum anderen', 'info');\n        } else {\n            document.body.classList.remove('connection-mode');\n            toggleButton.classList.remove('active');\n            toggleButton.title = 'Verbindungsmodus';\n            toggleButton.querySelector('i').className = 'bi bi-link';\n            \n            // Verbindungsdrag entfernen und Standarddrag wiederherstellen\n            this.removeConnectionDrag();\n            this.visualizer.enableDrag(); // Flag zurücksetzen\n            \n            // Aufräumen\n            this.resetConnectionState();\n            \n            showNotification('Verbindungsmodus deaktiviert', 'info');\n        }\n    }\n\n    /**\n     * Richtet den Drag-Mechanismus für Verbindungen ein\n     */\n    setupConnectionDrag() {\n        if (!this.visualizer.nodeElements) return;\n        \n        // Verbindungs-Drag entfernen (falls vorhanden)\n        this.removeConnectionDrag();\n        \n        // Drag-Funktion für Verbindungen definieren\n        const connectionDrag = d3.drag()\n            .on(\"start\", (event, d) => this.handleDragStart(event, d))\n            .on(\"drag\", (event, d) => this.handleDragMove(event, d))\n            .on(\"end\", (event, d) => this.handleDragEnd(event, d));\n        \n        // Auf Knoten anwenden\n        this.visualizer.nodeElements.call(connectionDrag);\n    }\n    \n    /**\n     * Entfernt den Verbindungs-Drag-Mechanismus\n     */\n    removeConnectionDrag() {\n        if (!this.visualizer.nodeElements) return;\n        \n        // Verbindungs-Drag entfernen\n        this.visualizer.nodeElements.on('.drag', null);\n    }\n\n    /**\n     * Behandelt den Start eines Verbindungsdrags\n     */\n    handleDragStart(event, d) {\n        if (!this.isConnectionModeActive) return;\n        \n        // Quellsystem festlegen\n        this.sourceSystem = d;\n        \n        // Visuell markieren\n        d3.select(event.sourceEvent.target.closest('.node')).classed('connection-source', true);\n        \n        // Temporäre Verbindungslinie erstellen\n        this.createTempLink(d);\n    }\n\n    /**\n     * Behandelt die Bewegung während eines Verbindungsdrags\n     */\n    handleDragMove(event, d) {\n        if (!this.isConnectionModeActive || !this.tempLink) return;\n        \n        // Temporäre Linie aktualisieren\n        this.tempLink.attr('d', `M${this.sourceSystem.x},${this.sourceSystem.y} L${event.x},${event.y}`);\n    }\n\n    /**\n     * Behandelt das Ende eines Verbindungsdrags\n     */\n    handleDragEnd(event, d) {\n        if (!this.isConnectionModeActive || !this.sourceSystem) return;\n        \n        // Prüfen, ob über einem anderen Knoten losgelassen wurde\n        const targetElement = document.elementFromPoint(event.sourceEvent.clientX, event.sourceEvent.clientY);\n        const targetNode = targetElement ? targetElement.closest('.node') : null;\n        \n        if (targetNode) {\n            const targetSystemId = targetNode.getAttribute('data-system-id');\n            const targetSystem = this.dataManager.getData().systems.find(sys => sys.id === targetSystemId);\n            \n            if (targetSystem && targetSystem.id !== this.sourceSystem.id) {\n                // Verbindung erstellen mit Standardwerten\n                this.createConnection(this.sourceSystem, targetSystem);\n            } else if (targetSystem && targetSystem.id === this.sourceSystem.id) {\n                // Gleicher Knoten wurde als Ziel verwendet\n                showNotification('Quell- und Zielsystem können nicht identisch sein.', 'warning');\n            }\n        }\n        \n        // Aufräumen\n        this.resetConnectionState();\n    }\n\n    /**\n     * Erstellt eine temporäre Verbindungslinie vom Quellsystem\n     */\n    createTempLink(sourceSystem) {\n        // Temporäre Linie erstellen\n        this.tempLink = this.visualizer.svg.select('g').append('path')\n            .attr('class', 'temp-link')\n            .attr('d', `M${sourceSystem.x},${sourceSystem.y} L${sourceSystem.x},${sourceSystem.y}`);\n    }\n\n    /**\n     * Erstellt eine neue Verbindung mit Standardwerten\n     */\n    createConnection(sourceSystem, targetSystem) {\n        // Neue Abhängigkeit mit Standardwerten erstellen\n        const newDependency = {\n            source: sourceSystem.id,\n            target: targetSystem.id,\n            type: this.defaultConnectionType,\n            description: `Verbindung von ${sourceSystem.name} zu ${targetSystem.name}`,\n            protocol: this.defaultConnectionProtocol\n        };\n        \n        // Abhängigkeit über den DataManager hinzufügen\n        const success = this.dataManager.addDependency(newDependency);\n        \n        if (success) {\n            // Erfolgsmeldung\n            showNotification(\n                `Verbindung von \"${sourceSystem.name}\" zu \"${targetSystem.name}\" wurde erstellt`,\n                'success'\n            );\n        } else {\n            showNotification('Fehler beim Erstellen der Verbindung', 'danger');\n        }\n    }\n\n    /**\n     * Setzt den Verbindungsstatus zurück\n     */\n    resetConnectionState() {\n        // Quellsystem zurücksetzen\n        if (this.sourceSystem) {\n            d3.selectAll('.node').classed('connection-source', false);\n            this.sourceSystem = null;\n        }\n        \n        // Temporäre Linie entfernen\n        if (this.tempLink) {\n            this.tempLink.remove();\n            this.tempLink = null;\n        }\n    }\n\n    /**\n     * Zeigt die Lösch-Kontrolle für eine Verbindung an\n     */\n    showLinkControls(event, linkData) {\n        // Im Verbindungsmodus keine Controls anzeigen\n        if (this.isConnectionModeActive) return;\n        \n        // Bestehende Controls entfernen\n        this.hideLinkControls();\n        \n        // Neue Controls erstellen\n        const controls = document.createElement('div');\n        controls.className = 'link-controls';\n        controls.innerHTML = `\n            <button class=\"link-delete-btn\" title=\"Verbindung löschen\">\n                <i class=\"bi bi-trash\"></i>\n            </button>\n        `;\n        \n        // Position setzen\n        controls.style.left = `${event.pageX}px`;\n        controls.style.top = `${event.pageY}px`;\n        \n        // Zum DOM hinzufügen\n        document.body.appendChild(controls);\n        \n        // Link-Daten in ein Attribut speichern\n        controls.setAttribute('data-source', linkData.source.id || linkData.source);\n        controls.setAttribute('data-target', linkData.target.id || linkData.target);\n        \n        // Event-Listener für Löschen-Button\n        controls.querySelector('.link-delete-btn').addEventListener('click', () => {\n            this.showDeleteDependencyConfirmation(linkData);\n            this.hideLinkControls();\n        });\n        \n        // Controls anzeigen\n        controls.style.display = 'block';\n        \n        // Außerhalb klicken, um zu schließen\n        document.addEventListener('click', (e) => {\n            if (!controls.contains(e.target) && e.target !== event.target) {\n                this.hideLinkControls();\n            }\n        }, { once: true });\n    }\n\n    /**\n     * Blendet die Link-Controls aus\n     */\n    hideLinkControls() {\n        const existingControls = document.querySelector('.link-controls');\n        if (existingControls) {\n            existingControls.remove();\n        }\n    }\n\n    /**\n     * Zeigt eine Bestätigungsaufforderung zum Löschen einer Abhängigkeit an\n     */\n    showDeleteDependencyConfirmation(linkData) {\n        const sourceId = linkData.source.id || linkData.source;\n        const targetId = linkData.target.id || linkData.target;\n        \n        const sourceSystem = this.dataManager.getData().systems.find(sys => sys.id === sourceId);\n        const targetSystem = this.dataManager.getData().systems.find(sys => sys.id === targetId);\n        \n        if (!sourceSystem || !targetSystem) return;\n        \n        // Bestätigungsnachricht\n        const message = `Möchten Sie die Verbindung von \"${sourceSystem.name}\" zu \"${targetSystem.name}\" wirklich löschen?`;\n        \n        document.getElementById('confirm-message').innerHTML = message;\n        document.getElementById('confirm-action').setAttribute('data-action', 'delete-dependency');\n        document.getElementById('confirm-action').setAttribute('data-source', sourceId);\n        document.getElementById('confirm-action').setAttribute('data-target', targetId);\n        \n        // Modal anzeigen\n        const modal = new bootstrap.Modal(document.getElementById('confirm-modal'));\n        modal.show();\n    }\n\n    /**\n     * Löscht eine Abhängigkeit\n     */\n    deleteDependency(sourceId, targetId) {\n        // Systeme finden für die Benachrichtigung\n        const sourceSystem = this.dataManager.getData().systems.find(sys => sys.id === sourceId);\n        const targetSystem = this.dataManager.getData().systems.find(sys => sys.id === targetId);\n        \n        if (!sourceSystem || !targetSystem) return;\n        \n        // Abhängigkeit über den DataManager löschen\n        const success = this.dataManager.deleteDependency({\n            source: sourceId,\n            target: targetId\n        });\n        \n        if (success) {\n            showNotification(\n                `Verbindung von \"${sourceSystem.name}\" zu \"${targetSystem.name}\" wurde gelöscht`,\n                'success'\n            );\n        } else {\n            showNotification('Fehler beim Löschen der Verbindung', 'danger');\n        }\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/dependency-manager.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _data_manager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data-manager.js */ \"./src/data-manager.js\");\n/* harmony import */ var _visualizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./visualizer.js */ \"./src/visualizer.js\");\n/* harmony import */ var _dependency_manager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dependency-manager.js */ \"./src/dependency-manager.js\");\n/* harmony import */ var _system_manager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./system-manager.js */ \"./src/system-manager.js\");\n/* harmony import */ var _llm_integration_manager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./llm-integration-manager.js */ \"./src/llm-integration-manager.js\");\n\n\n\n\n\n\nwindow.DataManager = _data_manager_js__WEBPACK_IMPORTED_MODULE_0__.DataManager;\nwindow.SystemVisualizer = _visualizer_js__WEBPACK_IMPORTED_MODULE_1__.SystemVisualizer;\nwindow.DependencyManager = _dependency_manager_js__WEBPACK_IMPORTED_MODULE_2__.DependencyManager;\nwindow.SystemManager = _system_manager_js__WEBPACK_IMPORTED_MODULE_3__.SystemManager;\nwindow.LlmIntegrationManager = _llm_integration_manager_js__WEBPACK_IMPORTED_MODULE_4__.LlmIntegrationManager;\n\n\n//# sourceURL=webpack://infravis/./src/index.js?");

/***/ }),

/***/ "./src/llm-integration-manager.js":
/*!****************************************!*\
  !*** ./src/llm-integration-manager.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LlmIntegrationManager: () => (/* binding */ LlmIntegrationManager)\n/* harmony export */ });\n/* harmony import */ var _completion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./completion.js */ \"./src/completion.js\");\n\n\n/**\n * LlmIntegrationManager - Verwaltet die Integration eines LLM in die Systemvisualisierung\n * Konzentriert sich auf die Kernfunktionalität der LLM-Kommunikation und Datenmodell-Updates\n */\nclass LlmIntegrationManager {\n    constructor(options = {}) {\n        this.dataManager = null;\n        this.generator = null;\n        this.initialized = false;\n        this.isProcessing = false;\n\n        // Konfiguration mit Standardwerten\n        this.config = {\n            apiKey: options.apiKey || \"\",\n            llmType: options.llmType || \"claude\", // claude, openai, custom\n            llmModel: options.llmModel || \"claude-3-7-sonnet-20250219\",\n            llmUrl: options.llmUrl || \"\", // Nur für custom notwendig\n            systemPrompt: options.systemPrompt || this.getDefaultSystemPrompt(),\n            promptPrefix: options.promptPrefix || \"\",\n            onMessageReceived: options.onMessageReceived || null,\n            onTyping: options.onTyping || null\n        };\n    }\n\n    /**\n     * Initialisiert den LlmIntegrationManager\n     * @param {DataManager} dataManager - Der DataManager für die Datenverwaltung\n     */\n    initialize(dataManager) {\n        if (this.initialized) return;\n\n        if (!dataManager) {\n            console.error(\"Kein DataManager bereitgestellt\");\n            return;\n        }\n\n        this.dataManager = dataManager;\n\n        // LLM-Generator erstellen\n        this.createLlmGenerator();\n\n        this.initialized = true;\n        console.log(\"LlmIntegrationManager wurde initialisiert\");\n    }\n\n    /**\n     * Erstellt den LLM-Generator basierend auf der Konfiguration\n     */\n    createLlmGenerator() {\n        const variables = {\n            currentData: JSON.stringify(this.dataManager.getData())\n        };\n\n        // Generator mit der createGenerator-Funktion erstellen\n        this.generator = (0,_completion_js__WEBPACK_IMPORTED_MODULE_0__.createGenerator)(\n            variables,\n            this.config.systemPrompt,\n            this.config.promptPrefix,\n            {\n                llmType: this.config.llmType,\n                llmModel: this.config.llmModel,\n                llmApiKey: this.config.apiKey,\n                llmUrl: this.config.llmUrl\n            }\n        );\n\n        if (!this.generator) {\n            console.error(\"Fehler beim Erstellen des LLM-Generators\");\n            showNotification(\"LLM-Integration konnte nicht initialisiert werden\", \"danger\");\n        }\n    }\n\n    /**\n     * Verarbeitet eine Benutzeranfrage und sendet sie an das LLM\n     * @param {string} userInput - Die Benutzereingabe\n     * @returns {Promise<Object>} - Verarbeitungsergebnis mit Antwort und Datenänderungen\n     */\n    async processUserInput(userInput, callback) {\n        if (!userInput || !this.generator || this.isProcessing) {\n            return { success: false, message: \"Eingabe kann nicht verarbeitet werden\" };\n        }\n\n        this.isProcessing = true;\n        let result = {\n            success: false,\n            message: \"\",\n            originalResponse: \"\",\n            yamlData: null,\n            differences: null\n        };\n\n        try {\n            // Aktuelle Daten vorbereiten\n            const currentData = this.dataManager.getData();\n            const messageWithContext = this.createContextMessage(currentData, userInput);\n\n            // Nachricht an das LLM senden\n            this.generator.attachMessageAsUser(messageWithContext);\n\n            // Stream-Antwort verarbeiten\n            const response = await (0,_completion_js__WEBPACK_IMPORTED_MODULE_0__.handleSse)(\n                this.generator,\n                (error, token) => {\n                    if (error) {\n                        console.error(\"Stream-Fehler:\", error);\n                        return;\n                    }\n\n                    // Token an Handler übergeben, falls definiert\n                    if (this.config.onTyping && token) {\n                        this.config.onTyping(token);\n                    }\n                    if (callback && token) {\n                        callback(token);\n                    }\n                }\n            );\n\n            // Vollständige Antwort speichern\n            result.originalResponse = response;\n\n            // Antwort parsen und YAML extrahieren\n            const yamlContent = this.extractYamlFromResponse(response);\n\n            if (yamlContent) {\n                try {\n                    // YAML parsen\n                    const parsedData = jsyaml.load(yamlContent);\n\n                    // Daten validieren\n                    if (this.validateSystemData(parsedData)) {\n                        result.yamlData = parsedData;\n\n                        // Unterschiede berechnen\n                        result.differences = this.calculateDifferences(currentData, parsedData);\n                        result.success = true;\n                    } else {\n                        result.message = \"Die YAML-Struktur ist ungültig\";\n                    }\n                } catch (error) {\n                    console.error(\"Fehler beim Parsen der YAML-Antwort:\", error);\n                    result.message = \"Die YAML-Antwort konnte nicht verarbeitet werden\";\n                }\n            } else {\n                // Normale Konversation ohne YAML-Änderungen\n                result.success = true;\n                result.message = \"Keine Infrastrukturänderungen erkannt\";\n            }\n\n            // Falls ein Callback für empfangene Nachrichten definiert ist, diesen aufrufen\n            if (this.config.onMessageReceived) {\n                this.config.onMessageReceived(result);\n            }\n\n            return result;\n\n        } catch (error) {\n            console.error(\"Fehler bei der LLM-Verarbeitung:\", error);\n            result.message = \"Es ist ein Fehler bei der Verarbeitung aufgetreten\";\n            return result;\n        } finally {\n            this.isProcessing = false;\n        }\n    }\n\n    /**\n     * Erstellt eine kontextualisierte Nachricht mit den aktuellen Daten\n     * @param {Object} currentData - Aktuelle Infrastrukturdaten\n     * @param {string} userInput - Die Benutzereingabe\n     * @returns {string} - Die formatierte Nachricht mit Kontext\n     */\n    createContextMessage(currentData, userInput) {\n        return `\nHier ist die aktuelle YAML-Darstellung der Infrastruktur:\n\n\\`\\`\\`yaml\nsystems:\n${currentData.systems.map(sys => `  - id: ${sys.id}\n    name: ${sys.name}\n    description: ${sys.description}\n    category: ${sys.category}${this.formatGroups(sys)}\n    status: ${sys.status}\n    knownUsage: ${sys.knownUsage}${sys.tags && sys.tags.length > 0 ? `\\n    tags:\\n${sys.tags.map(tag => `      - ${tag}`).join('\\n')}` : ''}\n`).join('\\n')}\n\ndependencies:\n${currentData.dependencies.map(dep => `  - source: ${dep.source}\n    target: ${dep.target}\n    type: ${dep.type}\n    description: ${dep.description || 'Keine Beschreibung'}\n    protocol: ${dep.protocol || 'Unbekannt'}\n`).join('\\n')}\n\\`\\`\\`\n\nBenutzeranfrage:\n${userInput}\n\nWenn du Änderungen an der Infrastruktur vornehmen sollst, gib die neuen, aktualisierten oder zu löschenden Elemente in YAML im folgenden Format zurück:\n\n\\`\\`\\`yaml\nsystems:\n  - id: system1\n    name: System Name\n    description: Beschreibung\n    category: category\n    groups:\n      - group1\n      - group2\n    status: status\n    delete: true/false\n    knownUsage: true/false\n    # Weitere Eigenschaften...\n\ndependencies:\n  - source: system1\n    target: system2\n    type: type\n    description: Beschreibung\n    delete: true/false\n    protocol: Protokoll\n\\`\\`\\`\n\nWenn keine Änderungen erforderlich sind, antworte mit normaler Konversation. Gib YAML nur zurück, wenn Infrastrukturänderungen angefordert wurden.\n`;\n    }\n\n    /**\n     * Hilfsfunktion zum Formatieren der Gruppen-Information für die YAML-Darstellung\n     * @param {Object} system - Das System-Objekt\n     * @returns {string} - Formatierte Gruppen-Information\n     */\n    formatGroups(system) {\n        let groupsText = '';\n\n        // Fall 1: system hat ein groups-Array mit Einträgen\n        if (Array.isArray(system.groups) && system.groups.length > 0) {\n            groupsText = '\\n    groups:';\n            system.groups.forEach(group => {\n                groupsText += `\\n      - ${group}`;\n            });\n        }\n        // Fall 2: Legacy-Fall mit einfachem group-Feld\n        else if (system.group && typeof system.group === 'string') {\n            groupsText = `\\n    group: ${system.group}`;\n        }\n\n        return groupsText;\n    }\n\n    /**\n     * Wendet Datenänderungen auf das Datenmodell an\n     * @param {Object} differences - Die geänderten Daten\n     * @returns {boolean} - True bei Erfolg\n     */\n    applyChanges(differences) {\n        try {\n            // Daten im DataManager aktualisieren\n            this.dataManager.applyBatch(differences);\n            showNotification(\"Die Änderungen wurden erfolgreich angewendet\", \"success\");\n            return true;\n        } catch (error) {\n            console.error(\"Fehler beim Anwenden der Änderungen:\", error);\n            showNotification(\"Fehler beim Anwenden der Änderungen\", \"danger\");\n            return false;\n        }\n    }\n\n    /**\n     * Berechnet die Unterschiede zwischen zwei Datenmodellen\n     * @param {Object} currentData - Aktuelle Daten\n     * @param {Object} newData - Neue Daten\n     * @returns {Object} Unterschiede (hinzugefügt, geändert, entfernt)\n     */\n    calculateDifferences(currentData, newData) {\n        const differences = {\n            added: {\n                systems: [],\n                dependencies: []\n            },\n            modified: {\n                systems: [],\n                dependencies: []\n            },\n            removed: {\n                systems: [],\n                dependencies: []\n            }\n        };\n\n        // Systeme vergleichen\n        const currentSystemIds = new Set(currentData.systems.map(s => s.id));\n\n        // Hinzugefügte Systeme\n        newData.systems.forEach(newSystem => {\n            // Gelöschte Systeme\n            if (newSystem.delete) {\n                differences.removed.systems.push(newSystem);\n                return;\n            }\n            if (!currentSystemIds.has(newSystem.id)) {\n                differences.added.systems.push(newSystem);\n            } else {\n                // Geänderte Systeme\n                const currentSystem = currentData.systems.find(s => s.id === newSystem.id);\n                if (!this.areSystemsEqual(currentSystem, newSystem)) {\n                    differences.modified.systems.push(newSystem);\n                }\n            }\n        });\n\n        // Abhängigkeiten vergleichen\n        const currentDepKeys = new Set(currentData.dependencies.map(d => `${d.source}-${d.target}`));\n\n        // Hinzugefügte Abhängigkeiten\n        newData.dependencies.forEach(newDep => {\n            if (newDep.delete) {\n                differences.removed.dependencies.push(newDep);\n                return;\n            }\n            const key = `${newDep.source}-${newDep.target}`;\n            if (!currentDepKeys.has(key)) {\n                differences.added.dependencies.push(newDep);\n            } else {\n                // Geänderte Abhängigkeiten\n                const currentDep = currentData.dependencies.find(d =>\n                    d.source === newDep.source && d.target === newDep.target);\n                if (!this.areDependenciesEqual(currentDep, newDep)) {\n                    differences.modified.dependencies.push(newDep);\n                }\n            }\n        });\n\n        return differences;\n    }\n\n    /**\n     * Vergleicht zwei Systeme auf Gleichheit, angepasst für Multi-Gruppen\n     * @param {Object} system1 - Erstes System\n     * @param {Object} system2 - Zweites System\n     * @returns {boolean} True, wenn die Systeme gleich sind\n     */\n    areSystemsEqual(system1, system2) {\n        if (!system1 || !system2) return false;\n\n        // Vergleich der Haupteigenschaften\n        if (system1.name !== system2.name ||\n            system1.description !== system2.description ||\n            system1.category !== system2.category ||\n            system1.status !== system2.status ||\n            system1.knownUsage !== system2.knownUsage) {\n            return false;\n        }\n\n        // Gruppen vergleichen\n        const groups1 = this.getSystemGroups(system1);\n        const groups2 = this.getSystemGroups(system2);\n\n        if (groups1.length !== groups2.length) {\n            return false;\n        }\n\n        // Prüfen, ob alle Gruppen übereinstimmen (Reihenfolge unwichtig)\n        for (const group of groups1) {\n            if (!groups2.includes(group)) {\n                return false;\n            }\n        }\n\n        // Tags vergleichen (falls vorhanden)\n        if (Array.isArray(system1.tags) && Array.isArray(system2.tags)) {\n            if (system1.tags.length !== system2.tags.length) {\n                return false;\n            }\n\n            for (let i = 0; i < system1.tags.length; i++) {\n                if (!system2.tags.includes(system1.tags[i])) {\n                    return false;\n                }\n            }\n        } else if ((system1.tags && !system2.tags) || (!system1.tags && system2.tags)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Hilfsfunktion zum Extrahieren aller Gruppen eines Systems\n     * @param {Object} system - Das System-Objekt\n     * @returns {Array} Array mit allen Gruppennamen\n     */\n    getSystemGroups(system) {\n        let groups = [];\n\n        if (Array.isArray(system.groups) && system.groups.length > 0) {\n            groups = [...system.groups];\n        } else if (system.group && typeof system.group === 'string') {\n            groups = [system.group];\n        }\n\n        return groups;\n    }\n\n    /**\n     * Vergleicht zwei Abhängigkeiten auf Gleichheit\n     * @param {Object} dep1 - Erste Abhängigkeit\n     * @param {Object} dep2 - Zweite Abhängigkeit\n     * @returns {boolean} True, wenn die Abhängigkeiten gleich sind\n     */\n    areDependenciesEqual(dep1, dep2) {\n        if (!dep1 || !dep2) return false;\n\n        return dep1.type === dep2.type &&\n            dep1.description === dep2.description &&\n            dep1.protocol === dep2.protocol;\n    }\n\n    /**\n     * Validiert die Datenstruktur\n     * @param {Object} data - Die zu validierende Datenstruktur\n     * @returns {boolean} True, wenn die Daten valide sind\n     */\n    validateSystemData(data) {\n        // Überprüfe, ob die Grundstruktur vorhanden ist\n        if (!data || (!Array.isArray(data.systems) && !Array.isArray(data.dependencies))) {\n            return false;\n        }\n\n        data.systems = data.systems || [];\n        data.dependencies = data.dependencies || [];\n\n        // Überprüfe, ob alle Systeme eine ID haben\n        const allSystemsHaveId = data.systems.every(system => !!system.id);\n        if (!allSystemsHaveId) {\n            return false;\n        }\n\n        // Überprüfe, ob alle Abhängigkeiten gültige source und target haben\n        const currentData = this.dataManager.getData();\n        const allDependenciesValid = data.dependencies.every(dep =>\n            !!dep.source && !!dep.target &&\n            (data.systems.some(sys => sys.id === dep.source) || currentData.systems.some(sys => sys.id === dep.source)) &&\n            (data.systems.some(sys => sys.id === dep.target) || currentData.systems.some(sys => sys.id === dep.target))\n        );\n\n        return allDependenciesValid;\n    }\n\n    /**\n     * Extrahiert YAML-Inhalt aus einer LLM-Antwort\n     * @param {string} response - Die LLM-Antwort\n     * @returns {string|null} Der extrahierte YAML-Inhalt oder null\n     */\n    extractYamlFromResponse(response) {\n        // Suche nach YAML-Blöcken in der Antwort (mit Markdown-Code-Block)\n        const yamlRegex = /```(?:yaml)?\\s*([\\s\\S]*?)\\s*```/i;\n        const match = response.match(yamlRegex);\n\n        if (match && match[1]) {\n            return match[1].trim();\n        }\n\n        return null;\n    }\n\n    /**\n     * Gibt den Standard-Systemprompt zurück\n     * @returns {string} Der Standard-Systemprompt\n     */\n    getDefaultSystemPrompt() {\n        return `Du bist ein Infrastruktur-Assistent, der dabei hilft, IT-Systeme und deren Abhängigkeiten zu verwalten. IT-Systeme bestehen aus id, name, description, category, status, knownUsage, groups (array, optional) und tags (array, optional). Abhängigkeiten zwischen Systemen haben die Attribute source, target, type, description und protocol. Du analysierst Benutzeranfragen und wandelst sie in strukturierte YAML-Definitionen um.\n\nAkzeptable Kategorien (category) für Systeme sind:\n- core: Zentrale Systeme\n- legacy: Veraltete Systeme\n- data: Datenspeicher und -verarbeitung\n- service: Dienste und Anwendungen\n- external: Externe Systeme\n\nVerbindungstypen (type) zwischen Systemen können sein:\n- data: Datenaustausch\n- integration: Systemintegration\n- authentication: Authentifizierung\n- monitoring: Überwachung\n\nStatus-Werte (status) für Systeme:\n- active: Aktiv im Einsatz\n- planned: Geplant\n- deprecated: Veraltet\n- retired: Außer Betrieb\n\nWenn der Benutzer dich bittet, die Infrastruktur zu ändern (z.B. Systeme hinzuzufügen, zu bearbeiten oder zu löschen), \nantworte mit den neuen, geänderten und gelöschten Elementen in der YAML-Struktur. Gelöschte Elemente werden mit dem Attribut \\`delete: true\\` markiert. \nFüge keine Erklärungen innerhalb des YAML-Blocks hinzu.\n\nHalte dich an dieses Format:\n\n\\`\\`\\`yaml\nsystems:\n  - id: systemId\n    name: System Name\n    description: Beschreibung\n    category: kategorie\n    groups:\n      - gruppe1\n      - gruppe2\n    status: status\n    knownUsage: true/false\n    delete: true/false\n    tags:\n      - tag1\n      - tag2\n\ndependencies:\n  - source: quellSystemId\n    target: zielSystemId\n    type: verbindungstyp\n    description: Beschreibung der Verbindung\n    delete: true/false\n    protocol: Verwendetes Protokoll\n\\`\\`\\`\n\nWenn du nach allgemeinen Informationen über die Infrastrukturvisualisierung gefragt wirst, \nantworte mit hilfreichen Erklärungen, ohne YAML zurückzugeben.`;\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/llm-integration-manager.js?");

/***/ }),

/***/ "./src/node-cache.js":
/*!***************************!*\
  !*** ./src/node-cache.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NodeCache: () => (/* binding */ NodeCache)\n/* harmony export */ });\n/**\n * NodeCache - Verwaltet die Persistenz von Knotenpositionen im Diagramm\n * Speichert kontinuierlich die Positionen und kann diese aus verschiedenen Quellen laden\n */\nclass NodeCache {\n    constructor(options = {}) {\n        this.positions = new Map();\n        this.options = {\n            useLocalStorage: options.useLocalStorage || false,\n            localStorageKey: options.localStorageKey || 'system_visualizer_node_positions',\n            debounceTime: options.debounceTime || 500, // ms zwischen lokalem Speichern\n            persistGroups: options.persistGroups || true\n        };\n\n        // Debounce-Timer für LocalStorage-Updates\n        this.saveTimer = null;\n\n        // Beim Initialisieren aus dem LocalStorage laden\n        if (this.options.useLocalStorage) {\n            this.loadFromLocalStorage();\n        }\n    }\n\n    /**\n     * Speichert die Position eines Knotens\n     * @param {string} id - Die ID des Knotens\n     * @param {Object} position - Die Position {x, y, vx, vy} und optional weitere Eigenschaften\n     */\n    set(id, position) {\n        if (!id) return;\n\n        // Aktuelle Position setzen\n        this.positions.set(id, {\n            x: position.x,\n            y: position.y,\n            vx: position.vx || 0,\n            vy: position.vy || 0,\n            // Optional weitere Metadaten\n            lastUpdated: Date.now(),\n            isFixed: position.isFixed || false,\n        });\n\n        this.saveToLocalStorage();\n    }\n\n    /**\n     * Aktualisiert mehrere Knoten auf einmal\n     * @param {Array} nodes - Array von Knoten mit id und Positionsdaten\n     */\n    updateBatch(nodes) {\n        if (!Array.isArray(nodes)) return;\n\n        let updated = false;\n        nodes.forEach(node => {\n            if (node.id && (node.x !== undefined && node.y !== undefined)) {\n                this.positions.set(node.id, {\n                    x: node.x,\n                    y: node.y,\n                    vx: node.vx || 0,\n                    vy: node.vy || 0,\n                    lastUpdated: Date.now(),\n                    isFixed: node.isFixed || false,\n                });\n                updated = true;\n            }\n        });\n\n        if (updated) {\n            this.saveToLocalStorage();\n        }\n    }\n\n    /**\n     * Holt die gespeicherte Position eines Knotens\n     * @param {string} id - Die ID des Knotens\n     * @returns {Object|null} Die gespeicherte Position oder null\n     */\n    get(id) {\n        return this.positions.get(id) || null;\n    }\n\n    /**\n     * Prüft, ob eine Position für einen Knoten existiert\n     * @param {string} id - Die ID des Knotens\n     * @returns {boolean} True, wenn Position existiert\n     */\n    has(id) {\n        return this.positions.has(id);\n    }\n\n    /**\n     * Entfernt einen Eintrag aus dem Cache\n     * @param {string} id - Die ID des Knotens\n     */\n    remove(id) {\n        this.positions.delete(id);\n        this.saveToLocalStorage();\n    }\n\n    saveToLocalStorage() {\n        if (this.options.useLocalStorage) {\n            clearTimeout(this.saveTimer);\n            this.saveTimer = setTimeout(() => {\n                this.doSaveToLocalStorage();\n            }, this.options.debounceTime);\n        }\n    }\n\n    /**\n     * In den LocalStorage speichern\n     */\n    doSaveToLocalStorage() {\n        if (!this.options.useLocalStorage) return;\n\n        try {\n            // Umwandeln der Map in ein Array von [id, data] Paaren\n            const positionsArray = Array.from(this.positions);\n            localStorage.setItem(\n                this.options.localStorageKey,\n                JSON.stringify(positionsArray)\n            );\n        } catch (error) {\n            console.warn('Fehler beim Speichern der Positionen:', error);\n        }\n    }\n\n    /**\n     * Aus dem LocalStorage laden\n     */\n    loadFromLocalStorage() {\n        if (!this.options.useLocalStorage) return;\n\n        try {\n            const stored = localStorage.getItem(this.options.localStorageKey);\n            if (stored) {\n                // Array von [id, data] Paaren zurück in Map umwandeln\n                const positionsArray = JSON.parse(stored);\n                this.positions = new Map(positionsArray);\n            }\n        } catch (error) {\n            console.warn('Fehler beim Laden der Positionen:', error);\n        }\n    }\n\n    /**\n     * Cache leeren\n     * @param {boolean} alsoLocalStorage - Wenn true, auch den LocalStorage leeren\n     */\n    clear(alsoLocalStorage = false) {\n        this.positions.clear();\n\n        if (alsoLocalStorage && this.options.useLocalStorage) {\n            localStorage.removeItem(this.options.localStorageKey);\n        }\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/node-cache.js?");

/***/ }),

/***/ "./src/simulation.js":
/*!***************************!*\
  !*** ./src/simulation.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SimulationManager: () => (/* binding */ SimulationManager)\n/* harmony export */ });\n/**\n * SimulationManager - Handles d3 force simulation logic separate from visualization\n */\nclass SimulationManager {\n    constructor(options = {}) {\n        this.options = {\n            linkDistance: options.linkDistance || 150,\n            chargeStrength: options.chargeStrength || -300,\n            collisionRadius: options.collisionRadius || 60,\n            groupForceStrength: options.groupForceStrength || 0.5,\n            ...options\n        };\n\n        this.simulation = null;\n        this.nodeCache = options.nodeCache || null;\n        this.width = options.width || 800;\n        this.height = options.height || 600;\n\n        // For throttling cache updates\n        this.lastCacheUpdate = 0;\n        this.cacheUpdateInterval = options.cacheUpdateInterval || 300;\n\n        // Callbacks\n        this.onTick = options.onTick || (() => { });\n        this.onEnd = options.onEnd || (() => { });\n        this.onToggleFixed = options.onToggleFixed || (() => { });\n    }\n\n    /**\n     * Gibt den Knoten mit der angegebenen ID aus der aktuellen Simulation zurück\n     * @param {string} systemId - Die ID des zu findenden Systems\n     * @returns {Object|null} Das Knotenobjekt oder null, wenn nicht gefunden\n     */\n    getNodeById(systemId) {\n        return this.simulation.nodes().find(node => node.id === systemId);\n    }\n\n    /**\n     * Prüft, ob ein Knoten fixiert ist\n     * @param {string} systemId - Die ID des zu prüfenden Systems\n     * @returns {boolean} True, wenn der Knoten fixiert ist, false sonst oder wenn nicht gefunden\n     */\n    isNodeFixed(systemId, curNode = undefined) {\n        const node = curNode || this.getNodeById(systemId);\n        return node ? !!node.isFixed : false;\n    }\n\n    toggleNodeFixed(systemId) {\n        const node = this.getNodeById(systemId);\n        if (!node) return null;\n        const isFixed = this.isNodeFixed(systemId, node);\n        const newState = !isFixed;\n        this.setNodeFixed(systemId, newState, node);\n    }\n\n    setNodeFixed(systemId, state, curNode = undefined) {\n        const node = curNode || this.getNodeById(systemId);\n        if (!node) return null;\n\n        if (!state) {\n            // Fixierung aufheben\n            node.isFixed = false;\n            node.fx = null;\n            node.fy = null;\n        } else {\n            // Knoten an aktueller Position fixieren\n            node.isFixed = true;\n            node.fx = node.x;\n            node.fy = node.y;\n        }\n\n        // Aktualisiere Cache\n        if (this.nodeCache && node.id) {\n            this.nodeCache.set(node.id, {\n                x: node.x,\n                y: node.y,\n                vx: node.vx || 0,\n                vy: node.vy || 0,\n                isFixed: node.isFixed\n            });\n        }\n\n        // Simulation leicht neu starten\n        this.restart(0.1);\n\n        this.onToggleFixed(systemId, state);\n\n        return node.isFixed;\n    }\n\n    /**\n     * Initialize simulation with nodes and links\n     */\n    initialize(nodes, links, groups) {\n        // Apply cached positions before simulation starts\n        if (this.nodeCache) {\n            this.applyNodePositionsFromCache(nodes);\n        }\n\n        // Calculate initial positions for nodes without cache positions\n        this.applyInitialPositions(nodes);\n\n        // Create simulation\n        this.simulation = d3.forceSimulation(nodes)\n            .force(\"link\", d3.forceLink(links)\n                .id(d => d.id)\n                .distance(this.options.linkDistance))\n            .force(\"charge\", d3.forceManyBody()\n                .strength(this.options.chargeStrength))\n            .force(\"center\", d3.forceCenter(this.width / 2, this.height / 2))\n            .force(\"collision\", d3.forceCollide()\n                .radius(this.options.collisionRadius));\n\n        // Add group force if groups are provided\n        if (groups && Object.keys(groups).length > 0) {\n            this.simulation.force(\"group\", d3.forceClusterMultiGroup()\n                .centers(groups)\n                .strength(this.options.groupForceStrength));\n        }\n\n        // Add containment force to keep nodes within bounds\n        this.simulation.force(\"containment\", this.createContainmentForce());\n\n        // Register tick handler\n        this.simulation.on(\"tick\", () => {\n            // Update node cache periodically during simulation\n            this.throttledUpdateNodeCache();\n\n            // Call external tick handler\n            this.onTick();\n        });\n\n        // Register end handler\n        this.simulation.on(\"end\", () => {\n            // Save final positions to cache\n            if (this.nodeCache) {\n                this.nodeCache.updateBatch(this.simulation.nodes());\n            }\n\n            // Call external end handler\n            this.onEnd();\n        });\n\n        return this.simulation;\n    }\n\n    getNodeGroups(node) {\n        if (Array.isArray(node.groups) && node.groups.length > 0) {\n            return node.groups;\n        } else if (node.group && typeof node.group === 'string') {\n            return [node.group];\n        }\n        return [];\n    }\n\n    /**\n     * Create a force that keeps nodes within the container bounds\n     */\n    createContainmentForce() {\n        // Add padding to prevent nodes from touching the edge\n        const padding = 50;\n\n        return () => {\n            for (let node of this.simulation.nodes()) {\n                // Gradually increase force as node approaches boundaries\n                if (node.x < padding) {\n                    node.vx += (padding - node.x) * 0.1;\n                } else if (node.x > this.width - padding) {\n                    node.vx -= (node.x - (this.width - padding)) * 0.1;\n                }\n\n                if (node.y < padding) {\n                    node.vy += (padding - node.y) * 0.1;\n                } else if (node.y > this.height - padding) {\n                    node.vy -= (node.y - (this.height - padding)) * 0.1;\n                }\n\n                // Dampen velocity for stable movement\n                node.vx *= 0.9;\n                node.vy *= 0.9;\n            }\n        };\n    }\n\n    /**\n     * Apply cached positions to nodes\n     */\n    applyNodePositionsFromCache(nodes) {\n        if (!nodes || !this.nodeCache) return 0;\n\n        let cacheHits = 0;\n        nodes.forEach(node => {\n            if (node.id) {\n                const cachedPosition = this.nodeCache.get(node.id);\n                if (cachedPosition) {\n                    // Position from cache\n                    node.x = cachedPosition.x;\n                    node.y = cachedPosition.y;\n\n                    // Reduced velocity for smoother transitions\n                    node.vx = (cachedPosition.vx || 0) * 0.3;\n                    node.vy = (cachedPosition.vy || 0) * 0.3;\n\n                    // Briefly fix position for visual stability\n                    node.fx = cachedPosition.x;\n                    node.fy = cachedPosition.y;\n\n                    // Schedule release of fixed position\n                    node.isFixed = !!cachedPosition.isFixed;\n                    if(!node.isFixed) {\n                        setTimeout(() => {\n                            node.fx = null;\n                            node.fy = null;\n                        }, 500);\n                    }\n\n                    cacheHits++;\n                }\n            }\n        });\n\n        return cacheHits;\n    }\n\n    /**\n     * Calculate starting positions for nodes without cache positions\n     */\n    applyInitialPositions(nodes) {\n        // Find nodes without position\n        const nodesWithoutPosition = nodes.filter(node =>\n            node.x === undefined || node.y === undefined);\n\n        if (nodesWithoutPosition.length === 0) return;\n\n        // Get positioned nodes\n        const positionedNodes = nodes.filter(node =>\n            node.x !== undefined && node.y !== undefined);\n\n        // For each new node\n        nodesWithoutPosition.forEach(node => {\n            let referenceNodes = [];\n            let targetPosition;\n\n            // Reference nodes based on groups or all nodes\n            const nodeGroups = this.getNodeGroups(node);\n\n            if (nodeGroups.length > 0) {\n                // Sammeln aller Referenzknoten für alle Gruppen des Knotens\n                nodeGroups.forEach(group => {\n                    const groupNodes = positionedNodes.filter(n => {\n                        const nGroups = this.getNodeGroups(n);\n                        return nGroups.includes(group);\n                    });\n\n                    referenceNodes = [...referenceNodes, ...groupNodes];\n                });\n\n                // Duplikate entfernen\n                referenceNodes = Array.from(new Set(referenceNodes));\n            }\n\n            if (referenceNodes.length === 0) {\n                referenceNodes = positionedNodes;\n            }\n\n            // Calculate target position (between all group centers)\n            if (referenceNodes.length > 0) {\n                let sumX = 0, sumY = 0;\n                referenceNodes.forEach(refNode => {\n                    sumX += refNode.x;\n                    sumY += refNode.y;\n                });\n\n                // Group center with offset\n                const isGroupCentered = referenceNodes !== positionedNodes;\n                const offset = isGroupCentered ? 50 : 150;\n\n                targetPosition = {\n                    x: (sumX / referenceNodes.length) + (Math.random() - 0.5) * offset,\n                    y: (sumY / referenceNodes.length) + (Math.random() - 0.5) * offset\n                };\n            } else {\n                // If no references, use screen center\n                targetPosition = {\n                    x: this.width / 2 + (Math.random() - 0.5) * 200,\n                    y: this.height / 2 + (Math.random() - 0.5) * 200\n                };\n            }\n\n            // Starting position at group center edge\n            const distanceFromCenter = referenceNodes.length > 0 ? 100 : 200;\n            const angle = Math.random() * Math.PI * 2;  // Random angle\n\n            node.x = targetPosition.x + Math.cos(angle) * distanceFromCenter;\n            node.y = targetPosition.y + Math.sin(angle) * distanceFromCenter;\n\n            // Initial velocity toward target position\n            const dx = targetPosition.x - node.x;\n            const dy = targetPosition.y - node.y;\n\n            // Gentle movement toward center\n            const speedFactor = 0.01;  // Very low for gentle movement\n            node.vx = dx * speedFactor;\n            node.vy = dy * speedFactor;\n        });\n    }\n\n    /**\n     * Update node cache throttled\n     */\n    throttledUpdateNodeCache() {\n        const now = Date.now();\n        if (this.nodeCache && now - this.lastCacheUpdate > this.cacheUpdateInterval) {\n            this.lastCacheUpdate = now;\n            this.nodeCache.updateBatch(this.simulation.nodes());\n        }\n    }\n\n    /**\n     * Restart simulation with alpha\n     */\n    restart(alpha = 0.3) {\n        if (this.simulation) {\n            this.simulation.alpha(alpha).restart();\n        }\n    }\n\n    /**\n     * Stop simulation\n     */\n    stop() {\n        if (this.simulation) {\n            this.simulation.stop();\n        }\n    }\n\n    /**\n     * Update simulation size\n     */\n    updateSize(width, height) {\n        this.width = width;\n        this.height = height;\n\n        if (this.simulation) {\n            this.simulation.force(\"center\", d3.forceCenter(width / 2, height / 2));\n            // Restart with low alpha to adjust positions\n            this.restart(0.1);\n        }\n    }\n\n    /**\n     * Create drag behavior\n     */\n    createDragBehavior() {\n        return d3.drag()\n            .on(\"start\", (event, d) => this.dragstarted(event, d))\n            .on(\"drag\", (event, d) => this.dragged(event, d))\n            .on(\"end\", (event, d) => this.dragended(event, d));\n    }\n\n    /**\n     * Handle drag start\n     */\n    dragstarted(event, d) {\n        if (!event.active) this.simulation.alphaTarget(0.3).restart();\n        d.fx = d.x;\n        d.fy = d.y;\n        this.setNodeFixed(d.id, true, d);\n    }\n\n    /**\n     * Handle dragging\n     */\n    dragged(event, d) {\n        d.fx = event.x;\n        d.fy = event.y;\n    }\n\n    /**\n     * Handle drag end\n     */\n    dragended(event, d) {\n        if (!event.active) this.simulation.alphaTarget(0);\n\n        // Only persist position in cache if dragged\n        if (this.nodeCache && d.id) {\n            this.nodeCache.set(d.id, {\n                x: d.x,\n                y: d.y,\n                vx: 0,\n                vy: 0,\n                isFixed: d.isFixed || false\n            });\n        }\n\n        // Keep position fixed where user dropped it\n        // Or release: \n        //d.fx = null;\n        //d.fy = null;\n    }\n}\n\nd3.forceClusterMultiGroup = function () {\n    let strength = 0.1;\n    let centers = {};\n    let nodes = [];\n\n    // Gewichtung für jede Gruppe (1/Anzahl der Gruppen eines Knotens)\n    // Damit Knoten mit weniger Gruppen stärker zu ihren Gruppen hingezogen werden\n    function getGroupWeight(node) {\n        const nodeGroups = getNodeGroups(node);\n        return nodeGroups.length > 0 ? 1 / nodeGroups.length : 0;\n    }\n\n    // Hilfsfunktion zum Extrahieren aller Gruppen eines Knotens\n    function getNodeGroups(node) {\n        if (Array.isArray(node.groups) && node.groups.length > 0) {\n            return node.groups;\n        } else if (node.group && typeof node.group === 'string') {\n            return [node.group];\n        }\n        return [];\n    }\n\n    function force(alpha) {\n        // Für jeden Knoten\n        nodes.forEach(d => {\n            const nodeGroups = getNodeGroups(d);\n            if (nodeGroups.length === 0) return; // Überspringen, wenn keine Gruppe\n\n            // Vektor für die gesamte Kraft auf den Knoten\n            let totalForceX = 0;\n            let totalForceY = 0;\n            let totalWeight = 0;\n\n            // Kraft von jeder Gruppe berechnen\n            nodeGroups.forEach(groupName => {\n                const groupCenter = centers[groupName];\n                if (!groupCenter) return;\n\n                // Gewichtung für diese Gruppe\n                const weight = getGroupWeight(d);\n                totalWeight += weight;\n\n                // Je nach Anzahl der Gruppen, in denen der Knoten ist, die Kraft anpassen\n                const k = strength * alpha * weight;\n\n                // Kraft in Richtung des Gruppenzentrums\n                totalForceX += (groupCenter.x - d.x) * k;\n                totalForceY += (groupCenter.y - d.y) * k;\n            });\n\n            // Gesamtkraft auf den Knoten anwenden\n            if (totalWeight > 0) {\n                d.vx += totalForceX;\n                d.vy += totalForceY;\n            }\n        });\n    }\n\n    force.initialize = function (_) {\n        nodes = _;\n    };\n\n    force.centers = function (_) {\n        return arguments.length ? (centers = _, force) : centers;\n    };\n\n    force.strength = function (_) {\n        return arguments.length ? (strength = _, force) : strength;\n    };\n\n    return force;\n};\n\n//# sourceURL=webpack://infravis/./src/simulation.js?");

/***/ }),

/***/ "./src/system-manager.js":
/*!*******************************!*\
  !*** ./src/system-manager.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemManager: () => (/* binding */ SystemManager)\n/* harmony export */ });\n/**\n * System Manager - Verwaltet das Hinzufügen, Bearbeiten und Löschen von Systemen\n */\n\nclass SystemManager {\n    constructor() {\n        this.initialized = false;\n        this.currentEditingSystem = null;\n    }\n\n    /**\n     * Initialisiert den SystemManager\n     */\n    initialize(dataManager) {\n        this.dataManager = dataManager;\n\n        if (this.initialized) return;\n\n        // Auf Datenänderungen reagieren\n        this.dataManager.addEventListener('dataChanged', () => {\n            // Optional: Aktualisierung der UI bei Datenänderungen\n        });\n\n        this.initialized = true;\n        console.log('SystemManager wurde initialisiert');\n    }\n\n    /**\n     * Zeigt das System-Modal für Hinzufügen oder Bearbeiten an\n     * @param {string} systemId - Die ID des zu bearbeitenden Systems (null für Hinzufügen)\n     */\n    showSystemModal(systemId = null) {\n        // Modal-Titel je nach Aktion (Hinzufügen oder Bearbeiten) setzen\n        document.getElementById('system-modal-label').textContent =\n            systemId ? 'System bearbeiten' : 'System hinzufügen';\n\n        const form = document.getElementById('system-form');\n\n        // Formular zurücksetzen\n        form.reset();\n\n        // Gruppen-Container leeren\n        const groupsContainer = document.getElementById('system-groups-container');\n        if (groupsContainer) {\n            groupsContainer.innerHTML = '';\n        }\n\n        const groupsValueField = document.getElementById('system-groups-value');\n        if (groupsValueField) {\n            groupsValueField.value = '';\n        }\n\n        // Wenn systemId vorhanden, Formulardaten mit Systemdaten füllen\n        if (systemId) {\n            const system = this.dataManager.getData().systems.find(sys => sys.id === systemId);\n            if (system) {\n                this.currentEditingSystem = system;\n\n                // Formular mit Systemdaten füllen\n                document.getElementById('system-id').value = system.id;\n                document.getElementById('system-name').value = system.name;\n                document.getElementById('system-description').value = system.description;\n                document.getElementById('system-category').value = system.category;\n                document.getElementById('system-status').value = system.status;\n                document.getElementById('system-known-usage').checked = system.knownUsage;\n\n                // Gruppen als Badges hinzufügen\n                const groups = [];\n                if (Array.isArray(system.groups)) {\n                    system.groups.forEach(group => this.addGroupBadge(group));\n                    groups.push(...system.groups);\n                } else if (system.group && typeof system.group === 'string') {\n                    this.addGroupBadge(system.group);\n                    groups.push(system.group);\n                }\n\n                // Gruppen in Hidden-Feld speichern\n                if (groupsValueField) {\n                    groupsValueField.value = groups.join(',');\n                }\n\n                // Tags als kommaseparierte Liste darstellen\n                if (system.tags && Array.isArray(system.tags)) {\n                    document.getElementById('system-tags').value = system.tags.join(', ');\n                } else {\n                    document.getElementById('system-tags').value = '';\n                }\n            }\n        } else {\n            // Neues System, ID-Feld leeren\n            document.getElementById('system-id').value = '';\n            this.currentEditingSystem = null;\n        }\n\n        // Gruppenliste füllen (für Datalist)\n        const groupList = document.getElementById('group-list');\n        if (groupList) {\n            groupList.innerHTML = '';\n\n            // Bestehende Gruppen sammeln\n            const groups = this.dataManager.getAllGroups ?\n                this.dataManager.getAllGroups() : this.getExistingGroups();\n\n            // Gruppenliste befüllen\n            groups.forEach(group => {\n                const option = document.createElement('option');\n                option.value = group;\n                groupList.appendChild(option);\n            });\n        }\n\n        // Modal anzeigen\n        const modal = new bootstrap.Modal(document.getElementById('system-modal'));\n        modal.show();\n    }\n\n    /**\n     * Speichert ein neues oder bearbeitetes System\n     */\n    saveSystem() {\n        // Formulardaten sammeln\n        const systemId = document.getElementById('system-id').value;\n        const name = document.getElementById('system-name').value;\n        const description = document.getElementById('system-description').value;\n        const category = document.getElementById('system-category').value;\n        const status = document.getElementById('system-status').value;\n        const knownUsage = document.getElementById('system-known-usage').checked;\n\n        // Gruppen-Array erstellen - Unterstützung für altes und neues UI-Format\n        let groups = [];\n\n        // Neue UI (mit system-groups-value als Hidden-Field)\n        const groupsValueField = document.getElementById('system-groups-value');\n        if (groupsValueField) {\n            groups = groupsValueField.value\n                ? groupsValueField.value.split(',').map(g => g.trim()).filter(g => g !== '')\n                : [];\n        }\n        // Alte UI (mit system-group als direktem Input)\n        else {\n            const groupField = document.getElementById('system-group');\n            if (groupField && groupField.value.trim() !== '') {\n                // Prüfen, ob Kommas enthalten sind (für manuelle Mehrfachgruppeneingabe)\n                if (groupField.value.includes(',')) {\n                    groups = groupField.value.split(',').map(g => g.trim()).filter(g => g !== '');\n                } else {\n                    groups = [groupField.value.trim()];\n                }\n            }\n        }\n\n        // Tags aus kommaseparierter Liste in Array umwandeln\n        const tagsString = document.getElementById('system-tags').value;\n        const tags = tagsString\n            ? tagsString.split(',').map(tag => tag.trim()).filter(tag => tag)\n            : [];\n\n        // Formularvalidierung\n        if (!name || !description || !category || !status) {\n            showNotification('Bitte füllen Sie alle Pflichtfelder aus', 'warning');\n            return;\n        }\n\n        // Neues System-Objekt erstellen\n        const updatedSystem = {\n            id: systemId || this.dataManager.generateUniqueId(),\n            name,\n            description,\n            category,\n            status,\n            knownUsage,\n            tags,\n            groups // Neue Multi-Gruppen-Array\n        };\n\n        // Für Abwärtskompatibilität auch das einzelne group-Feld setzen\n        if (groups.length > 0) {\n            updatedSystem.group = groups[0];\n        }\n\n        // Hinzufügen oder Aktualisieren des Systems\n        if (!systemId) {\n            // Neues System hinzufügen\n            this.dataManager.addSystem(updatedSystem);\n            showNotification(`System \"${name}\" wurde hinzugefügt`, 'success');\n        } else {\n            // Bestehendes System aktualisieren\n            this.dataManager.updateSystem(updatedSystem);\n            showNotification(`System \"${name}\" wurde aktualisiert`, 'success');\n        }\n\n        // Modal schließen\n        bootstrap.Modal.getInstance(document.getElementById('system-modal')).hide();\n    }\n\n    /**\n     * Fügt eine Gruppe als Badge zum Container hinzu\n     * @param {string} groupName - Name der Gruppe\n     */\n    addGroupBadge(groupName) {\n        if (!groupName || groupName.trim() === '') return;\n\n        const container = document.getElementById('system-groups-container');\n        const hiddenField = document.getElementById('system-groups-value');\n\n        if (!container || !hiddenField) {\n            console.warn('Gruppen-UI-Elemente nicht gefunden. Multi-Gruppen-UI möglicherweise nicht initialisiert.');\n            return;\n        }\n\n        // Prüfen, ob die Gruppe bereits hinzugefügt wurde\n        const currentGroups = hiddenField.value ? hiddenField.value.split(',') : [];\n        if (currentGroups.includes(groupName)) return;\n\n        // Badge erstellen\n        const badge = document.createElement('span');\n        badge.className = 'badge bg-primary d-flex align-items-center';\n        badge.innerHTML = `\n        ${groupName}\n        <button type=\"button\" class=\"btn-close btn-close-white ms-2\" \n                aria-label=\"Entfernen\" style=\"font-size: 0.5rem;\"></button>\n    `;\n\n        // Löschen-Button\n        badge.querySelector('.btn-close').addEventListener('click', () => {\n            container.removeChild(badge);\n\n            // Wert aus dem Hidden-Field entfernen\n            const groups = hiddenField.value.split(',');\n            const index = groups.indexOf(groupName);\n            if (index !== -1) {\n                groups.splice(index, 1);\n                hiddenField.value = groups.join(',');\n            }\n        });\n\n        // Zum Container hinzufügen\n        container.appendChild(badge);\n\n        // Zum Hidden-Field hinzufügen\n        const newGroups = [...currentGroups, groupName];\n        hiddenField.value = newGroups.join(',');\n    }\n\n    /**\n     * Hilfsfunktion zum Sammeln aller existierenden Gruppen\n     * (Wird nur benötigt, falls getAllGroups nicht im DataManager implementiert ist)\n     * @returns {Array} Array mit einzigartigen Gruppennamen\n     */\n    getExistingGroups() {\n        const groups = new Set();\n\n        this.dataManager.getData().systems.forEach(system => {\n            if (Array.isArray(system.groups)) {\n                system.groups.forEach(group => {\n                    if (group && group.trim() !== '') {\n                        groups.add(group);\n                    }\n                });\n            } else if (system.group && typeof system.group === 'string') {\n                groups.add(system.group);\n            }\n        });\n\n        return Array.from(groups).sort();\n    }\n\n    /**\n     * Zeigt die Löschbestätigung für ein System an\n     * @param {string} systemId - Die ID des zu löschenden Systems\n     */\n    showDeleteConfirmation(systemId) {\n        const system = this.dataManager.getData().systems.find(sys => sys.id === systemId);\n        if (!system) return;\n\n        // Prüfen, ob das System in Abhängigkeiten verwendet wird\n        const data = this.dataManager.getData();\n        const incomingDeps = data.dependencies.filter(dep => dep.target === systemId);\n        const outgoingDeps = data.dependencies.filter(dep => dep.source === systemId);\n\n        let message = `Möchten Sie das System \"${system.name}\" wirklich löschen?`;\n\n        if (incomingDeps.length > 0 || outgoingDeps.length > 0) {\n            message += `<br><br><div class=\"alert alert-warning\">\n                <strong>Achtung:</strong> Dieses System hat ${incomingDeps.length + outgoingDeps.length} \n                Abhängigkeiten, die ebenfalls gelöscht werden.\n            </div>`;\n        }\n\n        document.getElementById('confirm-message').innerHTML = message;\n        document.getElementById('confirm-action').setAttribute('data-action', 'delete-system');\n        document.getElementById('confirm-action').setAttribute('data-id', systemId);\n\n        // Modal anzeigen\n        const modal = new bootstrap.Modal(document.getElementById('confirm-modal'));\n        modal.show();\n    }\n\n    /**\n     * Löscht ein System und seine Abhängigkeiten\n     * @param {string} systemId - Die ID des zu löschenden Systems\n     */\n    deleteSystem(systemId) {\n        // System finden und Namen für die Benachrichtigung speichern\n        const system = this.dataManager.getData().systems.find(sys => sys.id === systemId);\n        if (!system) return;\n\n        const systemName = system.name;\n\n        // System über den DataManager löschen\n        this.dataManager.deleteSystem(systemId);\n\n        showNotification(`System \"${systemName}\" und zugehörige Abhängigkeiten wurden gelöscht`, 'success');\n\n        // Details-Panel schließen\n        document.getElementById('details-panel').classList.remove('active');\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/system-manager.js?");

/***/ }),

/***/ "./src/visualizer.js":
/*!***************************!*\
  !*** ./src/visualizer.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemVisualizer: () => (/* binding */ SystemVisualizer)\n/* harmony export */ });\n/* harmony import */ var _simulation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simulation.js */ \"./src/simulation.js\");\n/* harmony import */ var _node_cache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node-cache.js */ \"./src/node-cache.js\");\n\n\n\n/**\n * SystemVisualizer - Visualisiert IT-Systeme und deren Abhängigkeiten als interaktiven Graphen\n */\nclass SystemVisualizer {\n    constructor(containerId, dataManager) {\n        this.containerId = containerId;\n        this.dataManager = dataManager;\n\n        this.eventListeners = {\n            'dependency-click': [],\n            'toggle-fixed': [],\n        };\n\n        // Getter für Zugriff auf aktuelle Daten\n        Object.defineProperty(this, 'data', {\n            get: () => this.dataManager.getData()\n        });\n\n        // D3-Visualisierungsvariablen\n        this.svg = null;\n        this.width = 0;\n        this.height = 0;\n        this.zoom = null;\n\n        // UI-Zustände\n        this.searchResults = [];\n        this.activeFilters = {\n            categories: [\"core\", \"legacy\", \"data\", \"service\", \"external\"],\n            knownUsage: [\"known\", \"unknown\"]\n        };\n\n        // Farbskalen\n        this.colorScale = d3.scaleOrdinal()\n            .domain([\"core\", \"legacy\", \"data\", \"service\", \"external\"])\n            .range([\"#0d6efd\", \"#6c757d\", \"#198754\", \"#ffc107\", \"#dc3545\"]);\n        this.groupColorScale = d3.scaleOrdinal(d3.schemeCategory10);\n\n        // Node-Cache erstellen\n        this.nodeCache = new _node_cache_js__WEBPACK_IMPORTED_MODULE_1__.NodeCache({\n            useLocalStorage: true,\n            localStorageKey: 'system_visualizer_node_positions',\n            debounceTime: 250\n        });\n\n        // SimulationManager erstellen (wird später initialisiert)\n        this.simulationManager = null;\n\n        // Visualisierungselemente\n        this.nodeElements = null;\n        this.linkElements = null;\n        this.groupHulls = null;\n        this.groupLabels = null;\n    }\n\n    /**\n     * Initialisiert die Visualisierung\n     */\n    initialize() {\n        if (!this.data || !this.data.systems || this.data.systems.length === 0) {\n            this.showError(\"Keine Systemdaten verfügbar\");\n            return;\n        }\n\n        this.createVisualization();\n        this.setupZoom();\n        this.attachEventListeners();\n\n        // Auf Datenänderungen reagieren\n        this.dataManager.addEventListener('dataChanged', () => {\n            // Visualisierung neu erstellen\n            const container = document.getElementById(this.containerId);\n            if (container) {\n                container.innerHTML = '';\n                this.createVisualization();\n                this.setupZoom();\n            }\n        });\n\n        // Details-Panel-Aktualisierung bei Datenänderungen\n        this.dataManager.addEventListener('dataChanged', () => {\n            const detailsPanel = document.getElementById('details-panel');\n            if (detailsPanel && detailsPanel.classList.contains('active')) {\n                const systemId = document.getElementById('detail-title').getAttribute('data-system-id');\n                if (systemId) {\n                    const updatedSystem = this.dataManager.getData().systems.find(sys => sys.id === systemId);\n                    if (updatedSystem) {\n                        this.showSystemDetails(updatedSystem);\n                    } else {\n                        detailsPanel.classList.remove('active');\n                    }\n                }\n            }\n        });\n\n        // Event-Listener für Fenstergrößenänderungen\n        window.addEventListener('resize', this.handleResize.bind(this));\n\n        // Vor dem Beenden Cache aktualisieren\n        window.addEventListener('beforeunload', () => {\n            if (this.simulationManager) {\n                this.simulationManager.stop();\n            }\n        });\n    }\n\n    /**\n     * Erstellt die D3.js-Visualisierung\n     */\n    createVisualization() {\n        const container = document.getElementById(this.containerId);\n\n        if (!container) {\n            console.error(`Container mit ID \"${this.containerId}\" nicht gefunden`);\n            return;\n        }\n\n        // Größe und Margins (Vollbild)\n        this.width = container.clientWidth;\n        this.height = container.clientHeight;\n\n        // SVG erstellen\n        this.svg = d3.select(container)\n            .append(\"svg\")\n            .attr(\"width\", this.width)\n            .attr(\"height\", this.height);\n\n        // Gruppe für Zoom\n        const g = this.svg.append(\"g\");\n\n        // Tooltip erstellen\n        // Tooltip-Element suchen oder erstellen (als D3-Selection)\n        let tooltip = d3.select(\"body\").select(\".tooltip\");\n        if (tooltip.empty()) {\n            tooltip = d3.select(\"body\").append(\"div\")\n                .attr(\"class\", \"tooltip\")\n                .style(\"opacity\", 0);\n        }\n\n        // Graph-Daten vorbereiten und filtern\n        const nodes = this.getFilteredNodes();\n        const links = this.getFilteredLinks(nodes);\n\n        // Gruppierungen identifizieren\n        const groups = this.identifyGroups(nodes);\n\n        // SimulationManager erstellen\n        this.simulationManager = new _simulation_js__WEBPACK_IMPORTED_MODULE_0__.SimulationManager({\n            width: this.width,\n            height: this.height,\n            nodeCache: this.nodeCache,\n            linkDistance: 150,\n            chargeStrength: -300,\n            collisionRadius: 60,\n            groupForceStrength: 0.5,\n            onTick: () => this.onSimulationTick(),\n            onToggleFixed:(id, state) => {\n                this.notifyListeners('toggle-fixed', { id, state });\n            },\n        });\n\n        // Pfeilspitzen für die Links\n        g.append(\"defs\").selectAll(\"marker\")\n            .data([\"data\", \"integration\", \"authentication\", \"monitoring\"])\n            .enter().append(\"marker\")\n            .attr(\"id\", d => `arrowhead-${d}`)\n            .attr(\"viewBox\", \"0 -5 10 10\")\n            .attr(\"refX\", 8)  // Kein Versatz - Pfeilspitze beginnt am Ende des Pfades\n            .attr(\"refY\", 0)  // Kein Versatz\n            .attr(\"markerWidth\", 6)\n            .attr(\"markerHeight\", 6)\n            .attr(\"orient\", \"auto\")\n            .append(\"path\")\n            .attr(\"d\", \"M0,-5L10,0L0,5\")\n            .attr(\"fill\", d => {\n                switch (d) {\n                    case \"data\": return \"#0d6efd\";\n                    case \"integration\": return \"#198754\";\n                    case \"authentication\": return \"#dc3545\";\n                    case \"monitoring\": return \"#6c757d\";\n                    default: return \"#999\";\n                }\n            });\n\n        // Gruppenrahmen zeichnen (vor den Knoten und Links)\n        this.groupHulls = g.append(\"g\")\n            .attr(\"class\", \"groups\")\n            .selectAll(\".group-hull\")\n            .data(Object.entries(groups).filter(([name]) => name !== \"ungrouped\")) // \"undefined\" Gruppe ausfiltern\n            .enter().append(\"path\")\n            .attr(\"class\", \"group-hull\")\n            .attr(\"data-group\", d => d[0])\n            .style(\"fill\", d => this.groupColorScale(d[0]))\n            .style(\"stroke\", d => d3.rgb(this.groupColorScale(d[0])).darker())\n            .style(\"stroke-width\", 1.5)\n            .style(\"fill-opacity\", 0.2)\n            .style(\"stroke-opacity\", 0.4);\n\n        // Links zeichnen\n        const that = this;\n        // Links zeichnen\n        this.linkElements = g.append(\"g\")\n            .attr(\"class\", \"links\")\n            .selectAll(\"path\")\n            .data(links)\n            .enter().append(\"path\")\n            .attr(\"class\", \"link\")\n            .attr(\"marker-end\", d => `url(#arrowhead-${d.type})`)\n            .attr(\"data-type\", d => d.type)\n            .attr(\"data-link-index\", d => d.linkIndex)\n            .attr(\"data-total-links\", d => d.totalLinks)\n            .on(\"mouseover\", function (event, d) {\n                if (that.dragDisabled) return;\n                tooltip.transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n\n                const sourceSystem = nodes.find(n => n.id === d.source.id || n.id === d.source);\n                const targetSystem = nodes.find(n => n.id === d.target.id || n.id === d.target);\n\n                tooltip.html(`\n                    <strong>${sourceSystem ? sourceSystem.name : 'Unbekannt'} → ${targetSystem ? targetSystem.name : 'Unbekannt'}</strong><br>\n                    ${d.description || 'Keine Beschreibung'}<br>\n                    <em>Protokoll: ${d.protocol || 'Nicht spezifiziert'}</em>\n                `);\n\n                // Tooltip mittig unterhalb des Mauszeigers positionieren\n                const tooltipNode = tooltip.node();\n                // Temporär sichtbar machen, um Breite zu messen\n                tooltip.style(\"opacity\", 0).style(\"display\", \"block\");\n                const tooltipWidth = tooltipNode.offsetWidth;\n                tooltip.style(\"display\", null); // zurücksetzen\n\n                tooltip\n                    .style(\"left\", (event.pageX - tooltipWidth / 2) + \"px\")\n                    .style(\"top\", (event.pageY + 16) + \"px\")\n                    .transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n            })\n            .on(\"mouseout\", function () {\n                tooltip.transition()\n                    .duration(500)\n                    .style(\"opacity\", 0);\n            })\n            .on(\"click\", (event, data) => {\n                this.notifyListeners('dependency-click', { event, data });\n                event.stopPropagation();\n            });;\n\n        // Knoten erstellen\n        const nodeGroup = g.append(\"g\")\n            .attr(\"class\", \"nodes\");\n\n        this.nodeElements = nodeGroup.selectAll(\".node\")\n            .data(nodes)\n            .enter().append(\"g\")\n            .attr(\"class\", d => {\n                const classes = [\"node\"];\n                if (!d.knownUsage) classes.push(\"unknown-usage\");\n\n                // Mehrere Gruppen-Klassen hinzufügen\n                const nodeGroups = this.getNodeGroups(d);\n                nodeGroups.forEach(group => {\n                    classes.push(`group-${group}`);\n                });\n\n                return classes.join(\" \");\n            })\n            .attr(\"data-system-id\", d => d.id)\n            .attr(\"data-groups\", d => this.getNodeGroups(d).join(\",\"));\n\n        if (!this.dragDisabled) {\n            this.nodeElements.call(this.simulationManager.createDragBehavior())\n        }\n\n        // Kreise für die Systeme\n        const radius = 30;\n        this.nodeElements.append(\"circle\")\n            .attr(\"r\", radius)\n            .attr(\"fill\", d => this.colorScale(d.category))\n            .attr(\"stroke\", d => {\n                const nodeGroups = this.getNodeGroups(d);\n                if (nodeGroups.length > 0) {\n                    // Bei mehreren Gruppen einen Mehrfarben-Stroke erstellen (könnte z.B. gestrichelt sein)\n                    return nodeGroups.length > 1 ?\n                        \"url(#multigroup-gradient-\" + d.id + \")\" : // ID für Gradient\n                        this.groupColorScale(nodeGroups[0]); // Einzelne Gruppe\n                }\n                return \"#fff\"; // Standard ohne Gruppe\n            })\n            .attr(\"stroke-width\", d => this.getNodeGroups(d).length > 0 ? 3 : 2)\n            .attr(\"stroke-dasharray\", d => this.getNodeGroups(d).length > 1 ? \"5,3\" : null)\n            .on(\"mouseover\", function (event, d) {\n                if (that.dragDisabled) return;\n                tooltip.transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n                tooltip.html(`\n                    <strong>${d.name}</strong><br>\n                    ${d.description}<br>\n                    ${d.group ? '<span class=\"badge bg-info\">Gruppe: ' + d.group + '</span>' : ''}\n                `);\n\n                // Temporär sichtbar machen, um Breite und Höhe zu messen\n                tooltip.style(\"opacity\", 0).style(\"display\", \"block\");\n                const tooltipNode = tooltip.node();\n                const tooltipWidth = tooltipNode.offsetWidth;\n                tooltip.style(\"display\", null); // zurücksetzen\n\n                // Höhe des Kreises bestimmen (SVG-Kreis hat r=30)\n                const circleRadius = radius;\n                // Optional: Falls der Kreisradius dynamisch ist, könnte man ihn so ermitteln:\n                // const circleRadius = d3.select(this).attr(\"r\");\n\n                tooltip\n                    .style(\"left\", (event.pageX - tooltipWidth / 2) + \"px\")\n                    .style(\"top\", (event.pageY + Number(circleRadius) + 8) + \"px\") // 8px Abstand unterhalb des Kreises\n                    .transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n            })\n            .on(\"mouseout\", function () {\n                tooltip.transition()\n                    .duration(500)\n                    .style(\"opacity\", 0);\n            })\n            .on(\"click\", (event, d) => this.showSystemDetails(d));\n\n        // Text-Labels\n        this.nodeElements.append(\"text\")\n            .attr(\"dy\", -40)\n            .attr(\"text-anchor\", \"middle\")\n            .text(d => d.name)\n            .attr(\"fill\", \"#333\");\n\n        // Gruppen-Labels hinzufügen\n        this.groupLabels = g.append(\"g\")\n            .attr(\"class\", \"group-labels\")\n            .selectAll(\".group-label\")\n            .data(Object.entries(groups).filter(([name]) => name !== \"ungrouped\"))\n            .enter().append(\"text\")\n            .attr(\"class\", \"group-label\")\n            .attr(\"text-anchor\", \"middle\")\n            .style(\"font-size\", \"16px\")\n            .style(\"font-weight\", \"bold\")\n            .style(\"fill\", d => d3.rgb(this.groupColorScale(d[0])).darker(2))\n            .style(\"pointer-events\", \"none\")\n            .text(d => {\n                // Anzeige für zusammengeführte Gruppen\n                if (d[1].allGroups && d[1].allGroups.length > 1) {\n                    return `${d[0]} (+${d[1].allGroups.length - 1})`;\n                }\n                return d[0];\n            });\n        this.groupLabels.append(\"title\") // Tooltip für Details\n            .text(d => {\n                if (d[1].allGroups && d[1].allGroups.length > 1) {\n                    return `Zusammengeführte Gruppen:\\n${d[1].allGroups.join('\\n')}`;\n                }\n                return d[0];\n            });\n\n        const defs = g.select(\"defs\");\n        nodes.forEach(d => {\n            const nodeGroups = this.getNodeGroups(d);\n            if (nodeGroups.length > 1) {\n                const gradient = defs.append(\"linearGradient\")\n                    .attr(\"id\", \"multigroup-gradient-\" + d.id)\n                    .attr(\"x1\", \"0%\")\n                    .attr(\"y1\", \"0%\")\n                    .attr(\"x2\", \"100%\")\n                    .attr(\"y2\", \"100%\");\n\n                // Farbstopps für jede Gruppe hinzufügen\n                nodeGroups.forEach((group, i) => {\n                    gradient.append(\"stop\")\n                        .attr(\"offset\", (i / (nodeGroups.length - 1) * 100) + \"%\")\n                        .attr(\"stop-color\", this.groupColorScale(group));\n                });\n            }\n        });\n\n        // Simulation starten\n        this.simulationManager.initialize(nodes, links, groups);\n    }\n\n    /**\n    * Gibt gefilterte Links basierend auf den gefilterten Knoten zurück\n    */\n    getFilteredLinks(nodes) {\n        const nodeIds = nodes.map(node => node.id);\n\n        // Verbindungszähler initialisieren\n        const linkCounts = {};\n\n        // Erste Filterung der Links\n        const filteredLinks = this.data.dependencies.filter(dep => {\n            return nodeIds.includes(dep.source) && nodeIds.includes(dep.target);\n        });\n\n        // Links zählen und indizieren\n        filteredLinks.forEach(dep => {\n            const key = `${dep.source}-${dep.target}`;\n            const reverseKey = `${dep.target}-${dep.source}`;\n\n            // Zähler für diese Richtung initialisieren\n            if (!linkCounts[key]) {\n                linkCounts[key] = 0;\n            }\n\n            // Zähler erhöhen und dem Link zuweisen\n            linkCounts[key]++;\n            dep.linkIndex = linkCounts[key] - 1; // 0-basierter Index\n\n            // Gesamtzahl der Links in dieser Richtung speichern\n            dep.totalLinks = filteredLinks.filter(d =>\n                (d.source === dep.source && d.target === dep.target)\n            ).length;\n        });\n\n        // Links mit zusätzlichen Informationen zurückgeben\n        return filteredLinks.map(dep => ({\n            source: dep.source,\n            target: dep.target,\n            linkIndex: dep.linkIndex,\n            totalLinks: dep.totalLinks,\n            ...dep\n        }));\n    }\n\n    /**\n     * Wird bei jedem Simulation-Tick aufgerufen\n     */\n    onSimulationTick() {\n        if (!this.linkElements || !this.nodeElements || !this.groupHulls || !this.groupLabels) {\n            return;\n        }\n\n        // Links aktualisieren\n        this.linkElements.attr(\"d\", this.linkArc);\n\n        // Knoten aktualisieren\n        this.nodeElements.attr(\"transform\", d => `translate(${d.x},${d.y})`);\n\n        // Gruppierungshüllen aktualisieren\n        this.groupHulls.attr(\"d\", d => {\n            const groupName = d[0];\n            const simulation = this.simulationManager.simulation;\n\n            // Alle Knoten finden, die zu dieser Gruppe gehören\n            // WICHTIGER UNTERSCHIED: Wir prüfen jetzt, ob ein Knoten zu EINER der ursprünglichen Gruppen gehört\n            const groupNodes = simulation.nodes().filter(n => {\n                const nodeGroups = this.getNodeGroups(n);\n\n                // Prüfe, ob der Knoten zu einer der ursprünglichen Gruppen gehört,\n                // die auf diese Repräsentanten-Gruppe abgebildet wurden\n                if (d[1].allGroups) {\n                    // Für eine zusammengeführte Gruppe prüfen, ob der Knoten zu einer der ursprünglichen Gruppen gehört\n                    return nodeGroups.some(ng => d[1].allGroups.includes(ng));\n                } else {\n                    // Für eine einzelne Gruppe normal prüfen\n                    return nodeGroups.includes(groupName);\n                }\n            });\n\n            // Wenn keine oder nur ein Knoten, zeichne einen kleinen Kreis um diesen\n            if (groupNodes.length === 0) {\n                return \"\"; // Keine Hülle, wenn keine Knoten\n            }\n\n            if (groupNodes.length === 1) {\n                // Bei nur einem Knoten: zeichne Kreis um diesen\n                const node = groupNodes[0];\n                return `M${node.x + 60},${node.y} \n                    A60,60 0 1,1 ${node.x - 60},${node.y} \n                    A60,60 0 1,1 ${node.x + 60},${node.y}`;\n            }\n\n            // Zentroid der Gruppe berechnen\n            const points = groupNodes.map(n => [n.x, n.y]);\n            const centroid = this.getCentroid(points);\n\n            // Radius berechnen (mit zusätzlichem Padding)\n            const maxDist = Math.max(40, this.getMaxDistanceFromCentroid(points, centroid) + 40);\n\n            // Kreisförmige Hülle um die Gruppe zeichnen\n            return this.createHullPath(centroid, maxDist, 24);\n        });\n\n        // Gruppenbezeichnungen aktualisieren\n        this.groupLabels.attr(\"transform\", d => {\n            const groupName = d[0];\n            const simulation = this.simulationManager.simulation;\n\n            // Die gleiche Filterlogik wie bei den Hüllen verwenden\n            const groupNodes = simulation.nodes().filter(n => {\n                const nodeGroups = this.getNodeGroups(n);\n\n                if (d[1].allGroups) {\n                    return nodeGroups.some(ng => d[1].allGroups.includes(ng));\n                } else {\n                    return nodeGroups.includes(groupName);\n                }\n            });\n\n            if (groupNodes.length === 0) return \"translate(0,0)\";\n\n            const points = groupNodes.map(n => [n.x, n.y]);\n            const centroid = this.getCentroid(points);\n\n            return `translate(${centroid[0]},${centroid[1] - 60})`;\n        });\n    }\n\n    /**\n     * Richtet Zoom-Funktionalität ein\n     */\n    setupZoom() {\n        this.zoom = d3.zoom()\n            .scaleExtent([0.1, 4])\n            .on(\"zoom\", (event) => {\n                this.svg.select(\"g\").attr(\"transform\", event.transform);\n            });\n\n        this.svg.call(this.zoom);\n\n        // Reset-Zoom-Button\n        document.getElementById(\"reset-zoom\").addEventListener(\"click\", () => {\n            this.svg.transition().duration(750).call(\n                this.zoom.transform,\n                d3.zoomIdentity\n            );\n        });\n\n        // Nach dem Zoom oder Pan den Zustand speichern\n        this.zoom.on('end', () => {\n            this.saveViewportState();\n        });\n\n        // Zustand wiederherstellen\n        this.restoreViewportState();\n    }\n\n    /**\n * Optimierte linkArc-Funktion mit angepasster Verteilung für gerade Anzahl von Links\n */\n    linkArc(d) {\n        // Knotenradius\n        const nodeRadius = 32;\n\n        // Extrahiere Quell- und Zielkoordinaten\n        const sourceX = d.source.x;\n        const sourceY = d.source.y;\n        const targetX = d.target.x;\n        const targetY = d.target.y;\n\n        // Berechne Abstand und Basiswinkel zwischen den Knoten\n        const dx = targetX - sourceX;\n        const dy = targetY - sourceY;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        const baseAngle = Math.atan2(dy, dx);\n\n        // Bestimmung der Winkelversätze\n        const totalLinks = d.totalLinks || 1;\n        const linkIndex = d.linkIndex || 0;\n\n        // Maximaler Winkelversatz in Grad (±15°), in Radiant umgerechnet\n        const maxOffsetDegrees = 15;\n        const maxOffset = (maxOffsetDegrees * Math.PI) / 180;\n\n        // Winkelversatz berechnen - mit Anpassung für gerade Anzahl von Links\n        let angleOffset = 0;\n\n        if (totalLinks > 1) {\n            if (totalLinks % 2 === 0) {\n                // Bei gerader Anzahl: Verschiebung, um die Mitte zu vermeiden\n                // z.B. bei 4 Links: -0.75, -0.25, +0.25, +0.75 statt -1, -0.33, +0.33, +1\n                const step = 1 / totalLinks;\n                angleOffset = ((linkIndex / (totalLinks - 1)) * 2 - 1 + step) * maxOffset;\n            } else {\n                // Bei ungerader Anzahl: normale Verteilung\n                angleOffset = ((linkIndex / (totalLinks - 1)) * 2 - 1) * maxOffset;\n            }\n        }\n\n        // Startpunkt auf dem Quellknoten\n        const startAngle = baseAngle + angleOffset;\n        const startX = sourceX + Math.cos(startAngle) * nodeRadius;\n        const startY = sourceY + Math.sin(startAngle) * nodeRadius;\n\n        // Endpunkt auf dem Zielknoten mit gespiegeltem Winkelversatz\n        const endAngle = baseAngle + Math.PI - angleOffset;\n        const endX = targetX + Math.cos(endAngle) * nodeRadius;\n        const endY = targetY + Math.sin(endAngle) * nodeRadius;\n\n        // Minimaler Winkelversatz für die Krümmung (selbst bei einzelnen Links)\n        // Einzelne Links bekommen eine leichte Kurve statt einer geraden Linie\n        const minCurvatureAngle = (3 * Math.PI) / 180;  // 3 Grad in Radiant\n\n        // Effektiver Winkelversatz für die Krümmungsberechnung\n        const effectiveAngleOffset = Math.max(Math.abs(angleOffset), minCurvatureAngle);\n\n        // Bogenrichtung basierend auf dem Vorzeichen des Winkelversatzes\n        // Bei einzelnen Links: standardmäßig im Uhrzeigersinn\n        const sweep = (totalLinks === 1 || angleOffset >= 0) ? 1 : 0;\n\n        // Krümmungsfaktor basierend auf Winkelversatz und Distanz\n        // Minimal 0.15 für leichte Kurve, maximal 0.5 für starke Kurve\n        let curvature = 0.15 + (effectiveAngleOffset / maxOffset) * 0.35;\n\n        // Orthogonale Richtungsvektoren für den Kontrollpunkt\n        const tangentX = (endX - startX) / distance;\n        const tangentY = (endY - startY) / distance;\n        const perpX = -tangentY;\n        const perpY = tangentX;\n\n        // Mittelpunkt berechnen\n        const midX = (startX + endX) / 2;\n        const midY = (startY + endY) / 2;\n\n        // Kontrollpunkt mit Richtung basierend auf sweep\n        const ctrlFactor = (sweep === 1 ? 1 : -1) * curvature * distance;\n        const ctrlX = midX + perpX * ctrlFactor;\n        const ctrlY = midY + perpY * ctrlFactor;\n\n        // Quadratische Bézierkurve\n        return `M${startX},${startY}Q${ctrlX},${ctrlY} ${endX},${endY}`;\n    }\n\n    /**\n     * Identifiziert alle Gruppen und bereitet sie für d3.js vor\n     * Optimiert, um Gruppen mit identischen Knoten zusammenzuführen\n     */\n    /**\n * Erweiterte identifyGroups Methode, die sowohl Zusammenführung durchführt\n * als auch bidirektionale Zuordnungen zwischen Gruppen speichert\n */\n    identifyGroups(nodes) {\n        // Schritt 1: Initiale Gruppierung erstellen\n        const initialGroupMap = {};\n        const UNGROUPED_GROUP_NAME = \"ungrouped\";\n\n        // Datenstruktur für Gruppe -> Zugehörige Knoten\n        nodes.forEach(node => {\n            const nodeGroups = this.getNodeGroups(node);\n\n            if (nodeGroups.length > 0) {\n                nodeGroups.forEach(groupName => {\n                    if (!initialGroupMap[groupName]) {\n                        initialGroupMap[groupName] = {\n                            nodes: [],\n                            nodeIds: new Set(),\n                            x: 0,\n                            y: 0\n                        };\n                    }\n                    initialGroupMap[groupName].nodes.push(node);\n                    initialGroupMap[groupName].nodeIds.add(node.id);\n                });\n            } else {\n                if (!initialGroupMap[UNGROUPED_GROUP_NAME]) {\n                    initialGroupMap[UNGROUPED_GROUP_NAME] = {\n                        nodes: [],\n                        nodeIds: new Set(),\n                        x: 0,\n                        y: 0\n                    };\n                }\n                initialGroupMap[UNGROUPED_GROUP_NAME].nodes.push(node);\n                initialGroupMap[UNGROUPED_GROUP_NAME].nodeIds.add(node.id);\n            }\n        });\n\n        // Schritt 2: Gruppen mit identischen Knoten identifizieren\n        const groupSignatures = {};  // Signatur -> Gruppen mit dieser Signatur\n\n        Object.entries(initialGroupMap).forEach(([groupName, groupData]) => {\n            if (groupName === UNGROUPED_GROUP_NAME) return;\n\n            // Erstelle eine eindeutige Signatur basierend auf den Knoten-IDs\n            const signature = Array.from(groupData.nodeIds).sort().join(',');\n\n            if (!groupSignatures[signature]) {\n                groupSignatures[signature] = [];\n            }\n\n            groupSignatures[signature].push(groupName);\n        });\n\n        // Schritt 3: Finale Gruppenkarte erstellen\n        const finalGroupMap = {};\n\n        // Mapping von ursprünglichen Gruppen zu repräsentativen Gruppen\n        // WICHTIG: Wir speichern dies als globale/Klasseninstanz-Variable\n        this.groupMap = {};\n\n        // Zuerst die ungrouped-Gruppe hinzufügen, falls vorhanden\n        if (initialGroupMap[UNGROUPED_GROUP_NAME]) {\n            finalGroupMap[UNGROUPED_GROUP_NAME] = initialGroupMap[UNGROUPED_GROUP_NAME];\n        }\n\n        // Dann die zusammengeführten Gruppen\n        Object.entries(groupSignatures).forEach(([signature, groups]) => {\n            // Die erste Gruppe als repräsentative Gruppe verwenden\n            const primaryGroup = groups[0];\n\n            // Gruppe in die finale Karte übernehmen\n            finalGroupMap[primaryGroup] = initialGroupMap[primaryGroup];\n\n            // Speichere alle ursprünglichen Gruppen als Metadaten\n            if (groups.length > 1) {\n                finalGroupMap[primaryGroup].allGroups = groups;\n                console.log(`Merged identical groups: ${groups.join(', ')} -> ${primaryGroup}`);\n\n                // Bidirektionale Zuordnung erstellen\n                groups.forEach(originalGroup => {\n                    this.groupMap[originalGroup] = primaryGroup;\n                });\n            } else {\n                // Auch für Einzelgruppen die Zuordnung erstellen\n                this.groupMap[primaryGroup] = primaryGroup;\n            }\n        });\n\n        // Schritt 4: Initiale Positionen berechnen\n        Object.entries(finalGroupMap).forEach(([groupName, group], index) => {\n            // Positionen gleichmäßig um den Mittelpunkt verteilen\n            const angle = (index / Object.keys(finalGroupMap).length) * 2 * Math.PI;\n            const radius = Math.min(this.width, this.height) * 0.4;\n\n            group.x = this.width / 2 + radius * Math.cos(angle);\n            group.y = this.height / 2 + radius * Math.sin(angle);\n        });\n\n        return finalGroupMap;\n    }\n\n    /**\n     * Hilfsfunktion um zu prüfen, ob zwei Arrays die gleichen Elemente enthalten\n     * (Reihenfolge wird ignoriert)\n     */\n    arraysHaveSameElements(arr1, arr2) {\n        if (arr1.length !== arr2.length) return false;\n\n        const set1 = new Set(arr1);\n        for (const item of arr2) {\n            if (!set1.has(item)) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Hilfsfunktion zum Extrahieren aller Gruppen eines Knotens\n     * Berücksichtigt neue groups-Arrays und Legacy group-Felder\n     */\n    getNodeGroups(node) {\n        if (Array.isArray(node.groups) && node.groups.length > 0) {\n            return node.groups;\n        } else if (node.group && typeof node.group === 'string') {\n            return [node.group];\n        }\n        return [];\n    }\n\n    /**\n     * Berechnet den Schwerpunkt (Zentroid) einer Gruppe von Punkten\n     */\n    getCentroid(points) {\n        const n = points.length;\n        if (n === 0) return [0, 0];\n\n        const sumX = points.reduce((sum, p) => sum + p[0], 0);\n        const sumY = points.reduce((sum, p) => sum + p[1], 0);\n\n        return [sumX / n, sumY / n];\n    }\n\n    /**\n     * Berechnet die maximale Distanz vom Zentroid zu einem Punkt der Gruppe\n     */\n    getMaxDistanceFromCentroid(points, centroid) {\n        if (points.length === 0) return 0;\n\n        return Math.max(...points.map(p =>\n            Math.sqrt(Math.pow(p[0] - centroid[0], 2) + Math.pow(p[1] - centroid[1], 2))\n        ));\n    }\n\n    /**\n     * Erstellt einen Pfad für die Gruppenhülle\n     */\n    createHullPath(center, radius, segments) {\n        const angleStep = (2 * Math.PI) / segments;\n        let path = `M${center[0] + radius},${center[1]}`;\n\n        for (let i = 1; i <= segments; i++) {\n            const angle = i * angleStep;\n            const x = center[0] + radius * Math.cos(angle);\n            const y = center[1] + radius * Math.sin(angle);\n            path += ` L${x},${y}`;\n        }\n\n        return path + \"Z\";\n    }\n\n    /**\n     * Gibt den Knoten mit der angegebenen ID aus der aktuellen Simulation zurück\n     * @param {string} systemId - Die ID des zu findenden Systems\n     * @returns {Object|null} Das Knotenobjekt oder null, wenn nicht gefunden\n     */\n    getNodeById(systemId) {\n        return this.simulationManager.getNodeById(systemId);\n    }\n\n    /**\n     * Prüft, ob ein Knoten fixiert ist\n     * @param {string} systemId - Die ID des zu prüfenden Systems\n     * @returns {boolean} True, wenn der Knoten fixiert ist, false sonst oder wenn nicht gefunden\n     */\n    isNodeFixed(systemId) {\n        return this.simulationManager.isNodeFixed(systemId);\n    }\n\n    /**\n     * Schaltet den fixierten Zustand eines Knotens um\n     * @param {string} systemId - Die ID des zu ändernden Systems\n     * @returns {boolean} Der neue Fixierungszustand oder null, wenn der Knoten nicht gefunden wurde\n     */\n    toggleNodeFixed(systemId) {\n        return this.simulationManager.toggleNodeFixed(systemId);\n    }\n\n    /**\n     * Zeigt die Systemdetails im Overlay an\n     */\n    showSystemDetails(system) {\n        const detailsPanel = document.getElementById('details-panel');\n        const detailsDiv = document.getElementById('system-details');\n        const detailTitle = document.getElementById('detail-title');\n\n        if (!detailsDiv || !detailsPanel || !detailTitle) {\n            console.error('Details-Container nicht gefunden');\n            return;\n        }\n\n        // Titel setzen\n        detailTitle.textContent = system.name;\n        detailTitle.setAttribute('data-system-id', system.id);\n\n        // Eingehende und ausgehende Abhängigkeiten finden\n        const incomingDeps = this.data.dependencies.filter(dep => dep.target === system.id);\n        const outgoingDeps = this.data.dependencies.filter(dep => dep.source === system.id);\n\n        let html = `\n        <div class=\"system-detail-card\">\n            <p class=\"mb-1\">${system.description}</p>\n            <div class=\"badge bg-${this.getCategoryClass(system.category)} mb-2\">${system.category}</div>\n            <p><strong>Status:</strong> ${system.status}</p>\n            <p><strong>Bekannte Nutzung:</strong> ${system.knownUsage ? 'Ja' : 'Nein'}</p>\n    `;\n\n        // Gruppen-Information hinzufügen - Multi-Gruppen-Unterstützung\n        const groups = [];\n        if (Array.isArray(system.groups) && system.groups.length > 0) {\n            groups.push(...system.groups);\n        } else if (system.group && typeof system.group === 'string') {\n            groups.push(system.group);\n        }\n\n        if (groups.length > 0) {\n            html += `<p><strong>Gruppen:</strong> ${groups.map(group =>\n                `<span class=\"badge bg-info\">${group}</span>`).join(' ')}</p>`;\n        }\n\n        if (system.tags && system.tags.length > 0) {\n            html += `<p><strong>Tags:</strong> ${system.tags.map(tag =>\n                `<span class=\"badge bg-secondary\">${tag}</span>`).join(' ')}</p>`;\n        }\n\n        if (incomingDeps.length > 0) {\n            html += `<h6 class=\"mt-3\">Eingehende Verbindungen</h6><ul class=\"list-group\">`;\n            incomingDeps.forEach(dep => {\n                const source = this.data.systems.find(s => s.id === dep.source);\n                html += `\n                <li class=\"list-group-item\">\n                    <div class=\"d-flex w-100 justify-content-between\">\n                        <strong>${source ? source.name : 'Unbekannt'}</strong>\n                        <span class=\"badge bg-secondary\">${dep.protocol || 'Unbekannt'}</span>\n                    </div>\n                    <small>${dep.description || 'Keine Beschreibung'}</small>\n                </li>`;\n            });\n            html += `</ul>`;\n        }\n\n        if (outgoingDeps.length > 0) {\n            html += `<h6 class=\"mt-3\">Ausgehende Verbindungen</h6><ul class=\"list-group\">`;\n            outgoingDeps.forEach(dep => {\n                const target = this.data.systems.find(s => s.id === dep.target);\n                html += `\n                <li class=\"list-group-item\">\n                    <div class=\"d-flex w-100 justify-content-between\">\n                        <strong>${target ? target.name : 'Unbekannt'}</strong>\n                        <span class=\"badge bg-secondary\">${dep.protocol || 'Unbekannt'}</span>\n                    </div>\n                    <small>${dep.description || 'Keine Beschreibung'}</small>\n                </li>`;\n            });\n            html += `</ul>`;\n        }\n\n        if (incomingDeps.length === 0 && outgoingDeps.length === 0) {\n            html += `<div class=\"alert alert-warning mt-3\">Dieses System hat keine bekannten Verbindungen.</div>`;\n        }\n\n        html += `</div>`;\n\n        detailsDiv.innerHTML = html;\n\n        // Details-Panel anzeigen\n        detailsPanel.classList.add('active');\n\n        // Button-Zustand anpassen\n        const toggleFixButton = document.querySelector('.toggle-fix-btn');\n        const isFixed = this.isNodeFixed(system.id);\n        if (toggleFixButton) {\n            if (isFixed) {\n                toggleFixButton.classList.add('active');\n                toggleFixButton.title = 'Position freigeben';\n            } else {\n                toggleFixButton.classList.remove('active');\n                toggleFixButton.title = 'Position fixieren';\n            }\n        }\n    }\n\n    /**\n     * Hilfsfunktion zur Ermittlung der Bootstrap-Farbe für Kategorien\n     */\n    getCategoryClass(category) {\n        switch (category) {\n            case 'core': return 'primary';\n            case 'legacy': return 'secondary';\n            case 'data': return 'success';\n            case 'service': return 'warning';\n            case 'external': return 'danger';\n            default: return 'info';\n        }\n    }\n\n    /**\n     * Zeigt eine Fehlermeldung an\n     */\n    showError(message) {\n        const container = document.getElementById(this.containerId);\n        if (container) {\n            container.innerHTML = `<div class=\"alert alert-danger m-3\">${message}</div>`;\n        } else {\n            console.error(message);\n        }\n    }\n\n    /**\n     * Behandelt Größenänderungen des Fensters\n     */\n    handleResize() {\n        const container = document.getElementById(this.containerId);\n        if (container && this.svg) {\n            // Neue Größe erfassen\n            this.width = container.clientWidth;\n            this.height = container.clientHeight;\n\n            // SVG-Größe aktualisieren\n            this.svg\n                .attr(\"width\", this.width)\n                .attr(\"height\", this.height);\n\n            // Simulationsmanager über neue Größe informieren\n            if (this.simulationManager) {\n                this.simulationManager.updateSize(this.width, this.height);\n            }\n        }\n    }\n\n    /**\n     * Fügt Event-Listener für UI-Elemente hinzu\n     */\n    attachEventListeners() {\n        // Filter für Systemkategorien\n        const categoryFilters = document.querySelectorAll('.category-filter');\n        if (categoryFilters.length > 0) {\n            categoryFilters.forEach(filter => {\n                filter.addEventListener('change', () => {\n                    const checkedCategories = Array.from(document.querySelectorAll('.category-filter:checked'))\n                        .map(checkbox => checkbox.value);\n                    this.activeFilters.categories = checkedCategories;\n                });\n            });\n        }\n\n        // Filter für Systemstatus\n        const statusFilters = document.querySelectorAll('.status-filter');\n        if (statusFilters.length > 0) {\n            statusFilters.forEach(filter => {\n                filter.addEventListener('change', () => {\n                    const checkedStatuses = Array.from(document.querySelectorAll('.status-filter:checked'))\n                        .map(checkbox => checkbox.value);\n                    this.activeFilters.knownUsage = checkedStatuses;\n                });\n            });\n        }\n\n        // Filter anwenden\n        const applyFiltersButton = document.getElementById('apply-filters');\n        if (applyFiltersButton) {\n            applyFiltersButton.addEventListener('click', () => {\n                this.applyFilters();\n                document.getElementById('filter-panel').classList.remove('active');\n            });\n        }\n\n        // Suchfeld\n        const searchInput = document.getElementById('system-search');\n        if (searchInput) {\n            searchInput.addEventListener('input', () => this.performSearch(searchInput.value));\n        }\n    }\n\n    /**\n     * Wendet Filter auf die Visualisierung an\n     */\n    applyFilters() {\n        if (this.svg) {\n            this.svg.remove();\n            this.createVisualization();\n            this.setupZoom();\n        }\n    }\n\n    /**\n     * Gibt gefilterte Knoten zurück\n     */\n    getFilteredNodes() {\n        return this.data.systems.filter(system => {\n            // Kategorie-Filter\n            if (!this.activeFilters.categories.includes(system.category)) {\n                return false;\n            }\n\n            // Status-Filter (bekannte/unbekannte Nutzung)\n            const usageType = system.knownUsage ? 'known' : 'unknown';\n            if (!this.activeFilters.knownUsage.includes(usageType)) {\n                return false;\n            }\n\n            return true;\n        }).map(system => ({ ...system }));\n    }\n\n    /**\n     * Führt eine Suche durch und zeigt die Ergebnisse an\n     */\n    performSearch(query) {\n        const resultsContainer = document.getElementById('search-results');\n\n        if (!resultsContainer) {\n            console.error('Suchergebnisse-Container nicht gefunden');\n            return;\n        }\n\n        if (!query || query.trim() === '') {\n            resultsContainer.innerHTML = '';\n            return;\n        }\n\n        const searchTerm = query.toLowerCase().trim();\n\n        // Systeme durchsuchen\n        const results = this.data.systems.filter(system => {\n            return (\n                system.name.toLowerCase().includes(searchTerm) ||\n                system.description.toLowerCase().includes(searchTerm) ||\n                (system.tags && system.tags.some(tag => tag.toLowerCase().includes(searchTerm))) ||\n                (system.group && system.group.toLowerCase().includes(searchTerm)) // Auch in Gruppen suchen\n            );\n        });\n\n        // Ergebnisse anzeigen\n        if (results.length === 0) {\n            resultsContainer.innerHTML = '<div class=\"alert alert-info\">Keine Systeme gefunden.</div>';\n        } else {\n            let html = '';\n\n            results.forEach(system => {\n                html += `\n                    <button class=\"list-group-item list-group-item-action\" data-system-id=\"${system.id}\">\n                        <div class=\"d-flex w-100 justify-content-between\">\n                            <h6 class=\"mb-1\">${system.name}</h6>\n                            <span class=\"badge bg-${this.getCategoryClass(system.category)}\">${system.category}</span>\n                        </div>\n                        <small>${system.description}</small>\n                        ${system.group ? `<br><small><span class=\"badge bg-info\">Gruppe: ${system.group}</span></small>` : ''}\n                    </button>\n                `;\n            });\n\n            resultsContainer.innerHTML = html;\n\n            // Event-Listener für Klicks auf Suchergebnisse\n            const resultItems = resultsContainer.querySelectorAll('.list-group-item');\n            resultItems.forEach(item => {\n                item.addEventListener('click', () => {\n                    const systemId = item.getAttribute('data-system-id');\n                    const system = this.data.systems.find(s => s.id === systemId);\n\n                    if (system) {\n                        this.showSystemDetails(system);\n                        document.getElementById('search-panel').classList.remove('active');\n                    }\n                });\n            });\n        }\n    }\n\n    // Methode zum Speichern des aktuellen Viewports\n    saveViewportState() {\n        if (this.svg) {\n            const currentTransform = d3.zoomTransform(this.svg.node());\n            localStorage.setItem('system_visualizer_transform', JSON.stringify({\n                x: currentTransform.x,\n                y: currentTransform.y,\n                k: currentTransform.k\n            }));\n        }\n    }\n\n    // Methode zum Wiederherstellen des Viewports\n    restoreViewportState() {\n        try {\n            const storedTransform = localStorage.getItem('system_visualizer_transform');\n            if (storedTransform && this.svg && this.zoom) {\n                const t = JSON.parse(storedTransform);\n                const transform = d3.zoomIdentity.translate(t.x, t.y).scale(t.k);\n                this.svg.call(this.zoom.transform, transform);\n            }\n        } catch (e) {\n            console.warn('Fehler beim Wiederherstellen des Viewports:', e);\n        }\n    }\n\n    /**\n     * Deaktiviert die Drag-Funktion für Knoten\n     */\n    disableDrag() {\n        if (this.nodeElements) {\n            this.nodeElements.on('.drag', null);\n        }\n        this.dragDisabled = true;\n    }\n\n    /**\n     * Aktiviert die Drag-Funktion für Knoten wieder\n     */\n    enableDrag() {\n        if (this.nodeElements && this.simulationManager) {\n            this.nodeElements.call(this.simulationManager.createDragBehavior());\n        }\n        this.dragDisabled = false;\n    }\n\n    /**\n     * Fügt einen Event-Listener hinzu\n     * @param {string} event - Der Event-Name (z.B. 'dataChanged')\n     * @param {Function} callback - Die Callback-Funktion\n     */\n    addEventListener(event, callback) {\n        if (this.eventListeners[event]) {\n            this.eventListeners[event].push(callback);\n        }\n    }\n\n    /**\n     * Benachrichtigt alle Listener über ein Event\n     * @param {string} event - Der Event-Name\n     */\n    notifyListeners(event, data) {\n        if (this.eventListeners[event]) {\n            this.eventListeners[event].forEach(callback => callback(data));\n        }\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/visualizer.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;