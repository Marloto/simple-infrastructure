/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _service_data_manager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./service/data-manager.js */ \"./src/service/data-manager.js\");\n/* harmony import */ var _service_history_manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./service/history-manager.js */ \"./src/service/history-manager.js\");\n/* harmony import */ var _service_llm_config_manager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./service/llm-config-manager.js */ \"./src/service/llm-config-manager.js\");\n/* harmony import */ var _service_llm_integration_manager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./service/llm-integration-manager.js */ \"./src/service/llm-integration-manager.js\");\n/* harmony import */ var _ui_components_visualizer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ui/components/visualizer.js */ \"./src/ui/components/visualizer.js\");\n/* harmony import */ var _ui_components_chat_config_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ui/components/chat-config.js */ \"./src/ui/components/chat-config.js\");\n/* harmony import */ var _ui_components_chat_interface_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ui/components/chat-interface.js */ \"./src/ui/components/chat-interface.js\");\n/* harmony import */ var _ui_components_export_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ui/components/export.js */ \"./src/ui/components/export.js\");\n/* harmony import */ var _ui_components_edit_system_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ui/components/edit-system.js */ \"./src/ui/components/edit-system.js\");\n/* harmony import */ var _ui_components_delete_system_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ui/components/delete-system.js */ \"./src/ui/components/delete-system.js\");\n/* harmony import */ var _ui_components_delete_dependency_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ui/components/delete-dependency.js */ \"./src/ui/components/delete-dependency.js\");\n/* harmony import */ var _ui_components_connection_mode_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ui/components/connection-mode.js */ \"./src/ui/components/connection-mode.js\");\n/* harmony import */ var _ui_components_toolbar_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ui/components/toolbar.js */ \"./src/ui/components/toolbar.js\");\n/* harmony import */ var _ui_components_history_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./ui/components/history.js */ \"./src/ui/components/history.js\");\n/* harmony import */ var _ui_components_search_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ui/components/search.js */ \"./src/ui/components/search.js\");\n/* harmony import */ var _ui_components_filter_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./ui/components/filter.js */ \"./src/ui/components/filter.js\");\n/* harmony import */ var _ui_components_legend_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./ui/components/legend.js */ \"./src/ui/components/legend.js\");\n/* harmony import */ var _ui_components_download_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./ui/components/download.js */ \"./src/ui/components/download.js\");\n/* harmony import */ var _ui_components_upload_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./ui/components/upload.js */ \"./src/ui/components/upload.js\");\n/* harmony import */ var _ui_components_reset_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./ui/components/reset.js */ \"./src/ui/components/reset.js\");\n/* harmony import */ var _ui_components_reset_zoom_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./ui/components/reset-zoom.js */ \"./src/ui/components/reset-zoom.js\");\n/* harmony import */ var _ui_components_details_overlay_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./ui/components/details-overlay.js */ \"./src/ui/components/details-overlay.js\");\n/* harmony import */ var _ui_components_multi_select_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./ui/components/multi-select.js */ \"./src/ui/components/multi-select.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndocument.addEventListener('DOMContentLoaded', async () => {\n    // Systemdaten laden und DataManager initialisieren\n    const dataManager = new _service_data_manager_js__WEBPACK_IMPORTED_MODULE_0__.DataManager();\n    console.log('Systemdaten geladen:', dataManager.data);\n\n    // Create HistoryManager for undo/redo functionality\n    const historyManager = new _service_history_manager_js__WEBPACK_IMPORTED_MODULE_1__.HistoryManager(dataManager);\n\n    // LLM-Integration initialisieren (NEU)\n    const llmConfig = new _service_llm_config_manager_js__WEBPACK_IMPORTED_MODULE_2__.LlmConfigManager();\n    const llmManager = new _service_llm_integration_manager_js__WEBPACK_IMPORTED_MODULE_3__.LlmIntegrationManager({\n        apiKey: (await llmConfig.loadLlmApiKey()) || \"\", // API-Key aus localStorage\n        llmType: llmConfig.llmType || \"\", // claude, openai, custom\n        llmModel: llmConfig.llmModel || \"\", // Modell je nach LLM-Typ, e.g. claude-3-7-sonnet-20250219\n        llmSystemPrompt: llmConfig.llmSystemPrompt || \"\", // Modell je nach LLM-Typ, e.g. claude-3-7-sonnet-20250219\n        llmPromptPrefix: llmConfig.llmPromptPrefix || \"\", // Modell je nach LLM-Typ, e.g. claude-3-7-sonnet-20250219\n        llmUrl: llmConfig.llmUrl || \"\", // Nur für custom-Typ\n    });\n    llmManager.initialize(dataManager);\n\n    // UI Components\n    const visualizer = new _ui_components_visualizer_js__WEBPACK_IMPORTED_MODULE_4__.SystemVisualizer('#visualization-container', {dataManager});\n    const toolbar = new _ui_components_toolbar_js__WEBPACK_IMPORTED_MODULE_12__.Toolbar('.controls-overlay', {});\n    const editSystemComponent = new _ui_components_edit_system_js__WEBPACK_IMPORTED_MODULE_8__.EditSystemComponent('body', { dataManager, toolbar });\n    const connectionMode = new _ui_components_connection_mode_js__WEBPACK_IMPORTED_MODULE_11__.ConnectionModeComponent('body', {\n        dataManager, \n        visualizer, \n        toolbar,\n    });\n    const chatConfig = new _ui_components_chat_config_js__WEBPACK_IMPORTED_MODULE_5__.ChatConfig('body', {llmManager, llmConfig});\n    const chatInterface = new _ui_components_chat_interface_js__WEBPACK_IMPORTED_MODULE_6__.ChatInterface('.main-container', { llmManager, chatConfig, toolbar });\n    const deleteSystemComponent = new _ui_components_delete_system_js__WEBPACK_IMPORTED_MODULE_9__.DeleteSystemComponent('body', { dataManager, visualizer });\n\n    const multiSelect = new _ui_components_multi_select_js__WEBPACK_IMPORTED_MODULE_22__.MultiSelectComponent('body', {\n        dataManager,\n        visualizer,\n        toolbar\n    });\n\n    [\n        visualizer,\n        editSystemComponent, \n        connectionMode, \n        chatConfig, \n        chatInterface, \n        deleteSystemComponent, \n        multiSelect,\n        new _ui_components_delete_dependency_js__WEBPACK_IMPORTED_MODULE_10__.DeleteDependencyComponent('body', { dataManager, connectionMode }),\n        new _ui_components_history_js__WEBPACK_IMPORTED_MODULE_13__.HistoryHelper('body', { historyManager, toolbar }),\n        new _ui_components_search_js__WEBPACK_IMPORTED_MODULE_14__.SearchOverlay('.main-container', { toolbar, visualizer, dataManager }),\n        new _ui_components_filter_js__WEBPACK_IMPORTED_MODULE_15__.FilterOverlay('.main-container', { toolbar, visualizer, dataManager }),\n        new _ui_components_legend_js__WEBPACK_IMPORTED_MODULE_16__.LegendOverlay('.main-container', { toolbar, visualizer, dataManager }),\n        new _ui_components_reset_zoom_js__WEBPACK_IMPORTED_MODULE_20__.ResetZoomHelper('.main-container', { toolbar, visualizer }),\n        new _ui_components_export_js__WEBPACK_IMPORTED_MODULE_7__.ExportImage('body', { toolbar }), \n        new _ui_components_upload_js__WEBPACK_IMPORTED_MODULE_18__.UploadHelper('.main-container', { toolbar, dataManager }),\n        new _ui_components_download_js__WEBPACK_IMPORTED_MODULE_17__.DownloadHelper('.main-container', { toolbar, dataManager }),\n        new _ui_components_reset_js__WEBPACK_IMPORTED_MODULE_19__.ResetData('body', { toolbar, dataManager, llmConfig, llmManager, chatInterface, visualizer }),\n        new _ui_components_details_overlay_js__WEBPACK_IMPORTED_MODULE_21__.DetailsOverlay('.main-container', { dataManager, visualizer, editSystemComponent, deleteSystemComponent }),\n    ].forEach(component => {\n        component.initialize();\n    });\n});\n\n//# sourceURL=webpack://infravis/./src/index.js?");

/***/ }),

/***/ "./src/service/data-manager.js":
/*!*************************************!*\
  !*** ./src/service/data-manager.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataManager: () => (/* binding */ DataManager)\n/* harmony export */ });\n/* harmony import */ var _utils_event_emitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/event-emitter.js */ \"./src/utils/event-emitter.js\");\n/* harmony import */ var _utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utilities.js */ \"./src/utils/utilities.js\");\n\n\n\n/**\n * Loads the system data from the YAML file\n * @returns {Promise<Object>} The parsed data object\n */\nfunction loadSystemData() {\n    try {\n        // Load YAML file\n        const yamlText = localStorage.getItem('systems_yaml');\n        if (!yamlText) {\n            throw new Error('Could not load system data from local storage');\n        }\n\n        // Parse YAML to JavaScript object\n        const parsedData = jsyaml.load(yamlText);\n\n        return parsedData;\n    } catch (error) {\n        console.log('Could not load data, fallback to new data set', error);\n        return {\n            systems: [],\n            dependencies: []\n        };\n    }\n}\n\n/**\n * Saves the system data as YAML in local storage\n * @param {Object} data - The system data to save\n */\nfunction saveSystemData(data) {\n    try {\n        const yamlText = jsyaml.dump(data);\n        localStorage.setItem('systems_yaml', yamlText);\n        console.log('Data saved successfully');\n    } catch (error) {\n        console.error('Error saving data:', error);\n        (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)('Error saving data', 'danger');\n    }\n}\n\n\n/**\n * DataManager - Central class for managing system data\n * Serves as the single source of truth for all other components\n */\nclass DataManager extends _utils_event_emitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor() {\n        super();\n        this.data = loadSystemData();\n        let saveTimeout = null;\n        this.on('dataChanged', () => {\n            if (saveTimeout) clearTimeout(saveTimeout);\n            saveTimeout = setTimeout(() => {\n                saveSystemData(this.data);\n                saveTimeout = null;\n            }, 500);\n        });\n    }\n\n    /**\n     * Initializes the DataManager with data\n     * @param {Object} data - The initial system data\n     */\n    initialize(data) {\n        if (data && data.systems && data.dependencies) {\n            this.data = data;\n        }\n        this.emit('dataChanged', this.data);\n    }\n\n    /**\n     * Returns the current system data\n     * @returns {Object} The system data\n     */\n    getData() {\n        return this.data;\n    }\n\n    /**\n     * Completely updates the system data\n     * @param {Object} newData - The new system data\n     */\n    setData(newData, notify = true) {\n        if (newData && newData.systems && newData.dependencies) {\n            this.data = newData;\n            notify && this.emit('dataChanged', this.data);\n        }\n    }\n\n    /**\n     * Completely removes the system data\n     * @param {Object} newData - The new system data\n     */\n    clearData(notify = true) {\n        this.setData({ systems: [], dependencies: [] }, notify);\n    }\n\n    /**\n     * Returns all unique groups present in the system data\n     * @returns {Array} Array of unique group names\n     */\n    getAllGroups() {\n        const groups = new Set();\n\n        this.data.systems.forEach(system => {\n            if (Array.isArray(system.groups)) {\n                system.groups.forEach(group => {\n                    if (group && group.trim() !== '') {\n                        groups.add(group);\n                    }\n                });\n            } else if (system.group && typeof system.group === 'string') {\n                groups.add(system.group);\n            }\n        });\n\n        return Array.from(groups).sort();\n    }\n\n    /**\n     * Helper function to ensure each system has a 'groups' array\n     * Converts single 'group' strings to arrays if necessary (backward compatibility)\n     * @param {Object} system - The system to check\n     */\n    ensureGroupsArray(system) {\n        // Case 1: system already has a groups array -> do nothing\n        if (Array.isArray(system.groups)) {\n            // Remove empty values and duplicates\n            system.groups = system.groups\n                .filter(group => group && group.trim() !== '')\n                .filter((group, index, self) => self.indexOf(group) === index);\n\n            // Remove legacy group field if present\n            delete system.group;\n            return;\n        }\n\n        // Case 2: system has a group field -> convert to groups array\n        if (typeof system.group === 'string' && system.group.trim() !== '') {\n            // If group is a comma-separated string, split\n            if (system.group.includes(',')) {\n                system.groups = system.group.split(',')\n                    .map(g => g.trim())\n                    .filter(g => g !== '');\n            } else {\n                system.groups = [system.group];\n            }\n            delete system.group;\n            return;\n        }\n\n        // Case 3: system has neither group nor groups\n        if (!system.groups) {\n            system.groups = [];\n            delete system.group; // Ensure no empty group field exists\n        }\n    }\n\n    /**\n     * Adds a new system\n     * @param {Object} system - The new system\n     * @returns {string} The ID of the added system\n     */\n    addSystem(system, notify = true) {\n        if (!system.id) {\n            system.id = this.generateUniqueId();\n        }\n\n        // Compatibility handling for converting 'group' to 'groups'\n        this.ensureGroupsArray(system);\n\n        this.data.systems.push(system);\n        notify && this.emit('dataChanged', this.data);\n        return system.id;\n    }\n\n    /**\n     * Updates an existing system\n     * @param {Object} updatedSystem - The updated system\n     * @returns {boolean} True if the system was found and updated\n     */\n    updateSystem(updatedSystem, notify = true) {\n        const index = this.data.systems.findIndex(sys => sys.id === updatedSystem.id);\n        if (index !== -1) {\n            // Compatibility handling for converting 'group' to 'groups'\n            this.ensureGroupsArray(updatedSystem);\n\n            this.data.systems[index] = updatedSystem;\n            notify && this.emit('dataChanged', this.data);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Deletes a system and associated dependencies\n     * @param {string} systemId - The ID of the system to delete\n     * @returns {boolean} True if the system was found and deleted\n     */\n    deleteSystem(systemId, notify = true) {\n        const systemIndex = this.data.systems.findIndex(sys => sys.id === systemId);\n        if (systemIndex === -1) return false;\n\n        // Delete system\n        this.data.systems.splice(systemIndex, 1);\n\n        // Delete associated dependencies\n        this.data.dependencies = this.data.dependencies.filter(\n            dep => dep.source !== systemId && dep.target !== systemId\n        );\n\n        notify && this.emit('dataChanged', this.data);\n        return true;\n    }\n\n    /**\n     * Adds a new dependency\n     * @param {Object} dependency - The new dependency\n     * @returns {boolean} True on success\n     */\n    addDependency(dependency, notify = true) {\n        // Check if source and target systems exist\n        const sourceExists = this.data.systems.some(sys => sys.id === dependency.source);\n        const targetExists = this.data.systems.some(sys => sys.id === dependency.target);\n\n        if (!sourceExists || !targetExists) return false;\n\n        this.data.dependencies.push(dependency);\n        notify && this.emit('dataChanged', this.data);\n        return true;\n    }\n\n    /**\n     * Deletes a dependency\n     * @param {Object} dependency - The dependency to delete (must contain source and target)\n     * @returns {boolean} True if the dependency was found and deleted\n     */\n    deleteDependency(dependency, notify = true) {\n        const index = this.data.dependencies.findIndex(\n            dep => dep.source === dependency.source && dep.target === dependency.target\n        );\n\n        if (index !== -1) {\n            this.data.dependencies.splice(index, 1);\n            notify && this.emit('dataChanged', this.data);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Applies a batch of changes at once and triggers only a single update event\n     * @param {Object} differences - Object with added, modified and removed arrays for systems and dependencies\n     * @returns {boolean} True on success\n     */\n    applyBatch(differences) {\n        if (!differences) return false;\n\n        try {\n            // Remove systems\n            if (differences.removed && differences.removed.systems) {\n                differences.removed.systems.forEach(system => {\n                    this.deleteSystem(system.id, false);\n                });\n            }\n\n            // Update systems\n            if (differences.modified && differences.modified.systems) {\n                differences.modified.systems.forEach(modifiedSystem => {\n                    this.updateSystem(modifiedSystem, false);\n                });\n            }\n\n            // Add new systems\n            if (differences.added && differences.added.systems) {\n                differences.added.systems.forEach(newSystem => {\n                    this.addSystem(newSystem, false);\n                });\n            }\n\n            // Remove dependencies\n            if (differences.removed && differences.removed.dependencies) {\n                differences.removed.dependencies.forEach(dependency => {\n                    this.deleteDependency(dependency, false);\n                });\n            }\n\n            // Update dependencies\n            if (differences.modified && differences.modified.dependencies) {\n                differences.modified.dependencies.forEach(modifiedDep => {\n                    // Delete and re-add, since updateDependency does not exist\n                    this.deleteDependency(modifiedDep, false);\n                    this.addDependency(modifiedDep, false);\n                });\n            }\n\n            // Add new dependencies\n            if (differences.added && differences.added.dependencies) {\n                differences.added.dependencies.forEach(newDep => {\n                    this.addDependency(newDep, false);\n                });\n            }\n\n            // Notify all listeners only once\n            this.emit('dataChanged', this.data);\n\n            return true;\n        } catch (error) {\n            console.error(\"Error applying batch changes:\", error);\n            return false;\n        }\n    }\n\n    /**\n     * Generates a unique ID\n     * @returns {string} A unique ID\n     */\n    generateUniqueId() {\n        const timestamp = new Date().getTime();\n        const randomPart = Math.floor(Math.random() * 10000);\n        return `sys_${timestamp}_${randomPart}`;\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/service/data-manager.js?");

/***/ }),

/***/ "./src/service/history-manager.js":
/*!****************************************!*\
  !*** ./src/service/history-manager.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HistoryManager: () => (/* binding */ HistoryManager)\n/* harmony export */ });\n/* harmony import */ var _utils_event_emitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/event-emitter.js */ \"./src/utils/event-emitter.js\");\n/* harmony import */ var _utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utilities.js */ \"./src/utils/utilities.js\");\n\n\n\n/**\n * HistoryManager \n */\nclass HistoryManager extends _utils_event_emitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter{\n    constructor(dataManager, options = {}) {\n        super();\n        this.dataManager = dataManager;\n        this.options = {\n            maxHistorySize: options.maxHistorySize || 50,\n            debounceTime: options.debounceTime || 500,\n            ...options\n        };\n\n        // History stacks\n        this.undoStack = [];  // Enthält VERGANGENE Zustände\n        this.redoStack = [];  // Enthält ZUKÜNFTIGE Zustände\n        \n        // State tracking\n        this.debounceTimer = null;\n        this.isPerformingHistoryOperation = false;\n        this.lastSavedState = null; // Für Vergleich\n\n        this.initialize();\n    }\n\n    initialize() {\n        // Initialen Zustand speichern\n        this.saveInitialState();\n\n        // WICHTIG: Wir speichern VOR Änderungen, nicht nach!\n        this.dataManager.on('dataChanged', () => {\n            if (this.isPerformingHistoryOperation) return;\n            \n            // Wenn das Event gefeuert wird, sind die Daten bereits geändert\n            // Aber wir haben noch den alten Zustand in lastSavedState\n            // Der gehört jetzt in den undoStack!\n            this.handleDataChanged();\n        });\n\n        this.setupKeyboardShortcuts();\n    }\n\n    /**\n     * Speichert den initialen Zustand\n     */\n    saveInitialState() {\n        this.lastSavedState = this.deepClone(this.dataManager.getData());\n        this.emit('historyUpdated');\n    }\n\n    /**\n     * Wird aufgerufen wenn sich Daten geändert haben\n     * Zu diesem Zeitpunkt sind die Daten bereits NEU, aber lastSavedState ist ALT\n     */\n    handleDataChanged() {\n        // Clear debounce timer falls vorhanden\n        if (this.debounceTimer) {\n            clearTimeout(this.debounceTimer);\n        }\n\n        // Debounced handling\n        this.debounceTimer = setTimeout(() => {\n            this.processPendingChange();\n        }, this.options.debounceTime);\n    }\n\n    /**\n     * Verarbeitet eine ausstehende Änderung\n     */\n    processPendingChange() {\n        const currentData = this.dataManager.getData();\n        \n        // Nichts zu tun wenn keine Änderung\n        if (this.lastSavedState && this.areStatesEqual(this.lastSavedState, currentData)) {\n            return;\n        }\n\n        // Den ALTEN Zustand (vor der Änderung) in den undoStack\n        if (this.lastSavedState) {\n            const undoSnapshot = {\n                data: this.deepClone(this.lastSavedState),\n                timestamp: Date.now()\n            };\n\n            this.undoStack.push(undoSnapshot);\n\n            // Redo-Stack leeren\n            this.redoStack = [];\n\n            // Stack-Größe begrenzen\n            if (this.undoStack.length > this.options.maxHistorySize) {\n                this.undoStack.shift();\n            }\n        }\n\n        // Neuen aktuellen Zustand für nächstes Mal merken\n        this.lastSavedState = this.deepClone(currentData);\n        \n        this.emit('historyUpdated');\n        console.log(`State change processed (${this.undoStack.length} undo states)`);\n    }\n\n    /**\n     * Undo - Zum vorherigen Zustand zurückkehren\n     */\n    undo() {\n        if (!this.canUndo()) {\n            console.warn('Cannot undo: no previous states');\n            return false;\n        }\n\n        // Pending operations canceln\n        if (this.debounceTimer) {\n            clearTimeout(this.debounceTimer);\n            this.debounceTimer = null;\n        }\n\n        // Aktuellen Zustand zu Redo-Stack hinzufügen\n        const currentData = this.dataManager.getData();\n        const redoSnapshot = {\n            data: this.deepClone(currentData),\n            timestamp: Date.now()\n        };\n        this.redoStack.push(redoSnapshot);\n\n        // Vorherigen Zustand vom undoStack holen\n        const previousSnapshot = this.undoStack.pop();\n\n        // Zustand anwenden\n        this.isPerformingHistoryOperation = true;\n        this.dataManager.setData(previousSnapshot.data, true);\n        this.lastSavedState = this.deepClone(previousSnapshot.data); // Wichtig: auch lastSavedState updaten\n        this.isPerformingHistoryOperation = false;\n\n        this.emit('historyUpdated');\n        return true;\n    }\n\n    /**\n     * Redo - Zum nächsten Zustand vorwärts gehen\n     */\n    redo() {\n        if (!this.canRedo()) {\n            console.warn('Cannot redo: no future states');\n            return false;\n        }\n\n        // Pending operations canceln\n        if (this.debounceTimer) {\n            clearTimeout(this.debounceTimer);\n            this.debounceTimer = null;\n        }\n\n        // Aktuellen Zustand zu Undo-Stack hinzufügen\n        const currentData = this.dataManager.getData();\n        const undoSnapshot = {\n            data: this.deepClone(currentData),\n            timestamp: Date.now()\n        };\n        this.undoStack.push(undoSnapshot);\n\n        // Nächsten Zustand vom redoStack holen\n        const nextSnapshot = this.redoStack.pop();\n\n        // Zustand anwenden\n        this.isPerformingHistoryOperation = true;\n        this.dataManager.setData(nextSnapshot.data, true);\n        this.lastSavedState = this.deepClone(nextSnapshot.data); // Wichtig: auch lastSavedState updaten\n        this.isPerformingHistoryOperation = false;\n\n        this.emit('historyUpdated');\n        return true;\n    }\n\n    /**\n     * Prüft ob Undo möglich ist\n     */\n    canUndo() {\n        return this.undoStack.length > 0;\n    }\n\n    /**\n     * Prüft ob Redo möglich ist\n     */\n    canRedo() {\n        return this.redoStack.length > 0;\n    }\n\n    /**\n     * Löscht komplette History\n     */\n    clearHistory() {\n        this.undoStack = [];\n        this.redoStack = [];\n        this.lastSavedState = this.deepClone(this.dataManager.getData());\n        this.emit('historyUpdated');\n        console.log('History cleared');\n    }\n\n    /**\n     * Deep Clone eines Objekts\n     */\n    deepClone(obj) {\n        if (obj === null || typeof obj !== 'object') return obj;\n        if (obj instanceof Date) return new Date(obj.getTime());\n        if (Array.isArray(obj)) return obj.map(item => this.deepClone(item));\n        \n        const cloned = {};\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                cloned[key] = this.deepClone(obj[key]);\n            }\n        }\n        return cloned;\n    }\n\n    /**\n     * Vergleicht zwei Zustände auf Gleichheit\n     */\n    areStatesEqual(state1, state2) {\n        return JSON.stringify(state1) === JSON.stringify(state2);\n    }\n\n    /**\n     * Keyboard Shortcuts einrichten\n     */\n    setupKeyboardShortcuts() {\n        document.addEventListener('keydown', (event) => {\n            if ((event.ctrlKey || event.metaKey) && event.key === 'z' && !event.shiftKey) {\n                event.preventDefault();\n                this.undo();\n                return;\n            }\n\n            if (((event.ctrlKey || event.metaKey) && event.shiftKey && event.key === 'Z') ||\n                (event.ctrlKey && event.key === 'y')) {\n                event.preventDefault();\n                this.redo();\n                return;\n            }\n        });\n    }\n\n    /**\n     * Debug Info - zeigt den aktuellen Zustand\n     */\n    getDebugInfo() {\n        return {\n            undoStackSize: this.undoStack.length,\n            redoStackSize: this.redoStack.length,\n            canUndo: this.canUndo(),\n            canRedo: this.canRedo(),\n            currentDataHash: JSON.stringify(this.dataManager.getData()).substring(0, 50) + '...',\n            lastSavedStateHash: this.lastSavedState ? JSON.stringify(this.lastSavedState).substring(0, 50) + '...' : 'null'\n        };\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/service/history-manager.js?");

/***/ }),

/***/ "./src/service/llm-config-manager.js":
/*!*******************************************!*\
  !*** ./src/service/llm-config-manager.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LlmConfigManager: () => (/* binding */ LlmConfigManager)\n/* harmony export */ });\n/* harmony import */ var _utils_utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utilities.js */ \"./src/utils/utilities.js\");\n\nclass LlmConfigManager {\n    get llmType() {\n        return localStorage.getItem(\"llmType\") || \"claude\";\n    }\n\n    set llmType(value) {\n        localStorage.setItem(\"llmType\", value);\n    }\n\n    async hasLlmApiKey() {\n        return !!localStorage.getItem(\"llmApiKey\");\n    }\n\n    async loadLlmApiKey() {\n        return await (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_0__.retrieveAndDecrypt)(\"llmApiKey\");\n    }\n\n    async updateLlmApiKey(value) {\n        return await (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_0__.encryptAndStore)(\"llmApiKey\", value);\n    }\n\n    get llmModel() {\n        return localStorage.getItem(\"llmModel\") || \"\";\n    }\n\n    set llmModel(value) {\n        localStorage.setItem(\"llmModel\", value);\n    }\n\n    get llmSystemPrompt() {\n        return localStorage.getItem(\"llmSystemPrompt\") || this.getDefaultSystemPrompt();\n    }\n\n    set llmSystemPrompt(value) {\n        localStorage.setItem(\"llmSystemPrompt\", value);\n    }\n\n    get llmPromptPrefix() {\n        return localStorage.getItem(\"llmPromptPrefix\") || this.getDefaultPromptPrefix();\n    }\n\n    set llmPromptPrefix(value) {\n        localStorage.setItem(\"llmPromptPrefix\", value);\n    }\n\n    get llmUrl() {\n        return localStorage.getItem(\"llmUrl\") || \"\";\n    }\n\n    set llmUrl(value) {\n        localStorage.setItem(\"llmUrl\", value);\n    }\n\n    reset() {\n        localStorage.removeItem(\"llmType\");\n        localStorage.removeItem(\"llmModel\");\n        localStorage.removeItem(\"llmSystemPrompt\");\n        localStorage.removeItem(\"llmPromptPrefix\");\n        localStorage.removeItem(\"llmApiKey\");\n        localStorage.removeItem(\"llmUrl\");\n    }\n\n    /**\n     * Returns the default system prompt\n     * @returns {string} The default system prompt\n     */\n    getDefaultSystemPrompt() {\n        const isGerman = typeof navigator !== \"undefined\" && navigator.language && navigator.language.startsWith(\"de\");\n        if (isGerman) {\n            return `Du bist ein Infrastruktur-Assistent, der dabei hilft, IT-Systeme und deren Abhängigkeiten zu verwalten. IT-Systeme bestehen aus id, name, description, category, status, knownUsage, groups (array, optional) und tags (array, optional). Abhängigkeiten zwischen Systemen haben die Attribute source, target, type, description und protocol. Du analysierst Benutzeranfragen und wandelst sie in strukturierte YAML-Definitionen um.\n\nAkzeptable Kategorien (category) für Systeme sind:\n- core: Zentrale Systeme\n- legacy: Veraltete Systeme\n- data: Datenspeicher und -verarbeitung\n- service: Dienste und Anwendungen\n- external: Externe Systeme\n\nVerbindungstypen (type) zwischen Systemen können sein:\n- data: Datenaustausch\n- integration: Systemintegration\n- authentication: Authentifizierung\n- monitoring: Überwachung\n\nStatus-Werte (status) für Systeme:\n- active: Aktiv im Einsatz\n- planned: Geplant\n- deprecated: Veraltet\n- retired: Außer Betrieb\n\nWenn der Benutzer dich bittet, die Infrastruktur zu ändern (z.B. Systeme hinzuzufügen, zu bearbeiten oder zu löschen), \nantworte mit den neuen, geänderten und gelöschten Elementen in der YAML-Struktur. Gelöschte Elemente werden mit dem Attribut \\`delete: true\\` markiert. \nFüge keine Erklärungen innerhalb des YAML-Blocks hinzu.\n\nHalte dich an dieses Format:\n\n{{dataStructure}}\n\nWenn du nach allgemeinen Informationen über die Infrastrukturvisualisierung gefragt wirst, \nantworte mit hilfreichen Erklärungen, ohne YAML zurückzugeben.`;\n        } else {\n            return `You are an infrastructure assistant that helps manage IT systems and their dependencies. IT systems consist of id, name, description, category, status, knownUsage, groups (array, optional), and tags (array, optional). Dependencies between systems have the attributes source, target, type, description, and protocol. You analyze user requests and convert them into structured YAML definitions.\n\nAcceptable categories (category) for systems are:\n- core: Core systems\n- legacy: Legacy systems\n- data: Data storage and processing\n- service: Services and applications\n- external: External systems\n\nConnection types (type) between systems can be:\n- data: Data exchange\n- integration: System integration\n- authentication: Authentication\n- monitoring: Monitoring\n\nStatus values (status) for systems:\n- active: Active in use\n- planned: Planned\n- deprecated: Deprecated\n- retired: Retired\n\nIf the user asks you to change the infrastructure (e.g., add, edit, or delete systems), \nrespond with the new, changed, and deleted elements in the YAML structure. Deleted elements are marked with the attribute \\`delete: true\\`. \nDo not include explanations inside the YAML block.\n\nStick to this format:\n\n{{dataStructure}}\n\nIf you are asked general questions about infrastructure visualization, \nrespond with helpful explanations without returning YAML.`;\n        }\n    }\n\n    /**\n     * Creates the default prompt header, use {{currentData}}, {{userInput}} and {{example}} as placeholders\n     * \n     * @returns {string} - The formatted message with context\n     */\n    getDefaultPromptPrefix() {\n        const isGerman = typeof navigator !== \"undefined\" && navigator.language && navigator.language.startsWith(\"de\");\n        if (isGerman) {\n            return `\nHier ist die aktuelle YAML-Darstellung der Infrastruktur:\n\n{{currentData}}\n\nBenutzeranfrage:\n\n{{userInput}}\n\nWenn du Änderungen an der Infrastruktur vornehmen sollst, gib die neuen, aktualisierten oder zu löschenden Elemente in YAML im folgenden Format zurück:\n\n{{example}}\n\nWenn keine Änderungen erforderlich sind, antworte mit normaler Konversation. Gib YAML immer im korrekten Markdown-Codeblock zurück.\n`;\n        } else {\n            return `\nHere is the current YAML representation of the infrastructure:\n\n{{currentData}}\n\nUser request:\n\n{{userInput}}\n\nIf you are asked to make changes to the infrastructure, return the new, updated, or deleted elements in YAML using the following format:\n\n{{example}}\n\nIf no changes are required, respond with a normal conversation. Always return YAML in a correct Markdown code block.\n`;\n        }\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/service/llm-config-manager.js?");

/***/ }),

/***/ "./src/service/llm-integration-manager.js":
/*!************************************************!*\
  !*** ./src/service/llm-integration-manager.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LlmIntegrationManager: () => (/* binding */ LlmIntegrationManager)\n/* harmony export */ });\n/* harmony import */ var _utils_completion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/completion.js */ \"./src/utils/completion.js\");\n/* harmony import */ var _utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utilities.js */ \"./src/utils/utilities.js\");\n\n\n\n/**\n * LlmIntegrationManager - Manages the integration of an LLM into the system visualization.\n * Focuses on the core functionality of LLM communication and data model updates.\n */\nclass LlmIntegrationManager {\n    constructor(options = {}) {\n        this.dataManager = null;\n        this.initialized = false;\n        this.isProcessing = false;\n\n        // Configuration with default values\n        this.config = {\n            apiKey: options.apiKey || \"\",\n            llmType: options.llmType || \"\", // claude, openai, custom\n            llmModel: options.llmModel || \"\", // like claude-3-7-sonnet-20250219\n            llmUrl: options.llmUrl || \"\", // Only needed for custom\n            systemPrompt: options.systemPrompt || \"\",\n            promptPrefix: options.promptPrefix || \"\",\n            onMessageReceived: options.onMessageReceived || null,\n            onTyping: options.onTyping || null\n        };\n    }\n\n    /**\n     * Updates the LLM integration configuration with the provided parameters.\n     *\n     * @param {string} llmType - The type of the language model (e.g., 'openai', 'anthropic').\n     * @param {string} llmModel - The specific model to use (e.g., 'gpt-4', 'claude-2').\n     * @param {string} llmApiKey - The API key for authenticating requests to the LLM service.\n     * @param {string} [llmSystemPrompt] - Optional system prompt to use; defaults to the class's default if not provided.\n     * @param {string} [llmPromptPrefix] - Optional prefix to prepend to prompts; defaults to an empty string if not provided.\n     */\n    updateConfig(llmType = undefined, llmModel = undefined, llmApiKey = undefined, llmSystemPrompt = undefined, llmPromptPrefix = undefined, llmUrl = undefined) {\n        this.config.llmType = llmType;\n        this.config.llmModel = llmModel;\n        this.config.apiKey = llmApiKey;\n        this.config.systemPrompt = llmSystemPrompt || \"\";\n        this.config.promptPrefix = llmPromptPrefix || \"\";\n        this.config.llmUrl = llmUrl;;\n\n        if(this.isConfigurated()) {\n            this.createLlmGenerator();\n        }\n    }\n\n    /**\n     * Checks if the configuration is complete by verifying the presence of\n     * `apiKey`, `llmType`, and `llmModel` properties in the config object.\n     *\n     * @returns {boolean} Returns `true` if all required configuration properties are set; otherwise, `false`.\n     */\n    isConfigurated() {\n        return this.config.apiKey && this.config.llmType && this.config.llmModel && (this.config.llmType !== \"custom\" || this.config.llmUrl);\n    }\n\n    /**\n     * Initializes the LlmIntegrationManager\n     * @param {DataManager} dataManager - The DataManager for data management\n     */\n    initialize(dataManager) {\n        if (this.initialized) return;\n\n        if (!dataManager) {\n            console.error(\"No DataManager provided\");\n            return;\n        }\n\n        this.dataManager = dataManager;\n\n        this.initialized = true;\n    }\n\n    /**\n     * Creates the LLM generator based on the configuration\n     */\n    createLlmGenerator() {\n        const variables = {\n            example: this.getExampleDataAsPromptBlock(),\n            dataStructure: this.getDataStructureAsPromptBlock()\n        };\n\n        // Create generator using the createGenerator function\n        const generator = (0,_utils_completion_js__WEBPACK_IMPORTED_MODULE_0__.createGenerator)(\n            variables,\n            this.config.systemPrompt || \"\",\n            this.config.promptPrefix || \"\",\n            {\n                llmType: this.config.llmType,\n                llmModel: this.config.llmModel,\n                llmApiKey: this.config.apiKey,\n                llmUrl: this.config.llmUrl\n            }\n        );\n\n        if (!generator) {\n            console.error(\"Error creating the LLM generator\");\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(\"LLM integration could not be initialized\", \"danger\");\n        }\n\n        return generator;\n    }\n\n    /**\n     * Processes a user request and sends it to the LLM\n     * @param {string} userInput - The user input\n     * @returns {Promise<Object>} - Processing result with response and data changes\n     */\n    async processUserInput(userInput, callback) {\n        if (!this.isConfigurated()) {\n            return { success: false, message: \"Missing configuration for connecting to ChatBot provider\" };\n        }\n\n        let generator;\n        try {\n            generator = this.createLlmGenerator();\n        } catch (error) {\n            console.error(\"Error creating the LLM generator:\", error);\n            return { success: false, message: \"Error creating the LLM generator\" };\n        }\n\n        if (!userInput || this.isProcessing) {\n            return { success: false, message: \"Input cannot be processed\" };\n        }\n\n        this.isProcessing = true;\n        let result = {\n            success: false,\n            message: \"\",\n            originalResponse: \"\",\n            yamlData: null,\n            differences: null\n        };\n\n        try {\n            // Aktuelle Daten vorbereiten\n            const currentData = this.dataManager.getData();\n\n            // Nachricht an das LLM senden\n            generator.attachMessageAsUserUsingPrefix({\n                userInput: userInput,\n                currentData: this.getCurrentDataAsPromptBlock(currentData),\n                example: this.getExampleDataAsPromptBlock(),\n            });\n\n            // Stream-Antwort verarbeiten\n            const response = await (0,_utils_completion_js__WEBPACK_IMPORTED_MODULE_0__.handleSse)(\n                generator,\n                (error, token) => {\n                    if (error) {\n                        console.error(\"Stream-Error:\", error);\n                        return;\n                    }\n\n                    // Token an Handler übergeben, falls definiert\n                    if (this.config.onTyping && token) {\n                        this.config.onTyping(token);\n                    }\n                    if (callback && token) {\n                        callback(token);\n                    }\n                }\n            );\n\n            // Vollständige Antwort speichern\n            result.originalResponse = response;\n            generator.attachMessageAsAssistant(response);\n\n            // Antwort parsen und YAML extrahieren\n            const yamlContent = this.extractYamlFromResponse(response);\n\n            if (yamlContent) {\n                try {\n                    // YAML parsen\n                    const parsedData = jsyaml.load(yamlContent);\n\n                    // Daten validieren\n                    if (this.validateSystemData(parsedData)) {\n                        result.yamlData = parsedData;\n\n                        // Unterschiede berechnen\n                        result.differences = this.calculateDifferences(currentData, parsedData);\n                        result.success = true;\n                    } else {\n                        result.message = \"The YAML structure is invalid\";\n                    }\n                } catch (error) {\n                    console.error(\"Error parsing the YAML response:\", error);\n                    result.message = \"The YAML response could not be processed\";\n                }\n            } else {\n                // Normale Konversation ohne YAML-Änderungen\n                result.success = true;\n                result.message = \"No infrastructure changes detected\";\n            }\n\n            // Falls ein Callback für empfangene Nachrichten definiert ist, diesen aufrufen\n            if (this.config.onMessageReceived) {\n                this.config.onMessageReceived(result);\n            }\n\n            return result;\n        } catch (error) {\n            console.error(\"Error during LLM processing:\", error);\n            result.message = \"An error occurred during processing\";\n            return result;\n        } finally {\n            this.isProcessing = false;\n        }\n    }\n\n    /**\n     * Erstellt einen YAML-Markdown-Block für die aktuelle Infrastruktur\n     * @param {Object} currentData - Aktuelle Infrastrukturdaten\n     * @returns {string} - Die formatierte Nachricht mit Kontext\n     */\n    getCurrentDataAsPromptBlock(currentData) {\n        return `\n\\`\\`\\`yaml\nsystems:\n${currentData.systems.map(sys => `  - id: ${sys.id}\n    name: ${sys.name}\n    description: ${sys.description}\n    category: ${sys.category}${this.formatGroups(sys)}\n    status: ${sys.status}\n    knownUsage: ${sys.knownUsage}${sys.tags && sys.tags.length > 0 ? `\\n    tags:\\n${sys.tags.map(tag => `      - ${tag}`).join('\\n')}` : ''}\n`).join('\\n')}\n\ndependencies:\n${currentData.dependencies.map(dep => `  - source: ${dep.source}\n    target: ${dep.target}\n    type: ${dep.type}\n    description: ${dep.description || 'No Description'}\n    protocol: ${dep.protocol || 'API'}\n`).join('\\n')}\n\\`\\`\\`\n`;\n    }\n\n    /**\n     * Erstellt einen YAML-Markdown-Block als Beispiel für den Prompt\n     * @returns {string} - Die formatierte Nachricht mit Kontext\n     */\n    getDataStructureAsPromptBlock() {\n        return `\n\\`\\`\\`yaml\nsystems:\n  - id: systemId\n    name: System Name\n    description: Description for the system\n    category: core/legacy/data/service/external\n    groups:\n      - gruppe1\n      - gruppe2\n    status: active/planned/deprecated/retired\n    knownUsage: true/false\n    delete: true/false\n    tags:\n      - tag1\n      - tag2\n\ndependencies:\n  - source: sourceSystemId\n    target: targetSystemId\n    type: data/integration/authentication/monitoring\n    description: Description for the dependency\n    delete: true/false\n    protocol: Name of Protocol\n\\`\\`\\`\n`;\n    }\n\n    /**\n     * Creates a YAML markdown block as an example for the prompt\n     * @returns {string} - The formatted message with context\n     */\n    getExampleDataAsPromptBlock() {\n        return `\n\\`\\`\\`yaml\nsystems:\n  - id: system1\n    name: System Name\n    description: Some description for the system\n    category: core\n    groups:\n      - group1\n      - group2\n    status: active\n    delete: false\n    knownUsage: true\n\ndependencies:\n  - source: system1\n    target: system2\n    type: data\n    description: Some description for the dependency\n    delete: false\n    protocol: Protocol\n\\`\\`\\`\n`;\n    }\n    /**\n     * Helper function to format the groups information for the YAML representation\n     * @param {Object} system - The system object\n     * @returns {string} - Formatted groups information\n     */\n    formatGroups(system) {\n        let groupsText = '';\n\n        // System has a groups array with entries\n        if (Array.isArray(system.groups) && system.groups.length > 0) {\n            groupsText = '\\n    groups:';\n            system.groups.forEach(group => {\n                groupsText += `\\n      - ${group}`;\n            });\n        }\n\n        return groupsText;\n    }\n\n    /**\n     * Applies data changes to the data model\n     * @param {Object} differences - The changed data\n     * @returns {boolean} - True on success\n     */\n    applyChanges(differences) {\n        try {\n            // Update data in the DataManager\n            this.dataManager.applyBatch(differences);\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(\"Changes have been successfully applied\", \"success\");\n            return true;\n        } catch (error) {\n            console.error(\"Error applying changes:\", error);\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(\"Error applying changes\", \"danger\");\n            return false;\n        }\n    }\n\n    /**\n     * Calculates the differences between two data models\n     * @param {Object} currentData - Current data\n     * @param {Object} newData - New data\n     * @returns {Object} Differences (added, modified, removed)\n     */\n    calculateDifferences(currentData, newData) {\n        const differences = {\n            added: {\n                systems: [],\n                dependencies: []\n            },\n            modified: {\n                systems: [],\n                dependencies: []\n            },\n            removed: {\n                systems: [],\n                dependencies: []\n            }\n        };\n\n        // Compare systems\n        const currentSystemIds = new Set(currentData.systems.map(s => s.id));\n\n        // Added and removed systems\n        newData.systems.forEach(newSystem => {\n            // Removed systems\n            if (newSystem.delete) {\n                differences.removed.systems.push(newSystem);\n                return;\n            }\n            if (!currentSystemIds.has(newSystem.id)) {\n                differences.added.systems.push(newSystem);\n            } else {\n                // Modified systems\n                const currentSystem = currentData.systems.find(s => s.id === newSystem.id);\n                if (!this.areSystemsEqual(currentSystem, newSystem)) {\n                    differences.modified.systems.push(newSystem);\n                }\n            }\n        });\n\n        // Compare dependencies\n        const currentDepKeys = new Set(currentData.dependencies.map(d => `${d.source}-${d.target}`));\n\n        // Added and removed dependencies\n        newData.dependencies.forEach(newDep => {\n            if (newDep.delete) {\n                differences.removed.dependencies.push(newDep);\n                return;\n            }\n            const key = `${newDep.source}-${newDep.target}`;\n            if (!currentDepKeys.has(key)) {\n                differences.added.dependencies.push(newDep);\n            } else {\n                // Modified dependencies\n                const currentDep = currentData.dependencies.find(d =>\n                    d.source === newDep.source && d.target === newDep.target);\n                if (!this.areDependenciesEqual(currentDep, newDep)) {\n                    differences.modified.dependencies.push(newDep);\n                }\n            }\n        });\n\n        return differences;\n    }\n\n    /**\n     * Compares two systems for equality, adapted for multi-group support\n     * @param {Object} system1 - First system\n     * @param {Object} system2 - Second system\n     * @returns {boolean} True if the systems are equal\n     */\n    areSystemsEqual(system1, system2) {\n        if (!system1 || !system2) return false;\n\n        // Compare main properties\n        if (system1.name !== system2.name ||\n            system1.description !== system2.description ||\n            system1.category !== system2.category ||\n            system1.status !== system2.status ||\n            system1.knownUsage !== system2.knownUsage) {\n            return false;\n        }\n\n        // Compare groups\n        const groups1 = this.getSystemGroups(system1);\n        const groups2 = this.getSystemGroups(system2);\n\n        if (groups1.length !== groups2.length) {\n            return false;\n        }\n\n        // Check if all groups match (order does not matter)\n        for (const group of groups1) {\n            if (!groups2.includes(group)) {\n                return false;\n            }\n        }\n\n        // Compare tags (if present)\n        if (Array.isArray(system1.tags) && Array.isArray(system2.tags)) {\n            if (system1.tags.length !== system2.tags.length) {\n                return false;\n            }\n\n            for (let i = 0; i < system1.tags.length; i++) {\n                if (!system2.tags.includes(system1.tags[i])) {\n                    return false;\n                }\n            }\n        } else if ((system1.tags && !system2.tags) || (!system1.tags && system2.tags)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Helper function to extract all groups of a system\n     * @param {Object} system - The system object\n     * @returns {Array} Array with all group names\n     */\n    getSystemGroups(system) {\n        let groups = [];\n\n        if (Array.isArray(system.groups) && system.groups.length > 0) {\n            groups = [...system.groups];\n        } else if (system.group && typeof system.group === 'string') {\n            groups = [system.group];\n        }\n\n        return groups;\n    }\n\n    /**\n     * Compares two dependencies for equality\n     * @param {Object} dep1 - First dependency\n     * @param {Object} dep2 - Second dependency\n     * @returns {boolean} True if the dependencies are equal\n     */\n    areDependenciesEqual(dep1, dep2) {\n        if (!dep1 || !dep2) return false;\n\n        return dep1.type === dep2.type &&\n            dep1.description === dep2.description &&\n            dep1.protocol === dep2.protocol;\n    }\n\n    /**\n     * Validates the data structure\n     * @param {Object} data - The data structure to validate\n     * @returns {boolean} True if the data is valid\n     */\n    validateSystemData(data) {\n        // Check if the basic structure exists\n        if (!data || (!Array.isArray(data.systems) && !Array.isArray(data.dependencies))) {\n            return false;\n        }\n\n        data.systems = data.systems || [];\n        data.dependencies = data.dependencies || [];\n\n        // Check if all systems have an ID\n        const allSystemsHaveId = data.systems.every(system => !!system.id);\n        if (!allSystemsHaveId) {\n            return false;\n        }\n\n        // Check if all dependencies have valid source and target\n        const currentData = this.dataManager.getData();\n        const allDependenciesValid = data.dependencies.every(dep =>\n            !!dep.source && !!dep.target &&\n            (data.systems.some(sys => sys.id === dep.source) || currentData.systems.some(sys => sys.id === dep.source)) &&\n            (data.systems.some(sys => sys.id === dep.target) || currentData.systems.some(sys => sys.id === dep.target))\n        );\n\n        return allDependenciesValid;\n    }\n\n    /**\n     * Extracts YAML content from an LLM response\n     * @param {string} response - The LLM response\n     * @returns {string|null} The extracted YAML content or null\n     */\n    extractYamlFromResponse(response) {\n        // Search for YAML blocks in the response (with Markdown code block)\n        const yamlRegex = /```(?:yaml)?\\s*([\\s\\S]*?)\\s*```/i;\n        const match = response.match(yamlRegex);\n\n        if (match && match[1]) {\n            return match[1].trim();\n        }\n\n        return null;\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/service/llm-integration-manager.js?");

/***/ }),

/***/ "./src/ui/base/overlay-component.js":
/*!******************************************!*\
  !*** ./src/ui/base/overlay-component.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OverlayComponent: () => (/* binding */ OverlayComponent)\n/* harmony export */ });\n/* harmony import */ var _ui_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui-component.js */ \"./src/ui/base/ui-component.js\");\n\n\nclass OverlayComponent extends _ui_component_js__WEBPACK_IMPORTED_MODULE_0__.UIComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n    }\n    \n    show() {\n        this.element.classList.add('active');\n        this.onShow();\n        this.emit('shown');\n    }\n    \n    hide() {\n        this.element.classList.remove('active');\n        this.onHide();\n        this.emit('hidden');\n    }\n    \n    toggle() {\n        if (this.isActive()) {\n            this.hide();\n        } else {\n            this.show();\n        }\n    }\n\n    isActive() {\n        return this.element.classList.contains('active');\n    }\n    \n    onShow() {\n        // Override in subclasses\n    }\n    \n    onHide() {\n        // Override in subclasses\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/base/overlay-component.js?");

/***/ }),

/***/ "./src/ui/base/ui-component.js":
/*!*************************************!*\
  !*** ./src/ui/base/ui-component.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UIComponent: () => (/* binding */ UIComponent)\n/* harmony export */ });\n/* harmony import */ var _utils_event_emitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/event-emitter.js */ \"./src/utils/event-emitter.js\");\n\n\nclass UIComponent extends _utils_event_emitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor(selector, dependencies = {}, options = {}) {\n        super();\n\n        this.element = this.resolveElement(selector);\n        if (!this.element) {\n            throw new Error(`Element '${selector}' not found`);\n        }\n\n        this.dependencies = dependencies;\n        this.options = options;\n    }\n\n    render(template) {\n        const div = document.createElement('div');\n        div.innerHTML = template;\n        return div.firstElementChild;\n    }\n    \n    resolveElement(selector) {\n        if (typeof selector === 'string') {\n            return document.querySelector(selector);\n        }\n        if (selector instanceof HTMLElement) {\n            return selector;\n        }\n        return null;\n    }\n\n    initialize() {\n        this.setupDOM();\n        this.bindEvents();\n        this.setupDependencies();\n        this.emit('initialized');\n    }\n    \n    setupDOM() {\n        // Override in subclasses\n    }\n    \n    bindEvents() {\n        // Override in subclasses\n    }\n    \n    setupDependencies() {\n        // Override in subclasses\n    }\n\n    destroy() {\n        this.emit('destroyed');\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/base/ui-component.js?");

/***/ }),

/***/ "./src/ui/components/chat-config.js":
/*!******************************************!*\
  !*** ./src/ui/components/chat-config.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatConfig: () => (/* binding */ ChatConfig)\n/* harmony export */ });\n/* harmony import */ var _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/overlay-component.js */ \"./src/ui/base/overlay-component.js\");\n\n\nconst chatConfigModalTemplate = () => `\n    <div class=\"modal fade\" id=\"llm-config-modal\" tabindex=\"-1\" aria-labelledby=\"llm-config-modal-label\"\n        aria-hidden=\"true\">\n        <div class=\"modal-dialog\">\n            <div class=\"modal-content\">\n                <div class=\"modal-header\">\n                    <h5 class=\"modal-title\" id=\"llm-config-modal-label\">Chatbot / LLM Configuration</h5>\n                    <button type=\"button\" class=\"btn-close\" aria-label=\"Close\"></button>\n                </div>\n                <div class=\"modal-body\">\n                    <form id=\"llm-config-form\">\n                        <div class=\"form-floating mb-3\">\n                            <select class=\"form-select\" id=\"llm-type\" required>\n                                <option value=\"claude\">Anthropic Claude</option>\n                                <option value=\"openai\">OpenAI</option>\n                                <option value=\"custom\">Custom</option>\n                            </select>\n                            <label for=\"llm-type\">LLM Provider</label>\n                        </div>\n                        <div class=\"form-floating mb-3\">\n                            <input type=\"password\" class=\"form-control\" id=\"llm-api-key\" autocomplete=\"off\" required\n                                placeholder=\"API Key\">\n                            <label for=\"llm-api-key\">API Key</label>\n                        </div>\n                        <div class=\"form-floating mb-3\">\n                            <input type=\"text\" class=\"form-control\" id=\"llm-model\" required placeholder=\"Model name\">\n                            <label for=\"llm-model\">Model name</label>\n                        </div>\n                        <div class=\"form-floating mb-3\" id=\"llm-url-container\" style=\"display: none;\">\n                            <input type=\"text\" class=\"form-control\" id=\"llm-url\" placeholder=\"URL (Optional)\">\n                            <label for=\"llm-url\">Backend URL</label>\n                        </div>\n                        <div class=\"accordion\" id=\"llm-advanced-settings\">\n                            <div class=\"accordion-item\">\n                                <h2 class=\"accordion-header\" id=\"headingAdvanced\">\n                                    <button class=\"accordion-button collapsed\" type=\"button\" data-bs-toggle=\"collapse\"\n                                        data-bs-target=\"#collapseAdvanced\" aria-expanded=\"false\"\n                                        aria-controls=\"collapseAdvanced\">\n                                        Advanced settings (optional)\n                                    </button>\n                                </h2>\n                                <div id=\"collapseAdvanced\" class=\"accordion-collapse collapse\"\n                                    aria-labelledby=\"headingAdvanced\" data-bs-parent=\"#llm-advanced-settings\">\n                                    <div class=\"accordion-body\">\n                                        <div class=\"form-floating mb-3\">\n                                            <textarea class=\"form-control\" id=\"llm-system-prompt\" rows=\"3\"\n                                                placeholder=\"Optional system prompt\" style=\"height: 120px\"></textarea>\n                                            <label for=\"llm-system-prompt\">System prompt</label>\n                                            <div class=\"form-text text-muted\">\n                                                You can use {{dataStructure}} to refer to the data structure.\n                                            </div>\n                                        </div>\n\n                                        <div class=\"form-floating mb-3\">\n                                            <textarea class=\"form-control\" id=\"llm-prompt-prefix\" rows=\"3\"\n                                                placeholder=\"Optional prompt prefix\" style=\"height: 120px\"></textarea>\n                                            <label for=\"llm-prompt-prefix\">Prompt prefix</label>\n                                            <div class=\"form-text text-muted\">\n                                                You can use {{currentData}} to refer to the current data and {{example}} to prompt how it should look like. For the user request use {{userInput}}.\n                                            </div>\n                                        </div>\n                                    </div>\n                                </div>\n                            </div>\n                        </div>\n                    </form>\n                </div>\n                <div class=\"modal-footer\">\n                    <button type=\"button\" class=\"btn btn-secondary\" id=\"cancel-llm-config\">Cancel</button>\n                    <button type=\"button\" class=\"btn btn-primary\" id=\"save-llm-config\">Save</button>\n                </div>\n            </div>\n        </div>\n    </div>\n`;\n\nconst hiddenKeyIfNotEmpty = \"-----hidden-----\";\n\nclass ChatConfig extends _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__.OverlayComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n        this.modalElement = null;\n        this.modal = null;\n    }\n\n    setupDOM() {\n        this.modalElement = this.render(chatConfigModalTemplate());\n        this.element.appendChild(this.modalElement);\n        this.modal = new bootstrap.Modal(this.modalElement);\n\n        this.saveLlmConfig = this.modalElement.querySelector('#save-llm-config');\n        this.cancelLlmConfig = this.modalElement.querySelector('#cancel-llm-config');\n        this.llmUrlContainer = this.modalElement.querySelector('#llm-url-container');\n        this.llmUrlElement = this.modalElement.querySelector('#llm-url');\n        this.llmTypeElement = this.modalElement.querySelector('#llm-type');\n        this.llmApiKeyElement = this.modalElement.querySelector('#llm-api-key');\n        this.llmModelElement = this.modalElement.querySelector('#llm-model');\n        this.llmSystemPromptElement = this.modalElement.querySelector('#llm-system-prompt');\n        this.llmPromptPrefixElement = this.modalElement.querySelector('#llm-prompt-prefix');\n\n        this.toggleLlmUrl();\n    }\n    \n    bindEvents() {\n        this.llmTypeElement.addEventListener('change', () => this.toggleLlmUrl());\n        this.modalElement.querySelector('.btn-close').addEventListener('click', () => this.hide());\n        this.cancelLlmConfig.addEventListener('click', () => this.hide());\n        this.saveLlmConfig.addEventListener('click', () => this.saveConfig());\n    }\n\n    saveConfig() {\n        const llmType = this.llmTypeElement.value;\n        const llmApiKey = this.llmApiKeyElement.value;\n        const llmModel = this.llmModelElement.value;\n        const llmSystemPrompt = this.llmSystemPromptElement.value;\n        const llmPromptPrefix = this.llmPromptPrefixElement.value;\n        const llmUrl = this.llmUrlElement.value;\n\n        // Save config\n        const llmConfig = this.dependencies.llmConfig;\n        llmConfig.llmType = llmType;\n        if (llmApiKey !== hiddenKeyIfNotEmpty) {\n            llmConfig.updateLlmApiKey(llmApiKey).then(() => {\n                console.log(\"API key saved\");\n            }).catch((error) => {\n                console.error(\"Error saving API key:\", error);\n            });\n        }\n        llmConfig.llmModel = llmModel;\n        llmConfig.llmSystemPrompt = llmSystemPrompt;\n        llmConfig.llmPromptPrefix = llmPromptPrefix;\n        llmConfig.llmUrl = llmUrl;\n        \n        this.dependencies.llmManager.updateConfig(llmType, llmModel, llmApiKey, llmSystemPrompt, llmPromptPrefix, llmUrl);\n\n        this.emit(\"saved\");\n\n        this.hide();\n    }\n    \n    toggleLlmUrl() {\n        this.llmUrlContainer.style.display = this.llmTypeElement.value === 'custom' ? '' : 'none';\n        this.llmUrlElement.required = this.llmTypeElement.value === 'custom';\n    }\n\n    onShow() {\n        const llmConfig = this.dependencies.llmConfig;\n        this.llmTypeElement.value = llmConfig.llmType;\n        this.llmApiKeyElement.value = llmConfig.hasLlmApiKey() ? hiddenKeyIfNotEmpty : \"\";\n        this.llmModelElement.value = llmConfig.llmModel;\n        this.llmSystemPromptElement.value = llmConfig.llmSystemPrompt;\n        this.llmPromptPrefixElement.value = llmConfig.llmPromptPrefix;\n        this.llmUrlElement.value = llmConfig.llmUrl;\n        this.toggleLlmUrl();\n        this.modal.show();\n    }\n\n    onHide() {\n        this.modal.hide();\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/chat-config.js?");

/***/ }),

/***/ "./src/ui/components/chat-interface.js":
/*!*********************************************!*\
  !*** ./src/ui/components/chat-interface.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatInterface: () => (/* binding */ ChatInterface)\n/* harmony export */ });\n/* harmony import */ var _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/ui-component.js */ \"./src/ui/base/ui-component.js\");\n/* harmony import */ var _utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utilities.js */ \"./src/utils/utilities.js\");\n\n\n\nconst chatUiTemplate = () => `\n    <div id=\"llm-chat-container\" class=\"llm-chat-container active\" style=\"display: flex;\">\n        <div class=\"llm-chat-header align-items-center justify-content-between\">\n            <h5>Infrastructure Assistant</h5>\n            <div class=\"d-flex align-items-center\">\n                <button class=\"btn btn-sm p-0 me-2\" id=\"llm-chat-settings\" title=\"Settings\">\n                    <i class=\"bi bi-gear fs-5\"></i>\n                </button>\n                <button type=\"button\" class=\"btn-close\" id=\"llm-chat-close\" aria-label=\"Close\"></button>\n            </div>\n        </div>\n        <div class=\"llm-chat-messages\" id=\"llm-chat-messages\">\n            <!-- Chat messages will be inserted here -->\n        </div>\n        <div class=\"llm-chat-input-container\">\n            <textarea id=\"llm-chat-input\" class=\"llm-chat-input\"\n                placeholder=\"Describe changes to the infrastructure...\" rows=\"1\"></textarea>\n            <button id=\"llm-chat-send\" class=\"llm-chat-send btn btn-primary\">\n                <i class=\"bi bi-send\"></i>\n            </button>\n            <div class=\"llm-chat-loading\" id=\"llm-chat-loading\">\n                <div class=\"spinner-border text-primary\" role=\"status\">\n                    <span class=\"visually-hidden\">Processing...</span>\n                </div>\n            </div>\n        </div>\n    </div>\n`;\n\nclass ChatInterface extends _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__.UIComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n    }\n\n    setupDOM() {\n        this.chatContainer = this.render(chatUiTemplate());\n        this.element.appendChild(this.chatContainer);\n\n        this.chatMessages = this.chatContainer.querySelector('#llm-chat-messages');\n        this.chatInput = this.chatContainer.querySelector('#llm-chat-input');\n        this.sendButton = this.chatContainer.querySelector('#llm-chat-send');\n        this.closeButton = this.chatContainer.querySelector('#llm-chat-close');\n        this.loadingIndicator = this.chatContainer.querySelector('#llm-chat-loading');\n        this.chatSettings = this.chatContainer.querySelector('#llm-chat-settings')\n\n        if (!this.dependencies.llmManager.isConfigurated()) {\n            this.chatContainer.style.display = 'none';\n        }\n    }\n\n    hide() {\n        this.chatContainer.style.display = 'none';\n    }\n\n    addWelcome() {\n        if (this.chatMessages.children.length === 0) {\n            this.addSystemMessage(\"How can I assist you with managing your IT infrastructure? You can describe changes to me, and I will update the model for you.\");\n        }\n    }\n\n    bindEvents() {\n        this.toggleLlmChat = this.dependencies.toolbar.button('bi-chat-dots', 'Chat assistant', () => {\n            this.toggleChat()\n        }, 'create', ['toggle-llm-chat']);\n        this.chatSettings.addEventListener('click', () => this.openSettings());\n        this.chatInput.addEventListener('focus', () => {\n            if (this.chatContainer.classList.contains('active')) {\n                this.chatContainer.classList.remove('active');\n                if (!this.dependencies.llmManager.isConfigurated()) {\n                    this.changeLlmConfig();\n                } else {\n                    this.addWelcome();\n                }\n            }\n        });\n        \n        this.chatInput.addEventListener('input', () => {\n            this.chatInput.style.height = 'auto';\n            const maxRows = 3;\n            const lines = this.chatInput.value.split('\\n').length;\n            const rows = Math.min(lines, maxRows);\n            this.chatInput.rows = rows;\n        });\n\n        this.closeButton.addEventListener('click', () => {\n            this.chatContainer.classList.add('active');\n            document.getElementById('toggle-llm-chat').classList.remove('active');\n        });\n\n        this.sendButton.addEventListener('click', () => this.sendMessage());\n\n        this.chatInput.addEventListener('keydown', (event) => {\n            if (event.key === 'Enter' && !event.shiftKey) {\n                event.preventDefault();\n                this.sendMessage();\n            }\n        });\n        \n        this.dependencies.chatConfig.on('hidden', () => this.checkIfConfiguratedOrCloseChat());\n\n        this.dependencies.chatConfig.on('saved', () => {\n            if (this.checkIfConfiguratedOrCloseChat()) {\n                this.chatContainer.style.display = 'flex';\n                if (this.isVisible()) {\n                    this.chatInput.focus();\n                    this.addWelcome();\n                }\n            } else {\n                this.toggleLlmChat.classList.remove('active');\n            }\n        });\n    }\n\n    async sendMessage() {\n        const userInput = this.chatInput.value.trim();\n        if (!userInput) return;\n\n        // Display user input\n        this.addUserMessage(userInput);\n        this.chatInput.value = '';\n\n        // Show loading indicator\n        this.loadingIndicator.style.display = 'flex';\n\n        // Build current message in the UI\n        let currentAssistantMessage = '';\n        const messageElement = this.addAssistantMessage('');\n\n        // Process LLM request\n        let currentResult = \"\";\n        const result = await this.dependencies.llmManager.processUserInput(userInput, (token) => {\n            currentResult += token;\n            messageElement.innerHTML = marked ? marked.parse(currentResult) : currentResult;\n        });\n        console.log(result);\n\n        // Hide loading indicator\n        this.loadingIndicator.style.display = 'none';\n\n        // Display response\n        messageElement.innerHTML = marked ? marked.parse(result.originalResponse) : result.originalResponse;\n\n        // If YAML response with changes\n        if (result.success && result.yamlData) {\n            this.showUpdateConfirmation(result.yamlData, result.differences);\n        }\n    }\n\n    showUpdateConfirmation(newData, differences) {\n        // Only show confirmation if there are changes\n        if (\n            differences.added.systems.length === 0 &&\n            differences.modified.systems.length === 0 &&\n            differences.removed.systems.length === 0 &&\n            differences.added.dependencies.length === 0 &&\n            differences.modified.dependencies.length === 0 &&\n            differences.removed.dependencies.length === 0\n        ) {\n            return;\n        }\n\n        // Create summary of changes\n        let summaryText = \"The following changes were detected:\\n\\n\";\n\n        // Systems\n        if (differences.added.systems.length > 0) {\n            summaryText += `➕ ${differences.added.systems.length} new systems: ${differences.added.systems.map(s => s.name).join(', ')}\\n`;\n        }\n        if (differences.modified.systems.length > 0) {\n            summaryText += `✏️ ${differences.modified.systems.length} modified systems: ${differences.modified.systems.map(s => s.name).join(', ')}\\n`;\n        }\n        if (differences.removed.systems.length > 0) {\n            summaryText += `❌ ${differences.removed.systems.length} removed systems: ${differences.removed.systems.map(s => s.name).join(', ')}\\n`;\n        }\n\n        // Dependencies\n        if (differences.added.dependencies.length > 0) {\n            summaryText += `➕ ${differences.added.dependencies.length} new connections\\n`;\n        }\n        if (differences.modified.dependencies.length > 0) {\n            summaryText += `✏️ ${differences.modified.dependencies.length} modified connections\\n`;\n        }\n        if (differences.removed.dependencies.length > 0) {\n            summaryText += `❌ ${differences.removed.dependencies.length} removed connections\\n`;\n        }\n\n        // Create message\n        const messageElement = document.createElement('div');\n        messageElement.className = 'llm-chat-message llm-system-message';\n        messageElement.textContent = summaryText;\n\n        // Add action buttons\n        const actionsDiv = document.createElement('div');\n        actionsDiv.className = 'llm-update-actions';\n\n        const applyButton = document.createElement('button');\n        applyButton.className = 'btn btn-primary';\n        applyButton.textContent = 'Apply changes';\n        applyButton.addEventListener('click', () => {\n            // Update data in DataManager\n            this.dependencies.llmManager.applyChanges(differences);\n\n            // Show feedback\n            this.addSystemMessage(\"The changes have been applied successfully.\");\n\n            // Remove button container\n            messageElement.removeChild(actionsDiv);\n        });\n\n        const cancelButton = document.createElement('button');\n        cancelButton.className = 'btn btn-outline-secondary';\n        cancelButton.textContent = 'Discard';\n        cancelButton.addEventListener('click', () => {\n            addSystemMessage(\"The changes have been discarded.\");\n\n            // Remove button container\n            messageElement.removeChild(actionsDiv);\n        });\n\n        actionsDiv.appendChild(applyButton);\n        actionsDiv.appendChild(cancelButton);\n        messageElement.appendChild(actionsDiv);\n\n        // Add to chat\n        this.chatMessages.appendChild(messageElement);\n        this.chatMessages.scrollTop = this.chatMessages.scrollHeight;\n    }\n\n    addUserMessage(message) {\n        const messageElement = document.createElement('div');\n        messageElement.className = 'llm-chat-message llm-user-message';\n        messageElement.textContent = message;\n        this.chatMessages.appendChild(messageElement);\n        this.chatMessages.scrollTop = this.chatMessages.scrollHeight;\n        return messageElement;\n    }\n\n    addAssistantMessage(message) {\n        const messageElement = document.createElement('div');\n        messageElement.className = 'llm-chat-message llm-assistant-message';\n        messageElement.innerHTML = message;\n        this.chatMessages.appendChild(messageElement);\n        this.chatMessages.scrollTop = this.chatMessages.scrollHeight;\n        return messageElement;\n    }\n\n    addSystemMessage(message) {\n        const messageElement = document.createElement('div');\n        messageElement.className = 'llm-chat-message llm-system-message';\n        messageElement.textContent = message;\n        this.chatMessages.appendChild(messageElement);\n        this.chatMessages.scrollTop = this.chatMessages.scrollHeight;\n        return messageElement;\n    }\n\n    toggleChat() {\n        const wasVisible = this.isVisible();\n        if (wasVisible) {\n            this.chatContainer.classList.add('active');\n            this.toggleLlmChat.classList.remove('active');\n        } else {\n            this.chatContainer.classList.remove('active');\n            this.toggleLlmChat.classList.add('active');\n        }\n\n        if (!wasVisible) {\n            if (!this.dependencies.llmManager.isConfigurated()) {\n                this.openSettings();\n            } else {\n                this.chatInput.focus();\n                this.addWelcome();\n            }\n        }\n    }\n\n    openSettings = () => {\n        this.dependencies.chatConfig.show();\n    }\n\n    isVisible() {\n        return !this.chatContainer.classList.contains('active');\n    }\n\n    checkIfConfiguratedOrCloseChat() {\n        if (!this.dependencies.llmManager.isConfigurated()) {\n            if (this.isVisible()) {\n                this.chatContainer.style.display = 'none';\n                this.toggleLlmChat.classList.remove('active');\n                (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(\"Please configure the chat assistant.\", \"warning\");\n            }\n            return false;\n        }\n        return true;\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/chat-interface.js?");

/***/ }),

/***/ "./src/ui/components/connection-mode.js":
/*!**********************************************!*\
  !*** ./src/ui/components/connection-mode.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionModeComponent: () => (/* binding */ ConnectionModeComponent)\n/* harmony export */ });\n/* harmony import */ var _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/ui-component.js */ \"./src/ui/base/ui-component.js\");\n/* harmony import */ var _utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utilities.js */ \"./src/utils/utilities.js\");\n\n\n\nclass ConnectionModeComponent extends _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__.UIComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n\n        this.initialized = false;\n        this.isConnectionModeActive = false;\n        this.sourceSystem = null;\n        this.tempLink = null;\n        this.mousePosition = { x: 0, y: 0 };\n\n        // Default values for new connections\n        this.defaultConnectionType = \"data\";\n        this.defaultConnectionProtocol = \"API\";\n    }\n\n    bindEvents() {\n        // Event listener for connection mode toggle\n        // document.getElementById('toggle-connection-mode')\n        this.toggleConnectionModeButton = this.dependencies.toolbar.button('bi-link', 'Connection mode', () => {\n            this.toggleConnectionMode();\n        }, 'create', ['toggle-connection-mode']);\n\n        // Event listener for data changes to keep connection mode active\n        this.dependencies.dataManager.on('dataChanged', () => {\n            if (this.isConnectionModeActive) {\n                // Short delay to wait for UI update\n                setTimeout(() => {\n                    this.setupConnectionDrag();\n                }, 100);\n            }\n        });\n\n        // Visualizer Dependency-Klick an Dependency-Manager weitergeben übergeben\n        this.dependencies.visualizer.on('dependencyClick', (ref) => {\n            const { event, data } = ref;\n            this.showLinkControls(event, data)\n        });\n    }\n\n    /**\n     * Toggles the connection mode on/off\n     */\n    toggleConnectionMode() {\n        this.isConnectionModeActive = !this.isConnectionModeActive;\n        const toggleButton = this.toggleConnectionModeButton;\n\n        if (this.isConnectionModeActive) {\n            document.body.classList.add('connection-mode');\n            toggleButton.classList.add('active');\n            toggleButton.title = 'Exit connection mode';\n            toggleButton.querySelector('i').className = 'bi bi-link-45deg';\n\n            // Disable default drag and enable connection drag instead\n            this.dependencies.visualizer.disableDrag(); // Set flag\n            this.setupConnectionDrag();\n\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)('Connection mode enabled: Drag from one system to another', 'info');\n        } else {\n            document.body.classList.remove('connection-mode');\n            toggleButton.classList.remove('active');\n            toggleButton.title = 'Connection mode';\n            toggleButton.querySelector('i').className = 'bi bi-link';\n\n            // Remove connection drag and restore default drag\n            this.removeConnectionDrag();\n            this.dependencies.visualizer.enableDrag(); // Reset flag\n\n            // Cleanup\n            this.resetConnectionState();\n\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)('Connection mode disabled', 'info');\n        }\n    }\n\n    /**\n     * Sets up the drag mechanism for connections\n     */\n    setupConnectionDrag() {\n        if (!this.dependencies.visualizer.nodeElements) return;\n\n        // Remove connection drag if present\n        this.removeConnectionDrag();\n\n        // Define drag function for connections\n        const connectionDrag = d3.drag()\n            .on(\"start\", (event, d) => this.handleDragStart(event, d))\n            .on(\"drag\", (event, d) => this.handleDragMove(event, d))\n            .on(\"end\", (event, d) => this.handleDragEnd(event, d));\n\n        // Apply to nodes\n        this.dependencies.visualizer.nodeElements.call(connectionDrag);\n    }\n\n    /**\n     * Removes the connection drag mechanism\n     */\n    removeConnectionDrag() {\n        if (!this.dependencies.visualizer.nodeElements) return;\n\n        // Remove connection drag\n        this.dependencies.visualizer.nodeElements.on('.drag', null);\n    }\n\n    /**\n     * Handles the start of a connection drag\n     */\n    handleDragStart(event, d) {\n        if (!this.isConnectionModeActive) return;\n\n        // Set source system\n        this.sourceSystem = d;\n\n        // Visually mark\n        d3.select(event.sourceEvent.target.closest('.node')).classed('connection-source', true);\n\n        // Create temporary connection line\n        this.createTempLink(d);\n    }\n\n    /**\n     * Handles movement during a connection drag\n     */\n    handleDragMove(event, d) {\n        if (!this.isConnectionModeActive || !this.tempLink) return;\n\n        // Update temporary line\n        this.tempLink.attr('d', `M${this.sourceSystem.x},${this.sourceSystem.y} L${event.x},${event.y}`);\n    }\n\n    /**\n     * Handles the end of a connection drag\n     */\n    handleDragEnd(event, d) {\n        if (!this.isConnectionModeActive || !this.sourceSystem) return;\n\n        // Verbesserte Touch-Erkennung: Event-Position sichern\n        const clientX = event.sourceEvent.type.startsWith('touch')\n            ? event.sourceEvent.changedTouches[0].clientX\n            : event.sourceEvent.clientX;\n\n        const clientY = event.sourceEvent.type.startsWith('touch')\n            ? event.sourceEvent.changedTouches[0].clientY\n            : event.sourceEvent.clientY;\n\n        // Check if released over another node\n        const targetElement = document.elementFromPoint(clientX, clientY);\n        const targetNode = targetElement ? targetElement.closest('.node') : null;\n\n        if (targetNode) {\n            const targetSystemId = targetNode.getAttribute('data-system-id');\n            const targetSystem = this.dependencies.dataManager.getData().systems.find(sys => sys.id === targetSystemId);\n\n            if (targetSystem && targetSystem.id !== this.sourceSystem.id) {\n                // Create connection with default values\n                this.createConnection(this.sourceSystem, targetSystem);\n            } else if (targetSystem && targetSystem.id === this.sourceSystem.id) {\n                // Same node used as target\n                (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)('Source and target system cannot be identical.', 'warning');\n            }\n        }\n\n        // Cleanup\n        this.resetConnectionState();\n    }\n\n    /**\n     * Creates a temporary connection line from the source system\n     */\n    createTempLink(sourceSystem) {\n        // Create temporary line\n        this.tempLink = this.dependencies.visualizer.svg.select('g').append('path')\n            .attr('class', 'temp-link')\n            .attr('d', `M${sourceSystem.x},${sourceSystem.y} L${sourceSystem.x},${sourceSystem.y}`);\n    }\n\n    /**\n     * Creates a new connection with default values\n     */\n    createConnection(sourceSystem, targetSystem) {\n        // Create new dependency with default values\n        const newDependency = {\n            source: sourceSystem.id,\n            target: targetSystem.id,\n            type: this.defaultConnectionType,\n            description: `Connection from ${sourceSystem.name} to ${targetSystem.name}`,\n            protocol: this.defaultConnectionProtocol\n        };\n\n        // Add dependency via DataManager\n        const success = this.dependencies.dataManager.addDependency(newDependency);\n\n        if (success) {\n            // Success message\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(\n                `Connection from \"${sourceSystem.name}\" to \"${targetSystem.name}\" has been created`,\n                'success'\n            );\n        } else {\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)('Error creating connection', 'danger');\n        }\n    }\n\n    /**\n     * Resets the connection state\n     */\n    resetConnectionState() {\n        // Reset source system\n        if (this.sourceSystem) {\n            d3.selectAll('.node').classed('connection-source', false);\n            this.sourceSystem = null;\n        }\n\n        // Remove temporary line\n        if (this.tempLink) {\n            this.tempLink.remove();\n            this.tempLink = null;\n        }\n    }\n\n    /**\n     * Shows the delete control for a connection\n     */\n    showLinkControls(event, linkData) {\n        // Do not show controls in connection mode\n        if (this.isConnectionModeActive) return;\n\n        // Remove existing controls\n        this.hideLinkControls();\n\n        // Create new controls\n        const controls = document.createElement('div');\n        controls.className = 'link-controls';\n        controls.innerHTML = `\n                <button class=\"link-delete-btn\" title=\"Delete connection\">\n                    <i class=\"bi bi-trash\"></i>\n                </button>\n            `;\n\n        // Set position\n        controls.style.left = `${event.pageX}px`;\n        controls.style.top = `${event.pageY}px`;\n\n        // Add to DOM\n        document.body.appendChild(controls);\n\n        // Store link data in attribute\n        controls.setAttribute('data-source', linkData.source.id || linkData.source);\n        controls.setAttribute('data-target', linkData.target.id || linkData.target);\n\n        // Event listener for delete button\n        controls.querySelector('.link-delete-btn').addEventListener('click', () => {\n            //this.showDeleteDependencyConfirmation(linkData);\n            this.emit('linkDeleted', {\n                source: linkData.source.id || linkData.source,\n                target: linkData.target.id || linkData.target\n            });\n            this.hideLinkControls();\n        });\n\n        // Show controls\n        controls.style.display = 'block';\n\n        // Click outside to close\n        document.addEventListener('click', (e) => {\n            if (!controls.contains(e.target) && e.target !== event.target) {\n                this.hideLinkControls();\n            }\n        }, { once: true });\n    }\n\n    /**\n     * Hides the link controls\n     */\n    hideLinkControls() {\n        const existingControls = document.querySelector('.link-controls');\n        if (existingControls) {\n            existingControls.remove();\n        }\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/connection-mode.js?");

/***/ }),

/***/ "./src/ui/components/delete-dependency.js":
/*!************************************************!*\
  !*** ./src/ui/components/delete-dependency.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DeleteDependencyComponent: () => (/* binding */ DeleteDependencyComponent)\n/* harmony export */ });\n/* harmony import */ var _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/overlay-component.js */ \"./src/ui/base/overlay-component.js\");\n/* harmony import */ var _utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utilities.js */ \"./src/utils/utilities.js\");\n\n\n\nconst deleteSystemModalTemplate = () => `\n    <div class=\"modal fade\" tabindex=\"-1\" aria-hidden=\"true\">\n        <div class=\"modal-dialog\">\n            <div class=\"modal-content\">\n                <div class=\"modal-header\">\n                    <h5 class=\"modal-title\">Confirmation required</h5>\n                    <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n                </div>\n                <div class=\"modal-body\" id=\"confirm-dependency-message\">\n                    Do you really want to delete this element?\n                </div>\n                <div class=\"modal-footer\">\n                    <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Cancel</button>\n                    <button type=\"button\" class=\"btn btn-danger\" id=\"confirm-dependency-action\">Delete</button>\n                </div>\n            </div>\n        </div>\n    </div>\n`;\n\nclass DeleteDependencyComponent extends _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__.OverlayComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n        this.modalElement = null;\n        this.modal = null;\n    }\n\n    setupDOM() {\n        this.modalElement = this.render(deleteSystemModalTemplate());\n        this.element.appendChild(this.modalElement);\n        this.modal = new bootstrap.Modal(this.modalElement);\n\n        this.confirm = this.modalElement.querySelector('#confirm-dependency-action');\n        this.message = this.modalElement.querySelector('#confirm-dependency-message');\n    }\n\n    bindEvents() {\n        this.confirm.addEventListener('click', () => {\n            const sourceId = this.confirm.getAttribute('data-source');\n            const targetId = this.confirm.getAttribute('data-target');\n            if (sourceId && targetId) {\n                this.deleteDependency(sourceId, targetId);\n                this.hide();\n            }\n        });\n\n        this.dependencies.connectionMode.on('linkDeleted', (data) => {\n            this.showDeleteDependencyConfirmation(data.source, data.target);\n        });\n    }\n\n    /**\n     * Shows a confirmation prompt to delete a dependency\n     */\n    showDeleteDependencyConfirmation(sourceId, targetId) {\n        const sourceSystem = this.dependencies.dataManager.getData().systems.find(sys => sys.id === sourceId);\n        const targetSystem = this.dependencies.dataManager.getData().systems.find(sys => sys.id === targetId);\n        \n        if (!sourceSystem || !targetSystem) return;\n        \n        // Confirmation message\n        const message = `Do you really want to delete the connection from \"${sourceSystem.name}\" to \"${targetSystem.name}\"?`;\n        \n        this.message.innerHTML = message;\n        this.confirm.setAttribute('data-action', 'delete-dependency');\n        this.confirm.setAttribute('data-source', sourceId);\n        this.confirm.setAttribute('data-target', targetId);\n        \n        // Show modal\n        this.show();\n    }\n\n    /**\n     * Deletes a dependency\n     */\n    deleteDependency(sourceId, targetId) {\n        // Find systems for notification\n        const sourceSystem = this.dependencies.dataManager.getData().systems.find(sys => sys.id === sourceId);\n        const targetSystem = this.dependencies.dataManager.getData().systems.find(sys => sys.id === targetId);\n        \n        if (!sourceSystem || !targetSystem) return;\n        \n        // Delete dependency via DataManager\n        const success = this.dependencies.dataManager.deleteDependency({\n            source: sourceId,\n            target: targetId\n        });\n        \n        if (success) {\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(\n                `Connection from \"${sourceSystem.name}\" to \"${targetSystem.name}\" has been deleted`,\n                'success'\n            );\n        } else {\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)('Error deleting connection', 'danger');\n        }\n    }\n\n    onShow() {\n        this.modal.show();\n    }\n\n    onHide() {\n        this.modal.hide();\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/delete-dependency.js?");

/***/ }),

/***/ "./src/ui/components/delete-system.js":
/*!********************************************!*\
  !*** ./src/ui/components/delete-system.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DeleteSystemComponent: () => (/* binding */ DeleteSystemComponent)\n/* harmony export */ });\n/* harmony import */ var _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/overlay-component.js */ \"./src/ui/base/overlay-component.js\");\n/* harmony import */ var _utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utilities.js */ \"./src/utils/utilities.js\");\n\n\n\nconst deleteSystemModalTemplate = () => `\n    <div class=\"modal fade\" tabindex=\"-1\" aria-hidden=\"true\">\n        <div class=\"modal-dialog\">\n            <div class=\"modal-content\">\n                <div class=\"modal-header\">\n                    <h5 class=\"modal-title\">Confirmation required</h5>\n                    <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n                </div>\n                <div class=\"modal-body\" id=\"confirm-system-message\">\n                    Do you really want to delete this element?\n                </div>\n                <div class=\"modal-footer\">\n                    <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Cancel</button>\n                    <button type=\"button\" class=\"btn btn-danger\" id=\"confirm-system-action\">Delete</button>\n                </div>\n            </div>\n        </div>\n    </div>\n`;\n\nclass DeleteSystemComponent extends _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__.OverlayComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n        this.modalElement = null;\n        this.modal = null;\n        this.isMultiDelete = false;\n        this.systemsToDelete = [];\n    }\n\n    setupDOM() {\n        this.modalElement = this.render(deleteSystemModalTemplate());\n        this.element.appendChild(this.modalElement);\n        this.modal = new bootstrap.Modal(this.modalElement);\n\n        this.confirm = this.modalElement.querySelector('#confirm-system-action');\n        this.message = this.modalElement.querySelector('#confirm-system-message');\n    }\n\n    bindEvents() {\n        this.confirm.addEventListener('click', () => {\n            if (this.isMultiDelete) {\n                this.deleteMultipleSystems(this.systemsToDelete);\n            } else {\n                const confirmId = this.confirm.getAttribute('data-id');\n                if (confirmId) {\n                    this.deleteSystem(confirmId);\n                }\n            }\n            this.hide();\n        });\n\n        document.addEventListener('keydown', (event) => {\n            // Only handle shortcuts when visualization container is focused/active\n            const visualizationContainer = document.getElementById('visualization-container');\n            if (!visualizationContainer || !document.activeElement) return;\n\n            // Check if we're in an input field or modal\n            const activeTag = document.activeElement.tagName.toLowerCase();\n            if (['input', 'textarea', 'select'].includes(activeTag)) return;\n\n            // Check for Delete/Backspace keys\n            if (event.key === 'Delete' || event.key === 'Backspace') {\n                const selectedSystems = this.dependencies.visualizer.getSelectedSystems();\n                if (selectedSystems.length > 0) {\n                    event.preventDefault();\n                    this.handleDeleteSelected(selectedSystems);\n                }\n            }\n        });\n    }\n\n    /**\n     * Shows the delete confirmation for a single system\n     * @param {string} systemId - The ID of the system to delete\n     */\n    showDeleteConfirmation(systemId) {\n        const system = this.dependencies.dataManager.getData().systems.find(sys => sys.id === systemId);\n        if (!system) return;\n\n        this.isMultiDelete = false;\n        this.systemsToDelete = [];\n\n        // Check if the system is used in dependencies\n        const data = this.dependencies.dataManager.getData();\n        const incomingDeps = data.dependencies.filter(dep => dep.target === systemId);\n        const outgoingDeps = data.dependencies.filter(dep => dep.source === systemId);\n\n        let message = `Do you really want to delete the system \"${system.name}\"?`;\n\n        if (incomingDeps.length > 0 || outgoingDeps.length > 0) {\n            message += `<br><br><div class=\"alert alert-warning\">\n                <strong>Warning:</strong> This system has ${incomingDeps.length + outgoingDeps.length} \n                dependencies that will also be deleted.\n            </div>`;\n        }\n\n        this.message.innerHTML = message;\n        this.confirm.setAttribute('data-id', systemId);\n        this.confirm.textContent = 'Delete';\n\n        // Show modal\n        this.show();\n    }\n\n    /**\n     * Handles deletion of selected nodes\n     */\n    handleDeleteSelected() {\n        const selectedSystems = this.dependencies.visualizer.getSelectedSystems();\n        if (selectedSystems.length === 0) return;\n    }\n\n    /**\n     * Shows the delete confirmation for multiple systems\n     * @param {Array} systems - Array of system objects to delete\n     */\n    showMultiDeleteConfirmation(systems) {\n        if (!systems || systems.length === 0) return;\n\n        if (systems.length === 1) {\n            // Fall back to single system deletion\n            this.showDeleteConfirmation(systems[0].id);\n            return;\n        }\n\n        this.isMultiDelete = true;\n        this.systemsToDelete = systems;\n\n        // Calculate total dependencies that will be affected\n        const data = this.dependencies.dataManager.getData();\n        const systemIds = systems.map(s => s.id);\n        \n        const affectedDependencies = data.dependencies.filter(dep => \n            systemIds.includes(dep.source) || systemIds.includes(dep.target)\n        );\n\n        // Generate system list for display (limit to show first few)\n        const displayLimit = 5;\n        const systemList = systems.slice(0, displayLimit).map(s => s.name).join(', ');\n        const hasMore = systems.length > displayLimit;\n        const moreText = hasMore ? ` and ${systems.length - displayLimit} more` : '';\n\n        let message = `Do you really want to delete <strong>${systems.length} systems</strong>?`;\n        \n        // Show system names (truncated if too many)\n        message += `<br><br><div class=\"alert alert-info\">\n            <strong>Systems to delete:</strong><br>\n            ${systemList}${moreText}\n        </div>`;\n\n        if (affectedDependencies.length > 0) {\n            message += `<div class=\"alert alert-warning\">\n                <strong>Warning:</strong> This will also delete ${affectedDependencies.length} \n                dependencies between these systems and other systems.\n            </div>`;\n        }\n\n        // Add detailed breakdown in collapsible section\n        message += `\n            <div class=\"accordion\" id=\"deleteDetailsAccordion\">\n                <div class=\"accordion-item\">\n                    <h2 class=\"accordion-header\">\n                        <button class=\"accordion-button collapsed\" type=\"button\" data-bs-toggle=\"collapse\" \n                                data-bs-target=\"#deleteDetails\" aria-expanded=\"false\">\n                            Show detailed breakdown\n                        </button>\n                    </h2>\n                    <div id=\"deleteDetails\" class=\"accordion-collapse collapse\">\n                        <div class=\"accordion-body\">\n                            ${this.generateDetailedBreakdown(systems, affectedDependencies)}\n                        </div>\n                    </div>\n                </div>\n            </div>\n        `;\n\n        this.message.innerHTML = message;\n        this.confirm.removeAttribute('data-id');\n        this.confirm.textContent = `Delete ${systems.length} Systems`;\n\n        // Show modal\n        this.show();\n    }\n\n    /**\n     * Generates detailed breakdown for multi-delete confirmation\n     */\n    generateDetailedBreakdown(systems, affectedDependencies) {\n        let html = '<div class=\"row\">';\n        \n        // Systems breakdown by category\n        const categoryCount = {};\n        systems.forEach(system => {\n            categoryCount[system.category] = (categoryCount[system.category] || 0) + 1;\n        });\n\n        html += '<div class=\"col-md-6\">';\n        html += '<h6>Systems by Category:</h6>';\n        html += '<ul class=\"list-unstyled\">';\n        Object.entries(categoryCount).forEach(([category, count]) => {\n            html += `<li><span class=\"badge bg-secondary me-2\">${category}</span>${count}</li>`;\n        });\n        html += '</ul></div>';\n\n        // Dependencies breakdown\n        html += '<div class=\"col-md-6\">';\n        html += '<h6>Dependencies Impact:</h6>';\n        html += `<ul class=\"list-unstyled\">\n            <li><strong>Total affected:</strong> ${affectedDependencies.length}</li>\n            <li><strong>Will be deleted:</strong> All connections to/from selected systems</li>\n        </ul></div>`;\n\n        html += '</div>';\n\n        // List all systems (for detailed view)\n        html += '<h6 class=\"mt-3\">All Systems to Delete:</h6>';\n        html += '<div style=\"max-height: 200px; overflow-y: auto;\">';\n        systems.forEach(system => {\n            html += `\n                <div class=\"d-flex justify-content-between align-items-center py-1 border-bottom\">\n                    <div>\n                        <strong>${system.name}</strong>\n                        <small class=\"text-muted d-block\">${system.description}</small>\n                    </div>\n                    <div>\n                        <span class=\"badge bg-secondary me-1\">${system.category}</span>\n                        <span class=\"badge bg-info\">${system.status}</span>\n                    </div>\n                </div>\n            `;\n        });\n        html += '</div>';\n\n        return html;\n    }\n\n    /**\n     * Deletes a single system and its dependencies\n     * @param {string} systemId - The ID of the system to delete\n     */\n    deleteSystem(systemId) {\n        // Find system and store name for notification\n        const system = this.dependencies.dataManager.getData().systems.find(sys => sys.id === systemId);\n        if (!system) return;\n\n        const systemName = system.name;\n\n        // Delete system via DataManager\n        this.dependencies.dataManager.deleteSystem(systemId);\n\n        (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(`System \"${systemName}\" and related dependencies have been deleted`, 'success');\n    }\n\n    /**\n     * Deletes multiple systems and their dependencies\n     * @param {Array} systems - Array of system objects to delete\n     */\n    deleteMultipleSystems(systems) {\n        if (!systems || systems.length === 0) return;\n\n        const systemNames = systems.map(s => s.name);\n\n        // Delete all systems (batch operation for better performance)\n        systems.forEach(system => {\n            this.dependencies.dataManager.deleteSystem(system.id, false); // Don't emit events for each\n        });\n\n        // Emit single data change event at the end\n        this.dependencies.dataManager.emit('dataChanged', this.dependencies.dataManager.getData());\n\n        // Clear selection since systems are deleted\n        this.dependencies.visualizer.clearSelection();\n\n        // Show success notification\n        const message = systems.length <= 3 \n            ? `Systems \"${systemNames.join('\", \"')}\" have been deleted`\n            : `${systems.length} systems have been deleted`;\n        \n        (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(message, 'success');\n    }\n\n    onShow() {\n        this.modal.show();\n    }\n\n    onHide() {\n        this.modal.hide();\n        // Reset state\n        this.isMultiDelete = false;\n        this.systemsToDelete = [];\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/delete-system.js?");

/***/ }),

/***/ "./src/ui/components/details-overlay.js":
/*!**********************************************!*\
  !*** ./src/ui/components/details-overlay.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DetailsOverlay: () => (/* binding */ DetailsOverlay)\n/* harmony export */ });\n/* harmony import */ var _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/overlay-component.js */ \"./src/ui/base/overlay-component.js\");\n/* harmony import */ var _utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utilities.js */ \"./src/utils/utilities.js\");\n\n\n\nconst createDetailsOverlay = () => `\n    <div class=\"details-overlay overlay\">\n        <div class=\"overlay-header\">\n            <h5 class=\"detail-title\">System details</h5>\n            <div class=\"btn-group me-2\">\n                <button class=\"btn btn-sm btn-outline-secondary edit-system-btn\" title=\"Edit system\">\n                    <i class=\"bi bi-pencil\"></i>\n                </button>\n                <button class=\"btn btn-sm btn-outline-secondary toggle-fix-btn\" title=\"Lock system\">\n                    <i class=\"bi bi-lock\"></i>\n                </button>\n                <button class=\"btn btn-sm btn-outline-danger delete-system-btn\" title=\"Delete system\">\n                    <i class=\"bi bi-trash\"></i>\n                </button>\n            </div>\n            <button class=\"btn-close close-overlay\" data-close-target=\"details-panel\"></button>\n        </div>\n        <div class=\"overlay-body\" data-overscroll-behavior=\"contain\" data-bs-smooth-scroll=\"true\">\n            <!-- System details will be inserted here -->\n        </div>\n    </div>\n`;\n\nclass DetailsOverlay extends _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__.OverlayComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n    }\n\n    setupDOM() {\n        this.overlayElement = this.render(createDetailsOverlay());\n        this.element.appendChild(this.overlayElement);\n    }\n\n    bindEvents() {\n        const detailTitle = this.overlayElement.querySelector('.detail-title');\n\n        // Close button\n        this.overlayElement.querySelector('.close-overlay').addEventListener('click', () => {\n            this.hide();\n        });\n\n        // Update the overlay when data is changed\n        this.dependencies.dataManager.on('dataChanged', () => {\n            if (this.overlayElement.classList.contains('active')) {\n                const systemId = detailTitle.getAttribute('data-system-id');\n                if (systemId) {\n                    const updatedSystem = this.dependencies.dataManager.getData().systems.find(sys => sys.id === systemId);\n                    if (updatedSystem) {\n                        this.showSystemDetails(updatedSystem);\n                    } else {\n                        this.overlayElement.classList.remove('active');\n                    }\n                }\n            }\n        });\n\n        // Open overlay if element is clicked\n        this.dependencies.visualizer.on('systemClicked', (event) => {\n            this.showSystemDetails(event.system);\n        });\n\n        // Switch toggle fix button\n        this.dependencies.visualizer.on('toggleFixed', (data) => {\n            const systemId = detailTitle.getAttribute('data-system-id');\n            const { id, state } = data;\n\n            if (id !== systemId) return;\n\n            const toggleButton = this.overlayElement.querySelector('.toggle-fix-btn');\n            if (state) {\n                toggleButton.classList.add('active');\n                toggleButton.title = 'Release position';\n                (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)('Position has been fixed', 'info');\n            } else {\n                toggleButton.classList.remove('active');\n                toggleButton.title = 'Fix position';\n                (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)('Position has been released', 'info');\n            }\n        });\n\n        this.dependencies.visualizer.on('systemsSelected', (event) => {\n            this.showMultiSystemDetails(event.systems);\n        });\n\n        this.dependencies.visualizer.on('selectionChanged', (data) => {\n            if (data.selected.length === 1) {\n                // Single system selected - show single system details\n                const system = this.dependencies.visualizer.getSelectedSystems()[0];\n                if (system) {\n                    this.showSystemDetails(system);\n                }\n            } else if (data.selected.length > 1) {\n                // Multiple systems selected - show multi-system view\n                const systems = this.dependencies.visualizer.getSelectedSystems();\n                this.showMultiSystemDetails(systems);\n            } else if (data.selected.length === 0) {\n                // Nothing selected - hide overlay\n                this.hide();\n            }\n        });\n\n        // Event-Handler für Bearbeiten- und Löschen-Buttons in der Detailansicht\n        this.overlayElement.querySelector('.edit-system-btn').addEventListener('click', () => {\n            const systemId = detailTitle.getAttribute('data-system-id');\n            if (systemId) {\n                this.dependencies.editSystemComponent.showSystemModal(systemId);\n            }\n        });\n\n        this.overlayElement.querySelector('.delete-system-btn').addEventListener('click', () => {\n            const systemId = detailTitle.getAttribute('data-system-id');\n            if (systemId) {\n                // Single system deletion\n                this.dependencies.deleteSystemComponent.showDeleteConfirmation(systemId);\n            } else {\n                // Multi-system deletion\n                const selectedSystems = this.dependencies.visualizer.getSelectedSystems();\n                if (selectedSystems.length > 0) {\n                    this.dependencies.deleteSystemComponent.showMultiDeleteConfirmation(selectedSystems);\n                }\n            }\n        });\n\n        this.overlayElement.querySelector('.toggle-fix-btn').addEventListener('click', () => {\n            const systemId = detailTitle.getAttribute('data-system-id');\n            if (systemId) {\n                // Single system toggle\n                this.dependencies.visualizer.toggleNodeFixed(systemId);\n            } else {\n                // Multi-system toggle\n                this.dependencies.visualizer.toggleSelectedNodesFixed();\n            }\n        });\n    }\n\n    /**\n     * Displays details for multiple selected systems\n     */\n    showMultiSystemDetails(systems) {\n        if (!systems || systems.length === 0) {\n            this.hide();\n            return;\n        }\n\n        if (systems.length === 1) {\n            // Fall back to single system view\n            this.showSystemDetails(systems[0]);\n            return;\n        }\n\n        const detailsPanel = this.overlayElement;\n        const detailsDiv = this.overlayElement.querySelector('.overlay-body');\n        const detailTitle = this.overlayElement.querySelector('.detail-title');\n\n        // Set title for multiple systems\n        detailTitle.textContent = `Selected Systems (${systems.length})`;\n        detailTitle.removeAttribute('data-system-id'); // Clear single system ID\n\n        // Generate multi-system content\n        const content = this.generateMultiSystemContent(systems);\n        detailsDiv.innerHTML = content;\n\n        // Update button states for multi-selection\n        this.updateMultiSelectButtons(systems);\n\n        // Show details panel\n        detailsPanel.classList.add('active');\n    }\n\n    /**\n     * Generates content for multiple system details\n     */\n    generateMultiSystemContent(systems) {\n        const data = this.dependencies.dataManager.getData();\n\n        // Get grouped properties for analysis\n        const grouped = this.dependencies.visualizer.getSelectedNodesGroupedProperties();\n\n        let html = `\n            <div class=\"multi-system-summary\">\n                <div class=\"row mb-3\">\n                    <div class=\"col-6\">\n                        <div class=\"card bg-light\">\n                            <div class=\"card-body text-center\">\n                                <h5 class=\"card-title text-primary\">${systems.length}</h5>\n                                <p class=\"card-text small mb-0\">Systems</p>\n                            </div>\n                        </div>\n                    </div>\n                    <div class=\"col-6\">\n                        <div class=\"card bg-light\">\n                            <div class=\"card-body text-center\">\n                                <h5 class=\"card-title text-success\">${grouped.knownUsage.true}</h5>\n                                <p class=\"card-text small mb-0\">Usages</p>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>`;\n\n        // Categories breakdown\n        const categoryEntries = Object.entries(grouped.categories);\n        if (categoryEntries.length > 0) {\n            html += `<h6 class=\"mt-3\">Categories</h6>`;\n            categoryEntries.forEach(([category, count]) => {\n                const percentage = Math.round((count / systems.length) * 100);\n                html += `\n                <div class=\"d-flex justify-content-between align-items-center mb-1\">\n                    <span class=\"badge bg-${this.dependencies.visualizer.getCategoryClass(category)}\">${category}</span>\n                    <span class=\"text-muted\">${count} (${percentage}%)</span>\n                </div>\n            `;\n            });\n        }\n\n        // Status breakdown\n        const statusEntries = Object.entries(grouped.statuses);\n        if (statusEntries.length > 0) {\n            html += `<h6 class=\"mt-3\">Status</h6>`;\n            statusEntries.forEach(([status, count]) => {\n                const percentage = Math.round((count / systems.length) * 100);\n                html += `\n                    <div class=\"d-flex justify-content-between align-items-center mb-1\">\n                        <span class=\"badge bg-secondary\">${status}</span>\n                        <span class=\"text-muted\">${count} (${percentage}%)</span>\n                    </div>\n                `;\n            });\n        }\n\n        // Groups breakdown\n        const groupEntries = Object.entries(grouped.groups);\n        if (groupEntries.length > 0) {\n            html += `<h6 class=\"mt-3\">Groups</h6>`;\n            groupEntries.forEach(([group, count]) => {\n                const percentage = Math.round((count / systems.length) * 100);\n                html += `\n                    <div class=\"d-flex justify-content-between align-items-center mb-1\">\n                        <span class=\"badge bg-info\">${group}</span>\n                        <span class=\"text-muted\">${count} (${percentage}%)</span>\n                    </div>\n                `;\n            });\n        }\n\n        // Connections summary\n        const totalIncoming = systems.reduce((sum, system) => {\n            return sum + data.dependencies.filter(dep => dep.target === system.id).length;\n        }, 0);\n\n        const totalOutgoing = systems.reduce((sum, system) => {\n            return sum + data.dependencies.filter(dep => dep.source === system.id).length;\n        }, 0);\n\n        if (totalIncoming > 0 || totalOutgoing > 0) {\n            html += `\n                <h6 class=\"mt-3\">Connections Summary</h6>\n                <div class=\"row\">\n                    <div class=\"col-6\">\n                        <div class=\"text-center\">\n                            <div class=\"text-success h5\">${totalIncoming}</div>\n                            <small class=\"text-muted\">Incoming</small>\n                        </div>\n                    </div>\n                    <div class=\"col-6\">\n                        <div class=\"text-center\">\n                            <div class=\"text-warning h5\">${totalOutgoing}</div>\n                            <small class=\"text-muted\">Outgoing</small>\n                        </div>\n                    </div>\n                </div>\n            `;\n        }\n\n        // Systems list (collapsible)\n        html += `\n            <div class=\"accordion mt-3\" id=\"systemsAccordion\">\n                <div class=\"accordion-item\">\n                    <h2 class=\"accordion-header\" id=\"systemsHeading\">\n                        <button class=\"accordion-button collapsed\" type=\"button\" data-bs-toggle=\"collapse\" \n                                data-bs-target=\"#systemsList\" aria-expanded=\"false\" aria-controls=\"systemsList\">\n                            Individual Systems (${systems.length})\n                        </button>\n                    </h2>\n                    <div id=\"systemsList\" class=\"accordion-collapse collapse\" aria-labelledby=\"systemsHeading\">\n                        <div class=\"accordion-body p-2\">\n        `;\n\n        systems.forEach(system => {\n            html += `\n                <div class=\"card mb-2\">\n                    <div class=\"card-body p-2\">\n                        <div class=\"d-flex justify-content-between align-items-start\">\n                            <div>\n                                <h6 class=\"card-title mb-1\">${system.name}</h6>\n                                <p class=\"card-text small text-muted mb-1\">${system.description}</p>\n                                <div>\n                                    <span class=\"badge bg-${this.dependencies.visualizer.getCategoryClass(system.category)} me-1\">${system.category}</span>\n                                    <span class=\"badge bg-secondary\">${system.status}</span>\n                                </div>\n                            </div>\n                            <button class=\"btn btn-sm btn-outline-primary\" onclick=\"window.visualizer.clearSelection(); window.visualizer.addToSelection('${system.id}');\">\n                                <i class=\"bi bi-eye\"></i>\n                            </button>\n                        </div>\n                    </div>\n                </div>\n            `;\n        });\n\n        html += `\n                    </div>\n                </div>\n            </div>\n        </div>\n    `;\n\n        return html;\n    }\n\n    toggle() {\n        document.querySelectorAll('.overlay').forEach(overlay => {\n            if (overlay !== this.overlayElement) overlay.classList.remove('active');\n        });\n        if (this.overlayElement.classList.contains('active')) {\n            this.hide();\n        } else {\n            this.show();\n        }\n    }\n\n    onShow() {\n        this.overlayElement.classList.add('active');\n    }\n\n    onHide() {\n        this.overlayElement.classList.remove('active');\n    }\n\n    /**\n     * Resets buttons to single-system mode\n     */\n    resetButtonsToSingleMode() {\n        const editButton = this.overlayElement.querySelector('.edit-system-btn');\n        const deleteButton = this.overlayElement.querySelector('.delete-system-btn');\n        const toggleButton = this.overlayElement.querySelector('.toggle-fix-btn');\n\n        // Reset edit button\n        if (editButton) {\n            editButton.disabled = false;\n            editButton.classList.remove('d-none'); // Hide for multi-selection\n        }\n\n        // Reset delete button\n        if (deleteButton) {\n            deleteButton.disabled = false;\n            deleteButton.title = 'Delete system';\n            deleteButton.innerHTML = '<i class=\"bi bi-trash\"></i>';\n        }\n\n        // Reset toggle button (will be updated by existing logic in showSystemDetails)\n        if (toggleButton) {\n            toggleButton.disabled = false;\n            toggleButton.classList.remove('active');\n            toggleButton.title = 'Lock system';\n            toggleButton.innerHTML = '<i class=\"bi bi-lock\"></i>';\n        }\n    }\n\n    /**\n     * Updates button states for multi-selection\n     */\n    updateMultiSelectButtons(systems) {\n        const editButton = this.overlayElement.querySelector('.edit-system-btn');\n        const deleteButton = this.overlayElement.querySelector('.delete-system-btn');\n        const toggleButton = this.overlayElement.querySelector('.toggle-fix-btn');\n\n        // Disable edit button for multi-selection (could be enabled later for bulk edit)\n        if (editButton) {\n            editButton.disabled = true;\n            editButton.classList.add('d-none'); // Hide for multi-selection\n        }\n\n        // Update delete button for multi-selection\n        if (deleteButton) {\n            deleteButton.disabled = false;\n            deleteButton.title = `Delete ${systems.length} systems`;\n            deleteButton.innerHTML = '<i class=\"bi bi-trash\"></i>';\n        }\n\n        // Update toggle button for multi-selection\n        if (toggleButton) {\n            const selectedIds = systems.map(s => s.id);\n            const hasUnfixedNodes = selectedIds.some(id => !this.dependencies.visualizer.isNodeFixed(id));\n\n            toggleButton.disabled = false;\n            if (hasUnfixedNodes) {\n                toggleButton.classList.remove('active');\n                toggleButton.title = `Fix ${systems.length} systems`;\n                toggleButton.innerHTML = '<i class=\"bi bi-lock\"></i>';\n            } else {\n                toggleButton.classList.add('active');\n                toggleButton.title = `Release ${systems.length} systems`;\n                toggleButton.innerHTML = '<i class=\"bi bi-unlock\"></i>';\n            }\n        }\n    }\n\n    /**\n     * Displays the system details in the overlay\n     */\n    showSystemDetails(system) {\n        const detailsPanel = this.overlayElement;\n        const detailsDiv = this.overlayElement.querySelector('.overlay-body');\n        const detailTitle = this.overlayElement.querySelector('.detail-title');\n        const data = this.dependencies.dataManager.getData();\n\n        // Set title\n        detailTitle.textContent = system.name;\n        detailTitle.setAttribute('data-system-id', system.id);\n\n        // Find incoming and outgoing dependencies\n        const incomingDeps = data.dependencies.filter(dep => dep.target === system.id);\n        const outgoingDeps = data.dependencies.filter(dep => dep.source === system.id);\n\n        let html = `\n        <div class=\"system-detail-card\">\n            <p class=\"mb-1\">${system.description}</p>\n            <div class=\"badge bg-${this.dependencies.visualizer.getCategoryClass(system.category)} mb-2\">${system.category}</div>\n            <p><strong>Status:</strong> ${system.status}</p>\n            <p><strong>Known Usage:</strong> ${system.knownUsage ? 'Yes' : 'No'}</p>\n        `;\n\n        // Add group information - multi-group support\n        const groups = [];\n        if (Array.isArray(system.groups) && system.groups.length > 0) {\n            groups.push(...system.groups);\n        } else if (system.group && typeof system.group === 'string') {\n            groups.push(system.group);\n        }\n\n        if (groups.length > 0) {\n            html += `<p><strong>Groups:</strong> ${groups.map(group =>\n                `<span class=\"badge bg-info\">${group}</span>`).join(' ')}</p>`;\n        }\n\n        if (system.tags && system.tags.length > 0) {\n            html += `<p><strong>Tags:</strong> ${system.tags.map(tag =>\n                `<span class=\"badge bg-secondary\">${tag}</span>`).join(' ')}</p>`;\n        }\n\n        if (incomingDeps.length > 0) {\n            html += `<h6 class=\"mt-3\">Incoming Connections</h6><ul class=\"list-group\">`;\n            incomingDeps.forEach(dep => {\n                const source = data.systems.find(s => s.id === dep.source);\n                html += `\n                <li class=\"list-group-item\">\n                    <div class=\"d-flex w-100 justify-content-between\">\n                        <strong>${source ? source.name : 'Unknown'}</strong>\n                        <span class=\"badge bg-secondary\">${dep.protocol || 'Unknown'}</span>\n                    </div>\n                    <small>${dep.description || 'No description'}</small>\n                </li>`;\n            });\n            html += `</ul>`;\n        }\n\n        if (outgoingDeps.length > 0) {\n            html += `<h6 class=\"mt-3\">Outgoing Connections</h6><ul class=\"list-group\">`;\n            outgoingDeps.forEach(dep => {\n                const target = data.systems.find(s => s.id === dep.target);\n                html += `\n                <li class=\"list-group-item\">\n                    <div class=\"d-flex w-100 justify-content-between\">\n                        <strong>${target ? target.name : 'Unknown'}</strong>\n                        <span class=\"badge bg-secondary\">${dep.protocol || 'Unknown'}</span>\n                    </div>\n                    <small>${dep.description || 'No description'}</small>\n                </li>`;\n            });\n            html += `</ul>`;\n        }\n\n        if (incomingDeps.length === 0 && outgoingDeps.length === 0) {\n            html += `<div class=\"alert alert-warning mt-3\">This system has no known connections.</div>`;\n        }\n\n        html += `</div>`;\n\n        detailsDiv.innerHTML = html;\n\n        // Show details panel\n        detailsPanel.classList.add('active');\n\n        this.resetButtonsToSingleMode();\n\n        // Adjust button state\n        const toggleFixButton = document.querySelector('.toggle-fix-btn');\n        const isFixed = this.dependencies.visualizer.isNodeFixed(system.id);\n        if (toggleFixButton) {\n            if (isFixed) {\n                toggleFixButton.classList.add('active');\n                toggleFixButton.title = 'Release position';\n            } else {\n                toggleFixButton.classList.remove('active');\n                toggleFixButton.title = 'Fix position';\n            }\n        }\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/details-overlay.js?");

/***/ }),

/***/ "./src/ui/components/download.js":
/*!***************************************!*\
  !*** ./src/ui/components/download.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DownloadHelper: () => (/* binding */ DownloadHelper)\n/* harmony export */ });\n/* harmony import */ var _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/ui-component.js */ \"./src/ui/base/ui-component.js\");\n/* harmony import */ var _utils_data_loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/data-loader.js */ \"./src/utils/data-loader.js\");\n\n\n\nclass DownloadHelper extends _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__.UIComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n    }\n\n    bindEvents() {\n        this.dependencies.toolbar.button('bi-download', 'Download data', () => {\n            (0,_utils_data_loader_js__WEBPACK_IMPORTED_MODULE_1__.downloadSystemData)(this.dependencies.dataManager);\n        }, 'import-export');\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/download.js?");

/***/ }),

/***/ "./src/ui/components/edit-system.js":
/*!******************************************!*\
  !*** ./src/ui/components/edit-system.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditSystemComponent: () => (/* binding */ EditSystemComponent)\n/* harmony export */ });\n/* harmony import */ var _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/overlay-component.js */ \"./src/ui/base/overlay-component.js\");\n/* harmony import */ var _utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utilities.js */ \"./src/utils/utilities.js\");\n\n\n\nconst editSystemModalTemplate = () => `\n    <div class=\"modal fade\" id=\"system-modal\" tabindex=\"-1\" aria-labelledby=\"system-modal-label\" aria-hidden=\"true\">\n        <div class=\"modal-dialog\">\n            <div class=\"modal-content\">\n                <div class=\"modal-header\">\n                    <h5 class=\"modal-title\" id=\"system-modal-label\">Add system</h5>\n                    <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n                </div>\n                <div class=\"modal-body\">\n                    <form id=\"system-form\">\n                        <input type=\"hidden\" id=\"system-id\">\n                        <div class=\"mb-3\">\n                            <label for=\"system-name\" class=\"form-label\">Name*</label>\n                            <input type=\"text\" class=\"form-control\" id=\"system-name\" required>\n                        </div>\n                        <div class=\"mb-3\">\n                            <label for=\"system-description\" class=\"form-label\">Description*</label>\n                            <textarea class=\"form-control\" id=\"system-description\" rows=\"3\" required></textarea>\n                        </div>\n                        <div class=\"mb-3\">\n                            <label for=\"system-category\" class=\"form-label\">Category*</label>\n                            <select class=\"form-select\" id=\"system-category\" required>\n                                <option value=\"core\">Core</option>\n                                <option value=\"legacy\">Legacy</option>\n                                <option value=\"data\">Data</option>\n                                <option value=\"service\">Service</option>\n                                <option value=\"external\">External</option>\n                            </select>\n                        </div>\n                        <div class=\"mb-3\">\n                            <label for=\"system-groups-input\" class=\"form-label\">Groups</label>\n                            <div class=\"input-group\">\n                                <input type=\"text\" class=\"form-control\" id=\"system-groups-input\" list=\"group-list\"\n                                    placeholder=\"Add group...\">\n                                <button class=\"btn btn-outline-secondary\" type=\"button\" id=\"add-group-btn\">\n                                    <i class=\"bi bi-plus\"></i>\n                                </button>\n                            </div>\n                            <div class=\"form-text\">Separate multiple groups with commas or add individually</div>\n\n                            <div id=\"system-groups-container\" class=\"mt-2 d-flex flex-wrap gap-2\">\n                                <!-- Selected groups will be shown as badges here -->\n                            </div>\n\n                            <input type=\"hidden\" id=\"system-groups-value\">\n\n                            <datalist id=\"group-list\">\n                                <!-- Filled dynamically -->\n                            </datalist>\n                        </div>\n                        <div class=\"mb-3\">\n                            <label for=\"system-status\" class=\"form-label\">Status*</label>\n                            <select class=\"form-select\" id=\"system-status\" required>\n                                <option value=\"active\">Active</option>\n                                <option value=\"planned\">Planned</option>\n                                <option value=\"deprecated\">Deprecated</option>\n                                <option value=\"retired\">Retired</option>\n                            </select>\n                        </div>\n                        <div class=\"mb-3 form-check\">\n                            <input type=\"checkbox\" class=\"form-check-input\" id=\"system-known-usage\" checked>\n                            <label class=\"form-check-label\" for=\"system-known-usage\">Known usage</label>\n                        </div>\n                        <div class=\"mb-3\">\n                            <label for=\"system-tags\" class=\"form-label\">Tags (comma separated)</label>\n                            <input type=\"text\" class=\"form-control\" id=\"system-tags\">\n                        </div>\n                    </form>\n                </div>\n                <div class=\"modal-footer\">\n                    <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Cancel</button>\n                    <button type=\"button\" class=\"btn btn-primary\" id=\"save-system\">Save</button>\n                </div>\n            </div>\n        </div>\n    </div>\n`;\n\nclass EditSystemComponent extends _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__.OverlayComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n        this.modalElement = null;\n        this.modal = null;\n    }\n\n    setupDOM() {\n        this.modalElement = this.render(editSystemModalTemplate());\n        this.element.appendChild(this.modalElement);\n        this.modal = new bootstrap.Modal(this.modalElement);\n    }\n\n    bindEvents() {\n        const groupInput = this.modalElement.querySelector('#system-groups-input');\n        const addButton = this.modalElement.querySelector('#add-group-btn');\n\n        // Event-Listener für das Hinzufügen von Gruppen mit dem Button\n        addButton.addEventListener('click', () => {\n            const value = groupInput.value.trim();\n            if (value) {\n                // Wenn Kommas enthalten sind, mehrere Gruppen gleichzeitig hinzufügen\n                if (value.includes(',')) {\n                    const groups = value.split(',').map(g => g.trim()).filter(g => g !== '');\n                    groups.forEach(group => this.addGroupBadge(group));\n                } else {\n                    this.addGroupBadge(value);\n                }\n                groupInput.value = '';\n            }\n        });\n\n        // Event-Listener für das Hinzufügen von Gruppen mit Enter\n        groupInput.addEventListener('keydown', (event) => {\n            if (event.key === 'Enter') {\n                event.preventDefault();\n                addButton.click();\n            }\n        });\n\n        // Auto-Vervollständigung bei Komma\n        groupInput.addEventListener('input', () => {\n            const value = groupInput.value;\n            if (value.endsWith(',')) {\n                const newGroup = value.slice(0, -1).trim();\n                if (newGroup) {\n                    this.addGroupBadge(newGroup);\n                    groupInput.value = '';\n                }\n            }\n        });\n\n        this.dependencies.toolbar.button('bi-plus-lg', 'Add element', () => {\n            this.showSystemModal()\n        }, 'create');\n\n        this.modalElement.querySelector('#save-system').addEventListener('click', () => this.saveSystem());\n    }\n\n    /**\n     * Shows the system modal for adding or editing\n     * @param {string} systemId - The ID of the system to edit (null for adding)\n     */\n    showSystemModal(systemId = null) {\n        // Set modal title depending on action (add or edit)\n        this.modalElement.querySelector('#system-modal-label').textContent = systemId ? 'Edit System' : 'Add System';\n\n        const form = this.modalElement.querySelector('#system-form');\n\n        // Reset form\n        form.reset();\n\n        // Clear groups container\n        const groupsContainer = this.modalElement.querySelector('#system-groups-container');\n        if (groupsContainer) {\n            groupsContainer.innerHTML = '';\n        }\n\n        const groupsValueField = this.modalElement.querySelector('#system-groups-value');\n        if (groupsValueField) {\n            groupsValueField.value = '';\n        }\n\n        // If systemId exists, fill form data with system data\n        if (systemId) {\n            const system = this.dependencies.dataManager.getData().systems.find(sys => sys.id === systemId);\n            if (system) {\n                this.currentEditingSystem = system;\n\n                // Fill form with system data\n                this.modalElement.querySelector('#system-id').value = system.id;\n                this.modalElement.querySelector('#system-name').value = system.name;\n                this.modalElement.querySelector('#system-description').value = system.description;\n                this.modalElement.querySelector('#system-category').value = system.category;\n                this.modalElement.querySelector('#system-status').value = system.status;\n                this.modalElement.querySelector('#system-known-usage').checked = system.knownUsage;\n\n                // Add groups as badges\n                const groups = [];\n                if (Array.isArray(system.groups)) {\n                    system.groups.forEach(group => this.addGroupBadge(group));\n                    groups.push(...system.groups);\n                } else if (system.group && typeof system.group === 'string') {\n                    this.addGroupBadge(system.group);\n                    groups.push(system.group);\n                }\n\n                // Store groups in hidden field\n                if (groupsValueField) {\n                    groupsValueField.value = groups.join(',');\n                }\n\n                // Display tags as comma-separated list\n                if (system.tags && Array.isArray(system.tags)) {\n                    this.modalElement.querySelector('#system-tags').value = system.tags.join(', ');\n                } else {\n                    this.modalElement.querySelector('#system-tags').value = '';\n                }\n            }\n        } else {\n            // New system, clear ID field\n            this.modalElement.querySelector('#system-id').value = '';\n            this.currentEditingSystem = null;\n        }\n\n        // Fill group list (for datalist)\n        const groupList = this.modalElement.querySelector('#group-list');\n        if (groupList) {\n            groupList.innerHTML = '';\n\n            // Collect existing groups\n            const groups = this.dependencies.dataManager.getAllGroups ?\n                this.dependencies.dataManager.getAllGroups() : this.getExistingGroups();\n\n            // Fill group list\n            groups.forEach(group => {\n                const option = document.createElement('option');\n                option.value = group;\n                groupList.appendChild(option);\n            });\n        }\n\n        this.show();\n    }\n\n    onShow() {\n        this.modal.show();\n    }\n\n    onHide() {\n        this.modal.hide();\n    }\n\n    /**\n     * Saves a new or edited system\n     */\n    saveSystem() {\n        // Collect form data\n        const systemId = this.modalElement.querySelector('#system-id').value;\n        const name = this.modalElement.querySelector('#system-name').value;\n        const description = this.modalElement.querySelector('#system-description').value;\n        const category = this.modalElement.querySelector('#system-category').value;\n        const status = this.modalElement.querySelector('#system-status').value;\n        const knownUsage = this.modalElement.querySelector('#system-known-usage').checked;\n\n        // Create groups array - support for old and new UI format\n        let groups = [];\n\n        // New UI (with system-groups-value as hidden field)\n        const groupsValueField = this.modalElement.querySelector('#system-groups-value');\n        if (groupsValueField) {\n            groups = groupsValueField.value\n                ? groupsValueField.value.split(',').map(g => g.trim()).filter(g => g !== '')\n                : [];\n        }\n        // Old UI (with system-group as direct input)\n        else {\n            const groupField = this.modalElement.querySelector('#system-group');\n            if (groupField && groupField.value.trim() !== '') {\n                // Check for commas (for manual multi-group input)\n                if (groupField.value.includes(',')) {\n                    groups = groupField.value.split(',').map(g => g.trim()).filter(g => g !== '');\n                } else {\n                    groups = [groupField.value.trim()];\n                }\n            }\n        }\n\n        // Convert tags from comma-separated list to array\n        const tagsString = this.modalElement.querySelector('#system-tags').value;\n        const tags = tagsString\n            ? tagsString.split(',').map(tag => tag.trim()).filter(tag => tag)\n            : [];\n\n        // Form validation\n        if (!name || !description || !category || !status) {\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)('Please fill in all required fields', 'warning');\n            return;\n        }\n\n        // Create new system object\n        const updatedSystem = {\n            id: systemId || this.dependencies.dataManager.generateUniqueId(),\n            name,\n            description,\n            category,\n            status,\n            knownUsage,\n            tags,\n            groups // New multi-group array\n        };\n\n        // For backward compatibility also set the single group field\n        if (groups.length > 0) {\n            updatedSystem.group = groups[0];\n        }\n\n        // Add or update the system\n        if (!systemId) {\n            // Add new system\n            this.dependencies.dataManager.addSystem(updatedSystem);\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(`System \"${name}\" has been added`, 'success');\n        } else {\n            // Update existing system\n            this.dependencies.dataManager.updateSystem(updatedSystem);\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(`System \"${name}\" has been updated`, 'success');\n        }\n\n        // Close modal\n        this.hide();\n    }\n\n    /**\n     * Adds a group as a badge to the container\n     * @param {string} groupName - Name of the group\n     */\n    addGroupBadge(groupName) {\n        if (!groupName || groupName.trim() === '') return;\n\n        const container = this.modalElement.querySelector('#system-groups-container');\n        const hiddenField = this.modalElement.querySelector('#system-groups-value');\n\n        if (!container || !hiddenField) {\n            console.warn('Group UI elements not found. Multi-group UI may not be initialized.');\n            return;\n        }\n\n        // Check if the group has already been added\n        const currentGroups = hiddenField.value ? hiddenField.value.split(',') : [];\n        if (currentGroups.includes(groupName)) return;\n\n        // Create badge\n        const badge = document.createElement('span');\n        badge.className = 'badge bg-primary d-flex align-items-center';\n        badge.innerHTML = `\n            ${groupName}\n            <button type=\"button\" class=\"btn-close btn-close-white ms-2\" \n                    aria-label=\"Remove\" style=\"font-size: 0.5rem;\"></button>\n        `;\n\n        // Delete button\n        badge.querySelector('.btn-close').addEventListener('click', () => {\n            container.removeChild(badge);\n\n            // Remove value from hidden field\n            const groups = hiddenField.value.split(',');\n            const index = groups.indexOf(groupName);\n            if (index !== -1) {\n                groups.splice(index, 1);\n                hiddenField.value = groups.join(',');\n            }\n        });\n\n        // Add to container\n        container.appendChild(badge);\n\n        // Add to hidden field\n        const newGroups = [...currentGroups, groupName];\n        hiddenField.value = newGroups.join(',');\n    }\n\n    /**\n     * Helper function to collect all existing groups\n     * (Only needed if getAllGroups is not implemented in DataManager)\n     * @returns {Array} Array of unique group names\n     */\n    getExistingGroups() {\n        const groups = new Set();\n\n        this.dependencies.dataManager.getData().systems.forEach(system => {\n            if (Array.isArray(system.groups)) {\n                system.groups.forEach(group => {\n                    if (group && group.trim() !== '') {\n                        groups.add(group);\n                    }\n                });\n            } else if (system.group && typeof system.group === 'string') {\n                groups.add(system.group);\n            }\n        });\n\n        return Array.from(groups).sort();\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/edit-system.js?");

/***/ }),

/***/ "./src/ui/components/export.js":
/*!*************************************!*\
  !*** ./src/ui/components/export.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExportImage: () => (/* binding */ ExportImage)\n/* harmony export */ });\n/* harmony import */ var _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/ui-component.js */ \"./src/ui/base/ui-component.js\");\n/* harmony import */ var _utils_data_loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/data-loader.js */ \"./src/utils/data-loader.js\");\n\n\n\nclass ExportImage extends _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__.UIComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n        this.dropupVisible = false;\n        this.dropupMenu = null;\n    }\n\n    bindEvents() {\n        this.exportButton = this.dependencies.toolbar.button('bi-image', 'Download image', (event) => {\n            event.stopPropagation();\n            this.exportImage();\n        }, 'import-export');\n    }\n    \n    exportImage() {\n        // If the menu is already shown, remove it\n        if (this.dropupVisible && this.dropupMenu) {\n            document.body.removeChild(this.dropupMenu);\n            this.dropupVisible = false;\n            return;\n        }\n\n        // Create a dropdown menu below the button\n        this.dropupMenu = document.createElement('div');\n        this.dropupMenu.className = 'dropdown-menu show';\n        this.dropupMenu.style.position = 'absolute';\n\n        // Calculate position (below the button as a dropdown)\n        const buttonRect = this.exportButton.getBoundingClientRect();\n        this.dropupMenu.style.top = (buttonRect.bottom + 5) + 'px'; // 5px gap to the button\n        this.dropupMenu.style.left = buttonRect.left + 'px';\n        this.dropupMenu.style.minWidth = '140px';\n        this.dropupMenu.style.backgroundColor = '#fff';\n        this.dropupMenu.style.border = '1px solid rgba(0,0,0,.15)';\n        this.dropupMenu.style.borderRadius = '.25rem';\n        this.dropupMenu.style.padding = '.5rem 0';\n        this.dropupMenu.style.zIndex = '1000';\n        this.dropupMenu.style.boxShadow = '0 0.5rem 1rem rgba(0, 0, 0, 0.15)';\n\n        // Add menu items\n        this.dropupMenu.innerHTML = `\n            <a class=\"dropdown-item px-3 py-2\" href=\"#\" id=\"download-svg\">\n                <i class=\"bi bi-filetype-svg me-2\"></i>As SVG\n            </a>\n            <a class=\"dropdown-item px-3 py-2\" href=\"#\" id=\"download-png\">\n                <i class=\"bi bi-filetype-png me-2\"></i>As PNG\n            </a>\n        `;\n\n        // Add to body\n        document.body.appendChild(this.dropupMenu);\n        this.dropupVisible = true;\n\n        // Event listeners for menu items\n        document.getElementById('download-svg').addEventListener('click', function (e) {\n            e.preventDefault();\n            (0,_utils_data_loader_js__WEBPACK_IMPORTED_MODULE_1__.downloadVisualizationAsSVG)();\n            document.body.removeChild(this.dropupMenu);\n            this.dropupVisible = false;\n        });\n\n        document.getElementById('download-png').addEventListener('click', function (e) {\n            e.preventDefault();\n            (0,_utils_data_loader_js__WEBPACK_IMPORTED_MODULE_1__.downloadVisualizationAsPNG)();\n            document.body.removeChild(this.dropupMenu);\n            this.dropupVisible = false;\n        });\n\n        // Clicking outside the menu closes it\n        document.addEventListener('click', function closeDropup(e) {\n            if (this.dropupVisible && !this.dropupMenu.contains(e.target) && e.target !== this.dependencies.exportButton) {\n                document.body.removeChild(this.dropupMenu);\n                this.dropupVisible = false;\n                document.removeEventListener('click', closeDropup);\n            }\n        });\n    }\n};\n\n//# sourceURL=webpack://infravis/./src/ui/components/export.js?");

/***/ }),

/***/ "./src/ui/components/filter.js":
/*!*************************************!*\
  !*** ./src/ui/components/filter.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FilterOverlay: () => (/* binding */ FilterOverlay)\n/* harmony export */ });\n/* harmony import */ var _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/overlay-component.js */ \"./src/ui/base/overlay-component.js\");\n\n\nconst createFilterOverlay = () => `\n    <div class=\"filter-overlay overlay\">\n        <div class=\"overlay-header\">\n            <h5>Filter</h5>\n            <button class=\"btn-close close-overlay\" data-close-target=\"filter-panel\"></button>\n        </div>\n        <div class=\"overlay-body\">\n            <h6>System categories</h6>\n            <div class=\"mb-3\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input category-filter\" type=\"checkbox\" id=\"filter-core\" value=\"core\"\n                        checked>\n                    <label class=\"form-check-label\" for=\"filter-core\">Core</label>\n                </div>\n                <div class=\"form-check\">\n                    <input class=\"form-check-input category-filter\" type=\"checkbox\" id=\"filter-legacy\"\n                        value=\"legacy\" checked>\n                    <label class=\"form-check-label\" for=\"filter-legacy\">Legacy</label>\n                </div>\n                <div class=\"form-check\">\n                    <input class=\"form-check-input category-filter\" type=\"checkbox\" id=\"filter-data\" value=\"data\"\n                        checked>\n                    <label class=\"form-check-label\" for=\"filter-data\">Data</label>\n                </div>\n                <div class=\"form-check\">\n                    <input class=\"form-check-input category-filter\" type=\"checkbox\" id=\"filter-service\"\n                        value=\"service\" checked>\n                    <label class=\"form-check-label\" for=\"filter-service\">Service</label>\n                </div>\n                <div class=\"form-check\">\n                    <input class=\"form-check-input category-filter\" type=\"checkbox\" id=\"filter-external\"\n                        value=\"external\" checked>\n                    <label class=\"form-check-label\" for=\"filter-external\">External</label>\n                </div>\n            </div>\n\n            <h6>System status</h6>\n            <div class=\"mb-3\">\n                <div class=\"form-check\">\n                    <input class=\"form-check-input status-filter\" type=\"checkbox\" id=\"filter-known\" value=\"known\"\n                        checked>\n                    <label class=\"form-check-label\" for=\"filter-known\">Known usage</label>\n                </div>\n                <div class=\"form-check\">\n                    <input class=\"form-check-input status-filter\" type=\"checkbox\" id=\"filter-unknown\"\n                        value=\"unknown\" checked>\n                    <label class=\"form-check-label\" for=\"filter-unknown\">Unknown usage</label>\n                </div>\n            </div>\n\n            <button class=\"btn btn-primary btn-sm w-100\" id=\"apply-filters\">Apply filters</button>\n        </div>\n    </div>\n`;\n\nclass FilterOverlay extends _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__.OverlayComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n    }\n\n    setupDOM() {\n        this.overlayElement = this.render(createFilterOverlay());\n        this.element.appendChild(this.overlayElement);\n    }\n\n    bindEvents() {\n        // Toolbar button to toggle search overlay\n        this.dependencies.toolbar.button('bi-funnel', 'Filter', () => {\n            this.toggle();\n        }, 'view');\n\n        // Close button\n        this.overlayElement.querySelector('.close-overlay').addEventListener('click', () => {\n            this.hide();\n        });\n\n        // Filter for system categories\n        const categoryFilters = this.overlayElement.querySelectorAll('.category-filter');\n        if (categoryFilters.length > 0) {\n            categoryFilters.forEach(filter => {\n                filter.addEventListener('change', () => {\n                    const checkedCategories = Array.from(document.querySelectorAll('.category-filter:checked'))\n                        .map(checkbox => checkbox.value);\n                    this.dependencies.visualizer.activeFilters.categories = checkedCategories;\n                });\n            });\n        }\n\n        // Filter for system status\n        const statusFilters = this.overlayElement.querySelectorAll('.status-filter');\n        if (statusFilters.length > 0) {\n            statusFilters.forEach(filter => {\n                filter.addEventListener('change', () => {\n                    const checkedStatuses = Array.from(document.querySelectorAll('.status-filter:checked'))\n                        .map(checkbox => checkbox.value);\n                    this.dependencies.visualizer.activeFilters.knownUsage = checkedStatuses;\n                });\n            });\n        }\n\n        // Apply filters\n        const applyFiltersButton = this.overlayElement.querySelector('#apply-filters');\n        if (applyFiltersButton) {\n            applyFiltersButton.addEventListener('click', () => {\n                this.dependencies.visualizer.applyFilters();\n                this.hide();\n            });\n        }\n    }\n\n    toggle() {\n        document.querySelectorAll('.overlay').forEach(overlay => {\n            if (overlay !== this.overlayElement) overlay.classList.remove('active');\n        });\n        if (this.overlayElement.classList.contains('active')) {\n            this.hide();\n        } else {\n            this.show();\n        }\n    }\n\n    onShow() {\n        this.overlayElement.classList.add('active');\n    }\n\n    onHide() {\n        this.overlayElement.classList.remove('active');\n    }\n\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/filter.js?");

/***/ }),

/***/ "./src/ui/components/history.js":
/*!**************************************!*\
  !*** ./src/ui/components/history.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HistoryHelper: () => (/* binding */ HistoryHelper)\n/* harmony export */ });\n/* harmony import */ var _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/ui-component.js */ \"./src/ui/base/ui-component.js\");\n\n\nclass HistoryHelper extends _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__.UIComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n    }\n\n    setupDOM() {\n    }\n\n    bindEvents() {\n        this.undoBtn = this.dependencies.toolbar.button('bi-arrow-counterclockwise', 'Undo', () => {\n            this.dependencies.historyManager.undo();\n        }, 'history', [\"upload-data\"]);\n        this.redoBtn = this.dependencies.toolbar.button('bi-arrow-clockwise', 'Redo', () => {\n            this.dependencies.historyManager.redo();\n        }, 'history', [\"download-data\"]);\n\n        this.dependencies.historyManager.on('historyUpdated', () => {\n            this.updateUI();\n        });\n\n        this.updateUI();\n    }\n\n    updateUI() {\n        if (this.undoBtn) {\n            this.undoBtn.disabled = !this.dependencies.historyManager.canUndo();\n            this.undoBtn.title = this.dependencies.historyManager.canUndo() ? 'Undo (Ctrl+Z)' : 'Nothing to undo';\n        }\n\n        if (this.redoBtn) {\n            this.redoBtn.disabled = !this.dependencies.historyManager.canRedo();\n            this.redoBtn.title = this.dependencies.historyManager.canRedo() ? 'Redo (Ctrl+Shift+Z)' : 'Nothing to redo';\n        }\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/history.js?");

/***/ }),

/***/ "./src/ui/components/legend.js":
/*!*************************************!*\
  !*** ./src/ui/components/legend.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LegendOverlay: () => (/* binding */ LegendOverlay)\n/* harmony export */ });\n/* harmony import */ var _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/overlay-component.js */ \"./src/ui/base/overlay-component.js\");\n\n\nconst createLegendOverlay = () => `\n    <div class=\"legend-overlay overlay\">\n        <div class=\"overlay-header\">\n            <h5>Legend</h5>\n            <button class=\"btn-close close-overlay\"></button>\n        </div>\n        <div class=\"overlay-body\">\n            <h6>System categories</h6>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background-color: #0d6efd;\"></div>\n                <div>Core system</div>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background-color: #6c757d;\"></div>\n                <div>Legacy system</div>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background-color: #198754;\"></div>\n                <div>Data system</div>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background-color: #ffc107;\"></div>\n                <div>Service system</div>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background-color: #dc3545;\"></div>\n                <div>External system</div>\n            </div>\n\n            <h6 class=\"mt-3\">System status</h6>\n            <div class=\"legend-item\">\n                <div style=\"width: 20px; height: 20px; border-radius: 50%; border: 2px solid #666;margin-right: 1rem;\"></div>\n                <div>Known usage</div>\n            </div>\n            <div class=\"legend-item\">\n                <div style=\"width: 20px; height: 20px; border-radius: 50%; border: 2px dashed #666;margin-right: 1rem;\"></div>\n                <div>Unknown usage</div>\n            </div>\n\n            <h6 class=\"mt-3\">Connection types</h6>\n            <div class=\"legend-item\">\n                <div style=\"width: 20px; height: 3px; background-color: #0d6efd;margin-right: 1rem;\"></div>\n                <div>Data exchange</div>\n            </div>\n            <div class=\"legend-item\">\n                <div style=\"width: 20px; height: 3px; background-color: #198754;margin-right: 1rem;\"></div>\n                <div>Integration</div>\n            </div>\n            <div class=\"legend-item\">\n                <div style=\"width: 20px; height: 3px; background-color: #dc3545;margin-right: 1rem;\"></div>\n                <div>Authentication</div>\n            </div>\n            <div class=\"legend-item\">\n                <div style=\"width: 20px; height: 3px; background-color: #6c757d;margin-right: 1rem;\"></div>\n                <div>Monitoring</div>\n            </div>\n        </div>\n    </div>\n`;\n\nclass LegendOverlay extends _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__.OverlayComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n    }\n\n    setupDOM() {\n        this.overlayElement = this.render(createLegendOverlay());\n        this.element.appendChild(this.overlayElement);\n    }\n\n    bindEvents() {\n        // Toolbar button to toggle search overlay\n        this.dependencies.toolbar.button('bi-info-circle', 'Legend', () => {\n            this.toggle();\n        }, 'view');\n\n        // Close button\n        this.overlayElement.querySelector('.close-overlay').addEventListener('click', () => {\n            this.hide();\n        });\n    }\n\n    toggle() {\n        document.querySelectorAll('.overlay').forEach(overlay => {\n            if (overlay !== this.overlayElement) overlay.classList.remove('active');\n        });\n        if (this.overlayElement.classList.contains('active')) {\n            this.hide();\n        } else {\n            this.show();\n        }\n    }\n\n    onShow() {\n        this.overlayElement.classList.add('active');\n    }\n\n    onHide() {\n        this.overlayElement.classList.remove('active');\n    }\n\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/legend.js?");

/***/ }),

/***/ "./src/ui/components/multi-select.js":
/*!*******************************************!*\
  !*** ./src/ui/components/multi-select.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultiSelectComponent: () => (/* binding */ MultiSelectComponent)\n/* harmony export */ });\n/* harmony import */ var _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/ui-component.js */ \"./src/ui/base/ui-component.js\");\n/* harmony import */ var _utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utilities.js */ \"./src/utils/utilities.js\");\n\n\n\nclass MultiSelectComponent extends _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__.UIComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n\n        this.initialized = false;\n        this.isRectSelectModeActive = false;\n        this.isDrawing = false;\n        this.startPoint = null;\n        this.selectionRect = null;\n        \n        // Selection rectangle properties\n        this.rectSelectOptions = {\n            minRectSize: 10, // Minimum size to register as selection\n            enableOnEmptySpace: true, // Only start on empty space\n            modifierKey: 'none' // 'ctrl', 'shift', 'alt', or 'none'\n        };\n    }\n\n    bindEvents() {\n        // Toolbar button for rectangle selection mode\n        this.toggleRectSelectButton = this.dependencies.toolbar.button(\n            'bi-bounding-box', \n            'Rectangle selection', \n            () => {\n                this.toggleRectSelectMode();\n            }, \n            'view', \n            ['toggle-rect-select']\n        );\n\n        // Listen to visualizer events\n        this.dependencies.visualizer.on('selectionChanged', (data) => {\n            this.updateSelectionInfo(data);\n        });\n\n        // Data changes might affect rectangle select mode\n        this.dependencies.dataManager.on('dataChanged', () => {\n            if (this.isRectSelectModeActive) {\n                // Short delay to wait for UI update\n                setTimeout(() => {\n                    this.setupRectangleSelection();\n                }, 100);\n            }\n        });\n    }\n\n    /**\n     * Toggles the rectangle selection mode on/off\n     */\n    toggleRectSelectMode() {\n        this.isRectSelectModeActive = !this.isRectSelectModeActive;\n        const toggleButton = this.toggleRectSelectButton;\n\n        if (this.isRectSelectModeActive) {\n            document.body.classList.add('multi-select-mode');\n            toggleButton.classList.add('active');\n            toggleButton.title = 'Exit rectangle selection';\n            toggleButton.querySelector('i').className = 'bi bi-bounding-box-circles';\n\n            // Disable zoom/pan and node drag\n            this.disableZoomAndDrag();\n            this.setupRectangleSelection();\n\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)('Rectangle selection enabled: Drag to select multiple systems', 'info');\n        } else {\n            document.body.classList.remove('multi-select-mode');\n            toggleButton.classList.remove('active');\n            toggleButton.title = 'Rectangle selection';\n            toggleButton.querySelector('i').className = 'bi bi-bounding-box';\n\n            // Re-enable zoom/pan and node drag\n            this.removeRectangleSelection();\n            this.enableZoomAndDrag();\n\n            this.hideSelectionInfo();\n        }\n    }\n\n    /**\n     * Disables zoom/pan and node dragging\n     */\n    disableZoomAndDrag() {\n        // Disable zoom/pan\n        if (this.dependencies.visualizer.svg && this.dependencies.visualizer.zoom) {\n            this.dependencies.visualizer.svg.on('.zoom', null);\n        }\n        \n        // Disable node dragging\n        this.dependencies.visualizer.disableDrag();\n    }\n\n    /**\n     * Re-enables zoom/pan and node dragging\n     */\n    enableZoomAndDrag() {\n        // Re-enable zoom/pan\n        if (this.dependencies.visualizer.svg && this.dependencies.visualizer.zoom) {\n            this.dependencies.visualizer.svg.call(this.dependencies.visualizer.zoom);\n        }\n        \n        // Re-enable node dragging\n        this.dependencies.visualizer.enableDrag();\n    }\n\n    /**\n     * Sets up the rectangle selection mechanism\n     */\n    setupRectangleSelection() {\n        if (!this.dependencies.visualizer.svg) return;\n\n        // Remove existing rectangle selection if present\n        this.removeRectangleSelection();\n\n        // Now we can use D3's drag behavior safely since zoom is disabled\n        const rectDrag = d3.drag()\n            .on(\"start\", (event) => this.handleRectDragStart(event))\n            .on(\"drag\", (event) => this.handleRectDragMove(event))\n            .on(\"end\", (event) => this.handleRectDragEnd(event))\n            .filter((event) => this.shouldStartRectSelection(event));\n\n        // Apply to the SVG element\n        this.dependencies.visualizer.svg.call(rectDrag);\n    }\n\n    /**\n     * Removes the rectangle selection mechanism\n     */\n    removeRectangleSelection() {\n        if (!this.dependencies.visualizer.svg) return;\n\n        // Remove rectangle selection drag\n        this.dependencies.visualizer.svg.on('.drag', null);\n\n        // Clean up any existing selection rectangle\n        this.cleanupSelectionRect();\n    }\n\n    /**\n     * Determines if rectangle selection should start based on the event\n     */\n    shouldStartRectSelection(event) {\n        // Safely get the source event and target\n        const sourceEvent = event.sourceEvent || event;\n        const target = sourceEvent.target;\n        \n        if (!target) return false;\n\n        // Check modifier key requirement\n        if (this.rectSelectOptions.modifierKey !== 'none') {\n            const hasRequiredModifier = \n                (this.rectSelectOptions.modifierKey === 'ctrl' && (sourceEvent.ctrlKey || sourceEvent.metaKey)) ||\n                (this.rectSelectOptions.modifierKey === 'shift' && sourceEvent.shiftKey) ||\n                (this.rectSelectOptions.modifierKey === 'alt' && sourceEvent.altKey);\n            \n            if (!hasRequiredModifier) return false;\n        }\n\n        // Only start on empty space (not on nodes or links)\n        if (this.rectSelectOptions.enableOnEmptySpace) {\n            // Check if clicked on a node, link, or other interactive element\n            if (target.closest && target.closest('.node') || \n                target.closest && target.closest('.link') || \n                target.classList && target.classList.contains('link') ||\n                target.tagName === 'circle' ||\n                target.tagName === 'text' ||\n                target.tagName === 'path') {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Handles the start of rectangle selection\n     */\n    handleRectDragStart(event) {\n        if (!this.isRectSelectModeActive) return;\n\n        this.isDrawing = true;\n\n        // Get coordinates relative to the SVG\n        const svgElement = this.dependencies.visualizer.svg.node();\n        const rect = svgElement.getBoundingClientRect();\n        \n        // Account for current zoom/pan transform\n        const transform = d3.zoomTransform(svgElement);\n        \n        this.startPoint = {\n            x: (event.sourceEvent.clientX - rect.left - transform.x) / transform.k,\n            y: (event.sourceEvent.clientY - rect.top - transform.y) / transform.k\n        };\n\n        // Create selection rectangle\n        this.createSelectionRect();\n    }\n\n    /**\n     * Handles rectangle selection dragging\n     */\n    handleRectDragMove(event) {\n        if (!this.isRectSelectModeActive || !this.isDrawing || !this.selectionRect) return;\n\n        // Get current coordinates\n        const svgElement = this.dependencies.visualizer.svg.node();\n        const rect = svgElement.getBoundingClientRect();\n        const transform = d3.zoomTransform(svgElement);\n        \n        const currentPoint = {\n            x: (event.sourceEvent.clientX - rect.left - transform.x) / transform.k,\n            y: (event.sourceEvent.clientY - rect.top - transform.y) / transform.k\n        };\n\n        // Update rectangle\n        this.updateSelectionRect(currentPoint);\n\n        // Highlight nodes within rectangle (preview)\n        this.previewSelection(currentPoint);\n    }\n\n    /**\n     * Handles the end of rectangle selection\n     */\n    handleRectDragEnd(event) {\n        if (!this.isRectSelectModeActive || !this.isDrawing) return;\n\n        this.isDrawing = false;\n\n        // Get final coordinates\n        const svgElement = this.dependencies.visualizer.svg.node();\n        const rect = svgElement.getBoundingClientRect();\n        const transform = d3.zoomTransform(svgElement);\n        \n        const endPoint = {\n            x: (event.sourceEvent.clientX - rect.left - transform.x) / transform.k,\n            y: (event.sourceEvent.clientY - rect.top - transform.y) / transform.k\n        };\n\n        // Perform final selection\n        this.performRectSelection(endPoint, event.sourceEvent);\n\n        // Cleanup\n        this.cleanupSelectionRect();\n    }\n\n    /**\n     * Creates the visual selection rectangle\n     */\n    createSelectionRect() {\n        // Create rectangle in the main SVG group (so it scales with zoom)\n        const svgGroup = this.dependencies.visualizer.svg.select('g');\n        \n        this.selectionRect = svgGroup.append('rect')\n            .attr('class', 'selection-rect')\n            .attr('x', this.startPoint.x)\n            .attr('y', this.startPoint.y)\n            .attr('width', 0)\n            .attr('height', 0);\n    }\n\n    /**\n     * Updates the selection rectangle as user drags\n     */\n    updateSelectionRect(currentPoint) {\n        if (!this.selectionRect) return;\n\n        const x = Math.min(this.startPoint.x, currentPoint.x);\n        const y = Math.min(this.startPoint.y, currentPoint.y);\n        const width = Math.abs(currentPoint.x - this.startPoint.x);\n        const height = Math.abs(currentPoint.y - this.startPoint.y);\n\n        this.selectionRect\n            .attr('x', x)\n            .attr('y', y)\n            .attr('width', width)\n            .attr('height', height);\n    }\n\n    /**\n     * Provides visual preview of what will be selected\n     */\n    previewSelection(currentPoint) {\n        // Optional: Add preview styling to nodes that would be selected\n        // For now, we'll skip this to avoid performance issues during drag\n    }\n\n    /**\n     * Performs the actual selection based on the rectangle\n     */\n    performRectSelection(endPoint, sourceEvent) {\n        // Calculate rectangle bounds\n        const minX = Math.min(this.startPoint.x, endPoint.x);\n        const maxX = Math.max(this.startPoint.x, endPoint.x);\n        const minY = Math.min(this.startPoint.y, endPoint.y);\n        const maxY = Math.max(this.startPoint.y, endPoint.y);\n\n        const rectWidth = maxX - minX;\n        const rectHeight = maxY - minY;\n\n        // Check if rectangle is large enough\n        if (rectWidth < this.rectSelectOptions.minRectSize || \n            rectHeight < this.rectSelectOptions.minRectSize) {\n            return;\n        }\n\n        // Find nodes within the rectangle\n        const nodesInRect = [];\n        \n        if (this.dependencies.visualizer.simulationManager && \n            this.dependencies.visualizer.simulationManager.simulation) {\n            \n            const nodes = this.dependencies.visualizer.simulationManager.simulation.nodes();\n            \n            nodes.forEach(node => {\n                if (node.x >= minX && node.x <= maxX && \n                    node.y >= minY && node.y <= maxY) {\n                    nodesInRect.push(node.id);\n                }\n            });\n        }\n\n        if (nodesInRect.length === 0) return;\n\n        // Determine selection behavior based on modifier keys\n        const isShiftPressed = sourceEvent.shiftKey;\n        const isCtrlPressed = sourceEvent.ctrlKey || sourceEvent.metaKey;\n\n        if (isShiftPressed || isCtrlPressed) {\n            // Add to existing selection\n            nodesInRect.forEach(nodeId => {\n                this.dependencies.visualizer.addToSelection(nodeId, false);\n            });\n        } else {\n            // Replace selection\n            this.dependencies.visualizer.clearSelection(false);\n            nodesInRect.forEach(nodeId => {\n                this.dependencies.visualizer.addToSelection(nodeId, false);\n            });\n        }\n\n        // Emit selection change event\n        this.dependencies.visualizer.emit('selectionChanged', {\n            selected: Array.from(this.dependencies.visualizer.selectedNodes),\n            added: nodesInRect,\n            removed: []\n        });\n\n        // Emit multi-selection event if multiple nodes selected\n        if (this.dependencies.visualizer.getSelectionCount() > 1) {\n            this.dependencies.visualizer.emit('systemsSelected', {\n                event: { sourceEvent },\n                systems: this.dependencies.visualizer.getSelectedSystems(),\n                primary: null // No primary system in rectangle selection\n            });\n        }\n    }\n\n    /**\n     * Cleans up the selection rectangle\n     */\n    cleanupSelectionRect() {\n        if (this.selectionRect) {\n            this.selectionRect.remove();\n            this.selectionRect = null;\n        }\n        this.startPoint = null;\n    }\n\n    /**\n     * Updates or shows selection info\n     */\n    updateSelectionInfo(selectionData) {\n        const count = selectionData.selected.length;\n        \n        // Update button badge\n        if (count > 0) {\n            this.toggleRectSelectButton.setAttribute('data-count', count);\n            this.toggleRectSelectButton.style.position = 'relative';\n        } else {\n            this.toggleRectSelectButton.removeAttribute('data-count');\n        }\n        \n        if (!this.isRectSelectModeActive) return;\n        \n        if (count > 0) {\n            this.showSelectionInfo(count);\n        } else {\n            this.hideSelectionInfo();\n        }\n    }\n\n    /**\n     * Shows selection information overlay\n     */\n    showSelectionInfo(count) {\n        let selectionInfo = document.querySelector('.selection-info');\n        \n        if (!selectionInfo) {\n            selectionInfo = document.createElement('div');\n            selectionInfo.className = 'selection-info';\n            document.body.appendChild(selectionInfo);\n        }\n        \n        selectionInfo.textContent = `${count} system${count !== 1 ? 's' : ''} selected`;\n        selectionInfo.classList.add('visible');\n    }\n\n    /**\n     * Hides selection information overlay\n     */\n    hideSelectionInfo() {\n        const selectionInfo = document.querySelector('.selection-info');\n        if (selectionInfo) {\n            selectionInfo.classList.remove('visible');\n        }\n    }\n\n    /**\n     * Gets the current rectangle selection mode state\n     */\n    isRectSelectMode() {\n        return this.isRectSelectModeActive;\n    }\n\n    /**\n     * Sets rectangle selection options\n     */\n    setRectSelectOptions(options) {\n        this.rectSelectOptions = { ...this.rectSelectOptions, ...options };\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/multi-select.js?");

/***/ }),

/***/ "./src/ui/components/reset-zoom.js":
/*!*****************************************!*\
  !*** ./src/ui/components/reset-zoom.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResetZoomHelper: () => (/* binding */ ResetZoomHelper)\n/* harmony export */ });\n/* harmony import */ var _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/ui-component.js */ \"./src/ui/base/ui-component.js\");\n\n\nclass ResetZoomHelper extends _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__.UIComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n    }\n\n    bindEvents() {\n        this.dependencies.toolbar.button('bi-aspect-ratio', 'Rezet zoom', () => {\n            this.dependencies.visualizer.resetZoom();\n        }, 'view');\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/reset-zoom.js?");

/***/ }),

/***/ "./src/ui/components/reset.js":
/*!************************************!*\
  !*** ./src/ui/components/reset.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ResetData: () => (/* binding */ ResetData)\n/* harmony export */ });\n/* harmony import */ var _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/overlay-component.js */ \"./src/ui/base/overlay-component.js\");\n/* harmony import */ var _utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utilities.js */ \"./src/utils/utilities.js\");\n\n\n\nconst createResetModalTemplate = () => `\n    <div class=\"modal fade\" id=\"reset-modal\" tabindex=\"-1\" aria-hidden=\"true\">\n        <div class=\"modal-dialog\" style=\"max-width: 50vw;\">\n            <div class=\"modal-content\">\n                <div class=\"modal-header\">\n                    <h5 class=\"modal-title\">Delete data</h5>\n                    <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n                </div>\n                <div class=\"modal-body\" id=\"confirm-message\">\n                    Do you want to delete all local infrastructure data and LLM configuration?\n                </div>\n                <div class=\"modal-footer\">\n                    <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Cancel</button>\n                    <button type=\"button\" class=\"btn btn-warning\" id=\"reset-modal-llm-action\">LLM configuration</button>\n                    <button type=\"button\" class=\"btn btn-warning\" id=\"reset-modal-data-action\">Infrastructure</button>\n                    <button type=\"button\" class=\"btn btn-danger\" id=\"reset-modal-all-action\">Delete all</button>\n                </div>\n            </div>\n        </div>\n    </div>\n`;\n\nclass ResetData extends _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__.OverlayComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n    }\n\n    setupDOM() {\n        this.modalElement = this.render(createResetModalTemplate());\n        this.element.appendChild(this.modalElement);\n        this.modal = new bootstrap.Modal(this.modalElement);\n    }\n\n    bindEvents() {\n        this.dependencies.toolbar.button('bi-x-circle', 'Reset data', () => {\n            this.show();\n        }, 'import-export');\n\n        // Nur LLM-Konfiguration zurücksetzen\n        this.modalElement.querySelector('#reset-modal-llm-action').addEventListener('click', () => {\n            this.dependencies.llmConfig.reset();\n            this.dependencies.llmManager.updateConfig();\n            this.dependencies.chatInterface.hide();\n\n            this.hide();\n\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(\"LLM-Konfiguration wurde zurückgesetzt.\", \"info\");\n        });\n\n        // Nur Daten zurücksetzen\n        this.modalElement.querySelector('#reset-modal-data-action').addEventListener('click', () => {\n            this.dependencies.dataManager.clearData();\n            this.dependencies.visualizer.nodeCache.clear(true);\n\n            this.hide();\n\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(\"Daten wurden zurückgesetzt.\", \"info\");\n        });\n\n        // Alles zurücksetzen\n        this.modalElement.querySelector('#reset-modal-all-action').addEventListener('click', () => {\n            this.dependencies.llmConfig.reset();\n            this.dependencies.llmManager.updateConfig();\n            this.dependencies.chatInterface.hide();\n            \n            this.dependencies.dataManager.clearData();\n            this.dependencies.visualizer.nodeCache.clear(true);\n            \n            this.hide();\n\n            (0,_utils_utilities_js__WEBPACK_IMPORTED_MODULE_1__.showNotification)(\"All data and configurations have been deleted.\", \"info\");\n        });\n    }\n\n    onShow() {\n        this.modal.show();\n    }\n\n    onHide() {\n        this.modal.hide();\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/reset.js?");

/***/ }),

/***/ "./src/ui/components/search.js":
/*!*************************************!*\
  !*** ./src/ui/components/search.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SearchOverlay: () => (/* binding */ SearchOverlay)\n/* harmony export */ });\n/* harmony import */ var _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/overlay-component.js */ \"./src/ui/base/overlay-component.js\");\n\n\nconst createSearchOverlay = () => `\n    <div class=\"search-overlay overlay\">\n        <div class=\"overlay-header\">\n            <h5>Search</h5>\n            <button class=\"btn-close close-overlay\" data-close-target=\"search-panel\"></button>\n        </div>\n        <div class=\"overlay-body\">\n            <div class=\"input-group mb-3\">\n                <span class=\"input-group-text\"><i class=\"bi bi-search\"></i></span>\n                <input type=\"text\" class=\"form-control system-search\" placeholder=\"Search system...\">\n            </div>\n            <div class=\"list-group search-results\">\n                <!-- Search results will be inserted here -->\n            </div>\n        </div>\n    </div>\n`;\n\nclass SearchOverlay extends _base_overlay_component_js__WEBPACK_IMPORTED_MODULE_0__.OverlayComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n    }\n\n    setupDOM() {\n        this.overlayElement = this.render(createSearchOverlay());\n        this.element.appendChild(this.overlayElement);\n    }\n\n    bindEvents() {\n        // Toolbar button to toggle search overlay\n        this.dependencies.toolbar.button('bi-search', 'Search', () => {\n            this.toggle();\n        }, 'view');\n\n        // Close button\n        this.overlayElement.querySelector('.close-overlay').addEventListener('click', () => {\n            this.hide();\n        });\n\n        // Search field\n        const input = this.overlayElement.querySelector('.system-search');\n        input.addEventListener('input', () => this.performSearch(input.value));\n    }\n\n    toggle() {\n        document.querySelectorAll('.overlay').forEach(overlay => {\n            if (overlay !== this.overlayElement) overlay.classList.remove('active');\n        });\n        if (this.overlayElement.classList.contains('active')) {\n            this.hide();\n        } else {\n            this.show();\n        }\n    }\n\n    onShow() {\n        this.overlayElement.classList.add('active');\n    }\n\n    onHide() {\n        this.overlayElement.classList.remove('active');\n    }\n\n    performSearch(query) {\n        const resultsContainer = this.overlayElement.querySelector('.search-results');\n\n        if (!resultsContainer) {\n            console.error('Search results container not found');\n            return;\n        }\n\n        if (!query || query.trim() === '') {\n            resultsContainer.innerHTML = '';\n            return;\n        }\n\n        const searchTerm = query.toLowerCase().trim();\n\n        // Search systems\n        const results = this.dependencies.dataManager.getData().systems.filter(system => {\n            return (\n                system.name.toLowerCase().includes(searchTerm) ||\n                system.description.toLowerCase().includes(searchTerm) ||\n                (system.tags && system.tags.some(tag => tag.toLowerCase().includes(searchTerm))) ||\n                (system.group && system.group.toLowerCase().includes(searchTerm)) // Also search in groups\n            );\n        });\n\n        // Display results\n        if (results.length === 0) {\n            resultsContainer.innerHTML = '<div class=\"alert alert-info\">No systems found.</div>';\n        } else {\n            let html = '';\n\n            results.forEach(system => {\n                html += `\n                    <button class=\"list-group-item list-group-item-action\" data-system-id=\"${system.id}\">\n                        <div class=\"d-flex w-100 justify-content-between\">\n                            <h6 class=\"mb-1\">${system.name}</h6>\n                            <span class=\"badge bg-${this.dependencies.visualizer.getCategoryClass(system.category)}\">${system.category}</span>\n                        </div>\n                        <small>${system.description}</small>\n                        ${system.group ? `<br><small><span class=\"badge bg-info\">Group: ${system.group}</span></small>` : ''}\n                    </button>\n                `;\n            });\n\n            resultsContainer.innerHTML = html;\n\n            // Event listeners for clicks on search results\n            const resultItems = resultsContainer.querySelectorAll('.list-group-item');\n            resultItems.forEach(item => {\n                item.addEventListener('click', () => {\n                    const systemId = item.getAttribute('data-system-id');\n                    const system = this.dependencies.dataManager.getData().systems.find(s => s.id === systemId);\n\n                    if (system) {\n                        this.dependencies.visualizer.showSystemDetails(system);\n                        this.hide();\n                    }\n                });\n            });\n        }\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/search.js?");

/***/ }),

/***/ "./src/ui/components/toolbar.js":
/*!**************************************!*\
  !*** ./src/ui/components/toolbar.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Toolbar: () => (/* binding */ Toolbar)\n/* harmony export */ });\n/* harmony import */ var _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/ui-component.js */ \"./src/ui/base/ui-component.js\");\n\n\nclass Toolbar extends _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__.UIComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n    }\n\n    group(name) {\n        //<div class=\"btn-group\"></div>\n        if (!this._groups) {\n            this._groups = new Map();\n        }\n        if (this._groups.has(name)) {\n            return this._groups.get(name);\n        }\n        const group = document.createElement('div');\n        group.classList.add('btn-group', 'me-1');\n        this._groups.set(name, group);\n        this.element.appendChild(group);\n        return group;\n    }\n\n    button(icon, title, callback, group = 'default', additionalClasses = []) {\n        const button = document.createElement('button');\n        button.classList.add('btn', 'btn-dark', 'btn-sm');\n        additionalClasses.forEach(cls => button.classList.add(cls));\n        button.title = title;\n        button.innerHTML = `<i class=\"bi ${icon}\"></i>`;\n        button.addEventListener('click', callback);\n        this.group(group).appendChild(button);\n        return button;\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/toolbar.js?");

/***/ }),

/***/ "./src/ui/components/upload.js":
/*!*************************************!*\
  !*** ./src/ui/components/upload.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UploadHelper: () => (/* binding */ UploadHelper)\n/* harmony export */ });\n/* harmony import */ var _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/ui-component.js */ \"./src/ui/base/ui-component.js\");\n/* harmony import */ var _utils_data_loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/data-loader.js */ \"./src/utils/data-loader.js\");\n\n\n\nclass UploadHelper extends _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__.UIComponent {\n    constructor(selector, dependencies = {}, options = {}) {\n        super(selector, dependencies, options);\n    }\n\n    bindEvents() {\n        this.dependencies.toolbar.button('bi-upload', 'Upload data', () => {\n            (0,_utils_data_loader_js__WEBPACK_IMPORTED_MODULE_1__.uploadSystemData)(this.dependencies.dataManager);\n        }, 'import-export');\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/upload.js?");

/***/ }),

/***/ "./src/ui/components/visualizer.js":
/*!*****************************************!*\
  !*** ./src/ui/components/visualizer.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SystemVisualizer: () => (/* binding */ SystemVisualizer)\n/* harmony export */ });\n/* harmony import */ var _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/ui-component.js */ \"./src/ui/base/ui-component.js\");\n/* harmony import */ var _utils_simulation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/simulation.js */ \"./src/ui/utils/simulation.js\");\n/* harmony import */ var _utils_node_cache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/node-cache.js */ \"./src/ui/utils/node-cache.js\");\n\n\n\n\n/**\n * SystemVisualizer - Visualizes IT systems and their dependencies as an interactive graph\n */\nclass SystemVisualizer extends _base_ui_component_js__WEBPACK_IMPORTED_MODULE_0__.UIComponent {\n    constructor(containerId, dependencies = {}, options = {}) {\n        super(containerId, dependencies, options);\n        this.dataManager = this.dependencies.dataManager;\n\n        // Getter for access to current data\n        Object.defineProperty(this, 'data', {\n            get: () => this.dataManager.getData()\n        });\n\n        // D3 visualization variables\n        this.svg = null;\n        this.width = 0;\n        this.height = 0;\n        this.zoom = null;\n\n        // UI states\n        this.searchResults = [];\n        this.activeFilters = {\n            categories: [\"core\", \"legacy\", \"data\", \"service\", \"external\"],\n            knownUsage: [\"known\", \"unknown\"]\n        };\n\n        // Color scales\n        this.colorScale = d3.scaleOrdinal()\n            .domain([\"core\", \"legacy\", \"data\", \"service\", \"external\"])\n            .range([\"#0d6efd\", \"#6c757d\", \"#198754\", \"#ffc107\", \"#dc3545\"]);\n        this.groupColorScale = d3.scaleOrdinal(d3.schemeCategory10);\n\n        // Create node cache\n        this.nodeCache = new _utils_node_cache_js__WEBPACK_IMPORTED_MODULE_2__.NodeCache({\n            useLocalStorage: true,\n            localStorageKey: 'system_visualizer_node_positions',\n            debounceTime: 250\n        });\n\n        // SimulationManager (will be initialized later)\n        this.simulationManager = null;\n\n        // Visualization elements\n        this.nodeElements = null;\n        this.linkElements = null;\n        this.groupHulls = null;\n        this.groupLabels = null;\n\n        // Multi-Selection state\n        this.selectedNodes = new Set(); // IDs der ausgewählten Knoten\n        this.isMultiSelectActive = false; // Ob Multi-Select Modus aktiv ist\n        this.lastSelectedNode = null; // Für Shift-Selection ranges\n    }\n\n    /**\n     * Returns the currently selected node IDs\n     * @returns {Set<string>} Set of selected node IDs\n     */\n    getSelectedNodeIds() {\n        return new Set(this.selectedNodes);\n    }\n\n    /**\n     * Returns the currently selected system objects\n     * @returns {Array<Object>} Array of selected system objects\n     */\n    getSelectedSystems() {\n        return Array.from(this.selectedNodes)\n            .map(id => this.data.systems.find(system => system.id === id))\n            .filter(system => system !== undefined);\n    }\n\n    /**\n     * Checks if a node is currently selected\n     * @param {string} systemId - The ID of the system to check\n     * @returns {boolean} True if the node is selected\n     */\n    isNodeSelected(systemId) {\n        return this.selectedNodes.has(systemId);\n    }\n\n    /**\n     * Returns the number of currently selected nodes\n     * @returns {number} Number of selected nodes\n     */\n    getSelectionCount() {\n        return this.selectedNodes.size;\n    }\n\n    /**\n     * Initializes the visualization\n     */\n    initialize() {\n        if (!this.data) {\n            console.error(\"No data available for visualization\");\n            return;\n        }\n\n        this.createVisualization();\n        this.setupZoom();\n\n        // Setup keyboard shortcuts for multi-selection\n        this.setupKeyboardShortcuts();\n\n        // React to data changes\n        this.dataManager.on('dataChanged', () => {    // Check if any selected nodes no longer exist\n            const currentSystemIds = new Set(this.data.systems.map(sys => sys.id));\n            const invalidSelectedNodes = Array.from(this.selectedNodes)\n                .filter(nodeId => !currentSystemIds.has(nodeId));\n\n            // Remove invalid selections\n            if (invalidSelectedNodes.length > 0) {\n                invalidSelectedNodes.forEach(nodeId => {\n                    this.selectedNodes.delete(nodeId);\n                });\n\n                this.emit('selectionChanged', {\n                    selected: Array.from(this.selectedNodes),\n                    added: [],\n                    removed: invalidSelectedNodes\n                });\n            }\n\n            // Recreate visualization\n            const container = this.element;\n            if (container) {\n                container.innerHTML = '';\n                this.createVisualization();\n                this.setupZoom();\n                this.setupKeyboardShortcuts();\n            }\n        });\n\n        // Event listener for window resize\n        window.addEventListener('resize', this.handleResize.bind(this));\n\n        // Update cache before leaving\n        window.addEventListener('beforeunload', () => {\n            if (this.simulationManager) {\n                this.simulationManager.stop();\n            }\n        });\n    }\n\n    /**\n     * Creates the D3.js visualization\n     */\n    createVisualization() {\n        const container = this.element;\n\n        // Size and margins (fullscreen)\n        this.width = container.clientWidth;\n        this.height = container.clientHeight;\n\n        // Create SVG\n        this.svg = d3.select(container)\n            .append(\"svg\")\n            .attr(\"width\", this.width)\n            .attr(\"height\", this.height);\n\n        // Group for zoom\n        const g = this.svg.append(\"g\");\n\n        // Create tooltip\n        // Find or create tooltip element (as D3 selection)\n        let tooltip = d3.select(\"body\").select(\".tooltip\");\n        if (tooltip.empty()) {\n            tooltip = d3.select(\"body\").append(\"div\")\n                .attr(\"class\", \"tooltip\")\n                .style(\"opacity\", 0);\n        }\n\n        // Prepare and filter graph data\n        const nodes = this.getFilteredNodes();\n        const links = this.getFilteredLinks(nodes);\n\n        // Identify groupings\n        const groups = this.identifyGroups(nodes);\n\n        // Create SimulationManager\n        this.simulationManager = new _utils_simulation_js__WEBPACK_IMPORTED_MODULE_1__.SimulationManager({\n            width: this.width,\n            height: this.height,\n            nodeCache: this.nodeCache,\n            linkDistance: 150,\n            chargeStrength: -300,\n            collisionRadius: 60,\n            groupForceStrength: 0.5,\n            onTick: () => this.onSimulationTick(),\n            onToggleFixed: (id, state) => {\n                this.emit('toggleFixed', { id, state });\n            },\n        });\n\n        // Arrowheads for the links\n        g.append(\"defs\").selectAll(\"marker\")\n            .data([\"data\", \"integration\", \"authentication\", \"monitoring\"])\n            .enter().append(\"marker\")\n            .attr(\"id\", d => `arrowhead-${d}`)\n            .attr(\"viewBox\", \"0 -5 10 10\")\n            .attr(\"refX\", 8)  // No offset - arrowhead starts at end of path\n            .attr(\"refY\", 0)  // No offset\n            .attr(\"markerWidth\", 6)\n            .attr(\"markerHeight\", 6)\n            .attr(\"orient\", \"auto\")\n            .append(\"path\")\n            .attr(\"d\", \"M0,-5L10,0L0,5\")\n            .attr(\"fill\", d => {\n                switch (d) {\n                    case \"data\": return \"#0d6efd\";\n                    case \"integration\": return \"#198754\";\n                    case \"authentication\": return \"#dc3545\";\n                    case \"monitoring\": return \"#6c757d\";\n                    default: return \"#999\";\n                }\n            });\n\n        // Draw group hulls (before nodes and links)\n        this.groupHulls = g.append(\"g\")\n            .attr(\"class\", \"groups\")\n            .selectAll(\".group-hull\")\n            .data(Object.entries(groups).filter(([name]) => name !== \"ungrouped\")) // filter out \"undefined\" group\n            .enter().append(\"path\")\n            .attr(\"class\", \"group-hull\")\n            .attr(\"data-group\", d => d[0])\n            .style(\"fill\", d => this.groupColorScale(d[0]))\n            .style(\"stroke\", d => d3.rgb(this.groupColorScale(d[0])).darker())\n            .style(\"stroke-width\", 1.5)\n            .style(\"fill-opacity\", 0.2)\n            .style(\"stroke-opacity\", 0.4);\n\n        // Draw links\n        const that = this;\n        this.linkElements = g.append(\"g\")\n            .attr(\"class\", \"links\")\n            .selectAll(\"path\")\n            .data(links)\n            .enter().append(\"path\")\n            .attr(\"class\", \"link\")\n            .attr(\"marker-end\", d => `url(#arrowhead-${d.type})`)\n            .attr(\"data-type\", d => d.type)\n            .attr(\"data-link-index\", d => d.linkIndex)\n            .attr(\"data-total-links\", d => d.totalLinks)\n            .on(\"mouseover\", function (event, d) {\n                if (that.dragDisabled) return;\n                tooltip.transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n\n                const sourceSystem = nodes.find(n => n.id === d.source.id || n.id === d.source);\n                const targetSystem = nodes.find(n => n.id === d.target.id || n.id === d.target);\n\n                tooltip.html(`\n                    <strong>${sourceSystem ? sourceSystem.name : 'Unknown'} → ${targetSystem ? targetSystem.name : 'Unknown'}</strong><br>\n                    ${d.description || 'No description'}<br>\n                    <em>Protocol: ${d.protocol || 'Not specified'}</em>\n                `);\n\n                // Position tooltip centered below the mouse pointer\n                const tooltipNode = tooltip.node();\n                // Temporarily make visible to measure width\n                tooltip.style(\"opacity\", 0).style(\"display\", \"block\");\n                const tooltipWidth = tooltipNode.offsetWidth;\n                tooltip.style(\"display\", null); // reset\n\n                tooltip\n                    .style(\"left\", (event.pageX - tooltipWidth / 2) + \"px\")\n                    .style(\"top\", (event.pageY + 16) + \"px\")\n                    .transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n            })\n            .on(\"mouseout\", function () {\n                tooltip.transition()\n                    .duration(500)\n                    .style(\"opacity\", 0);\n            })\n            .on(\"click\", (event, data) => {\n                this.emit('dependencyClick', { event, data });\n                event.stopPropagation();\n            });\n\n        // Create nodes\n        const nodeGroup = g.append(\"g\")\n            .attr(\"class\", \"nodes\");\n\n        this.nodeElements = nodeGroup.selectAll(\".node\")\n            .data(nodes)\n            .enter().append(\"g\")\n            .attr(\"class\", d => {\n                const classes = [\"node\"];\n                if (!d.knownUsage) classes.push(\"unknown-usage\");\n\n                // Add selection class if node is selected\n                if (this.isNodeSelected(d.id)) classes.push(\"selected\");\n\n                // Add multiple group classes\n                const nodeGroups = this.getNodeGroups(d);\n                nodeGroups.forEach(group => {\n                    classes.push(`group-${group}`);\n                });\n\n                return classes.join(\" \");\n            })\n            .attr(\"data-system-id\", d => d.id)\n            .attr(\"data-groups\", d => this.getNodeGroups(d).join(\",\"));\n\n        if (!this.dragDisabled) {\n            this.nodeElements.call(this.simulationManager.createDragBehavior())\n        }\n\n        // Circles for the systems\n        const radius = 30;\n        this.nodeElements.append(\"circle\")\n            .attr(\"r\", radius)\n            .attr(\"fill\", d => this.colorScale(d.category))\n            .attr(\"stroke\", d => {\n                const nodeGroups = this.getNodeGroups(d);\n                if (nodeGroups.length > 0) {\n                    // For multiple groups, create a multi-color stroke (could be dashed)\n                    return nodeGroups.length > 1 ?\n                        \"url(#multigroup-gradient-\" + d.id + \")\" : // ID for gradient\n                        this.groupColorScale(nodeGroups[0]); // Single group\n                }\n                return \"#fff\"; // Default without group\n            })\n            .attr(\"stroke-width\", d => this.getNodeGroups(d).length > 0 ? 3 : 2)\n            .attr(\"stroke-dasharray\", d => this.getNodeGroups(d).length > 1 ? \"5,3\" : null)\n            .on(\"mouseover\", function (event, d) {\n                if (that.dragDisabled) return;\n                tooltip.transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n                tooltip.html(`\n                    <strong>${d.name}</strong><br>\n                    ${d.description}<br>\n                    ${d.group ? '<span class=\"badge bg-info\">Group: ' + d.group + '</span>' : ''}\n                `);\n\n                // Temporarily make visible to measure width and height\n                tooltip.style(\"opacity\", 0).style(\"display\", \"block\");\n                const tooltipNode = tooltip.node();\n                const tooltipWidth = tooltipNode.offsetWidth;\n                tooltip.style(\"display\", null); // reset\n\n                // Determine height of the circle (SVG circle has r=30)\n                const circleRadius = radius;\n                // Optionally: If the circle radius is dynamic, you could get it like this:\n                // const circleRadius = d3.select(this).attr(\"r\");\n\n                tooltip\n                    .style(\"left\", (event.pageX - tooltipWidth / 2) + \"px\")\n                    .style(\"top\", (event.pageY + Number(circleRadius) + 8) + \"px\") // 8px below the circle\n                    .transition()\n                    .duration(200)\n                    .style(\"opacity\", .9);\n            })\n            .on(\"mouseout\", function () {\n                tooltip.transition()\n                    .duration(500)\n                    .style(\"opacity\", 0);\n            })\n            .on(\"click\", (event, d) => {\n                // Neue Multi-Select Logik\n                this.handleNodeClick(event, d);\n            });\n\n        // Text labels\n        this.nodeElements.append(\"text\")\n            .attr(\"dy\", -40)\n            .attr(\"text-anchor\", \"middle\")\n            .text(d => d.name)\n            .attr(\"fill\", \"#333\")\n            .style(\"user-select\", \"none\")\n            .style(\"pointer-events\", \"none\");\n\n        // Add group labels\n        this.groupLabels = g.append(\"g\")\n            .attr(\"class\", \"group-labels\")\n            .selectAll(\".group-label\")\n            .data(Object.entries(groups).filter(([name]) => name !== \"ungrouped\"))\n            .enter().append(\"text\")\n            .attr(\"class\", \"group-label\")\n            .attr(\"text-anchor\", \"middle\")\n            .style(\"font-size\", \"16px\")\n            .style(\"font-weight\", \"bold\")\n            .style(\"fill\", d => d3.rgb(this.groupColorScale(d[0])).darker(2))\n            .style(\"user-select\", \"none\")\n            .style(\"pointer-events\", \"none\")\n            .text(d => {\n                // Display for merged groups\n                if (d[1].allGroups && d[1].allGroups.length > 1) {\n                    return `${d[0]} (+${d[1].allGroups.length - 1})`;\n                }\n                return d[0];\n            });\n        this.groupLabels.append(\"title\") // Tooltip for details\n            .text(d => {\n                if (d[1].allGroups && d[1].allGroups.length > 1) {\n                    return `Merged groups:\\n${d[1].allGroups.join('\\n')}`;\n                }\n                return d[0];\n            });\n\n        const defs = g.select(\"defs\");\n        nodes.forEach(d => {\n            const nodeGroups = this.getNodeGroups(d);\n            if (nodeGroups.length > 1) {\n                const gradient = defs.append(\"linearGradient\")\n                    .attr(\"id\", \"multigroup-gradient-\" + d.id)\n                    .attr(\"x1\", \"0%\")\n                    .attr(\"y1\", \"0%\")\n                    .attr(\"x2\", \"100%\")\n                    .attr(\"y2\", \"100%\");\n\n                // Add color stops for each group\n                nodeGroups.forEach((group, i) => {\n                    gradient.append(\"stop\")\n                        .attr(\"offset\", (i / (nodeGroups.length - 1) * 100) + \"%\")\n                        .attr(\"stop-color\", this.groupColorScale(group));\n                });\n            }\n        });\n\n        // Start simulation\n        this.simulationManager.initialize(nodes, links, groups);\n    }\n\n    /**\n    * Returns filtered links based on the filtered nodes\n    */\n    getFilteredLinks(nodes) {\n        const nodeIds = nodes.map(node => node.id);\n\n        // Initialize link counters\n        const linkCounts = {};\n\n        // First filter the links\n        const filteredLinks = this.data.dependencies.filter(dep => {\n            return nodeIds.includes(dep.source) && nodeIds.includes(dep.target);\n        });\n\n        // Count and index links\n        filteredLinks.forEach(dep => {\n            const key = `${dep.source}-${dep.target}`;\n            const reverseKey = `${dep.target}-${dep.source}`;\n\n            // Initialize counter for this direction\n            if (!linkCounts[key]) {\n                linkCounts[key] = 0;\n            }\n\n            // Increment counter and assign to link\n            linkCounts[key]++;\n            dep.linkIndex = linkCounts[key] - 1; // 0-based index\n\n            // Store total number of links in this direction\n            dep.totalLinks = filteredLinks.filter(d =>\n                (d.source === dep.source && d.target === dep.target)\n            ).length;\n        });\n\n        // Return links with additional information\n        return filteredLinks.map(dep => ({\n            source: dep.source,\n            target: dep.target,\n            linkIndex: dep.linkIndex,\n            totalLinks: dep.totalLinks,\n            ...dep\n        }));\n    }\n\n    /**\n     * Called on every simulation tick\n     */\n    onSimulationTick() {\n        if (!this.linkElements || !this.nodeElements || !this.groupHulls || !this.groupLabels) {\n            return;\n        }\n\n        // Update links\n        this.linkElements.attr(\"d\", this.linkArc);\n\n        // Update nodes\n        this.nodeElements.attr(\"transform\", d => `translate(${d.x},${d.y})`);\n\n        // Update group hulls\n        this.groupHulls.attr(\"d\", d => {\n            const groupName = d[0];\n            const simulation = this.simulationManager.simulation;\n\n            // Find all nodes that belong to this group\n            // IMPORTANT DIFFERENCE: Now we check if a node belongs to ANY of the original groups\n            const groupNodes = simulation.nodes().filter(n => {\n                const nodeGroups = this.getNodeGroups(n);\n\n                // Check if the node belongs to any of the original groups\n                // that were mapped to this representative group\n                if (d[1].allGroups) {\n                    // For a merged group, check if the node belongs to any of the original groups\n                    return nodeGroups.some(ng => d[1].allGroups.includes(ng));\n                } else {\n                    // For a single group, check normally\n                    return nodeGroups.includes(groupName);\n                }\n            });\n\n            // If no nodes or only one node, draw a small circle around it\n            if (groupNodes.length === 0) {\n                return \"\"; // No hull if no nodes\n            }\n\n            if (groupNodes.length === 1) {\n                // For only one node: draw a circle around it\n                const node = groupNodes[0];\n                return `M${node.x + 60},${node.y} \n                    A60,60 0 1,1 ${node.x - 60},${node.y} \n                    A60,60 0 1,1 ${node.x + 60},${node.y}`;\n            }\n\n            // Calculate centroid of the group\n            const points = groupNodes.map(n => [n.x, n.y]);\n            const centroid = this.getCentroid(points);\n\n            // Calculate radius (with extra padding)\n            const maxDist = Math.max(40, this.getMaxDistanceFromCentroid(points, centroid) + 40);\n\n            // Draw a circular hull around the group\n            return this.createHullPath(centroid, maxDist, 24);\n        });\n\n        // Update group labels\n        this.groupLabels.attr(\"transform\", d => {\n            const groupName = d[0];\n            const simulation = this.simulationManager.simulation;\n\n            // Use the same filter logic as for the hulls\n            const groupNodes = simulation.nodes().filter(n => {\n                const nodeGroups = this.getNodeGroups(n);\n\n                if (d[1].allGroups) {\n                    return nodeGroups.some(ng => d[1].allGroups.includes(ng));\n                } else {\n                    return nodeGroups.includes(groupName);\n                }\n            });\n\n            if (groupNodes.length === 0) return \"translate(0,0)\";\n\n            const points = groupNodes.map(n => [n.x, n.y]);\n            const centroid = this.getCentroid(points);\n\n            return `translate(${centroid[0]},${centroid[1] - 60})`;\n        });\n\n        this.updateAllNodeVisualSelections();\n    }\n\n    resetZoom() {\n        this.svg.transition().duration(750).call(\n            this.zoom.transform,\n            d3.zoomIdentity\n        );\n    }\n\n    /**\n     * Sets up zoom functionality\n     */\n    setupZoom() {\n        this.zoom = d3.zoom()\n            .scaleExtent([0.1, 4])\n            .on(\"zoom\", (event) => {\n                this.svg.select(\"g\").attr(\"transform\", event.transform);\n            });\n\n        this.svg.call(this.zoom);\n\n        // Save viewport state after zoom or pan\n        this.zoom.on('end', () => {\n            this.saveViewportState();\n        });\n\n        // Restore viewport state\n        this.restoreViewportState();\n    }\n\n    /**\n     * Optimized linkArc function with adjusted distribution for even number of links\n     */\n    linkArc(d) {\n        // Node radius\n        const nodeRadius = 32;\n\n        // Extract source and target coordinates\n        const sourceX = d.source.x;\n        const sourceY = d.source.y;\n        const targetX = d.target.x;\n        const targetY = d.target.y;\n\n        // Calculate distance and base angle between nodes\n        const dx = targetX - sourceX;\n        const dy = targetY - sourceY;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        const baseAngle = Math.atan2(dy, dx);\n\n        // Determine angle offsets\n        const totalLinks = d.totalLinks || 1;\n        const linkIndex = d.linkIndex || 0;\n\n        // Maximum angle offset in degrees (±15°), converted to radians\n        const maxOffsetDegrees = 15;\n        const maxOffset = (maxOffsetDegrees * Math.PI) / 180;\n\n        // Calculate angle offset - with adjustment for even number of links\n        let angleOffset = 0;\n\n        if (totalLinks > 1) {\n            if (totalLinks % 2 === 0) {\n                // For even number: shift to avoid the center\n                // e.g. for 4 links: -0.75, -0.25, +0.25, +0.75 instead of -1, -0.33, +0.33, +1\n                const step = 1 / totalLinks;\n                angleOffset = ((linkIndex / (totalLinks - 1)) * 2 - 1 + step) * maxOffset;\n            } else {\n                // For odd number: normal distribution\n                angleOffset = ((linkIndex / (totalLinks - 1)) * 2 - 1) * maxOffset;\n            }\n        }\n\n        // Start point on the source node\n        const startAngle = baseAngle + angleOffset;\n        const startX = sourceX + Math.cos(startAngle) * nodeRadius;\n        const startY = sourceY + Math.sin(startAngle) * nodeRadius;\n\n        // End point on the target node with mirrored angle offset\n        const endAngle = baseAngle + Math.PI - angleOffset;\n        const endX = targetX + Math.cos(endAngle) * nodeRadius;\n        const endY = targetY + Math.sin(endAngle) * nodeRadius;\n\n        // Minimal angle offset for curvature (even for single links)\n        // Single links get a slight curve instead of a straight line\n        const minCurvatureAngle = (3 * Math.PI) / 180;  // 3 degrees in radians\n\n        // Effective angle offset for curvature calculation\n        const effectiveAngleOffset = Math.max(Math.abs(angleOffset), minCurvatureAngle);\n\n        // Arc direction based on the sign of the angle offset\n        // For single links: default to clockwise\n        const sweep = (totalLinks === 1 || angleOffset >= 0) ? 1 : 0;\n\n        // Curvature factor based on angle offset and distance\n        // Minimum 0.15 for slight curve, maximum 0.5 for strong curve\n        let curvature = 0.15 + (effectiveAngleOffset / maxOffset) * 0.35;\n\n        // Orthogonal direction vectors for the control point\n        const tangentX = (endX - startX) / distance;\n        const tangentY = (endY - startY) / distance;\n        const perpX = -tangentY;\n        const perpY = tangentX;\n\n        // Calculate midpoint\n        const midX = (startX + endX) / 2;\n        const midY = (startY + endY) / 2;\n\n        // Control point with direction based on sweep\n        const ctrlFactor = (sweep === 1 ? 1 : -1) * curvature * distance;\n        const ctrlX = midX + perpX * ctrlFactor;\n        const ctrlY = midY + perpY * ctrlFactor;\n\n        // Quadratic Bézier curve\n        return `M${startX},${startY}Q${ctrlX},${ctrlY} ${endX},${endY}`;\n    }\n\n    /**\n     * Identifies all groups and prepares them for d3.js\n     * Optimized to merge groups with identical nodes\n     */\n    identifyGroups(nodes) {\n        // Step 1: Create initial grouping\n        const initialGroupMap = {};\n        const UNGROUPED_GROUP_NAME = \"ungrouped\";\n\n        // Data structure: group -> associated nodes\n        nodes.forEach(node => {\n            const nodeGroups = this.getNodeGroups(node);\n\n            if (nodeGroups.length > 0) {\n                nodeGroups.forEach(groupName => {\n                    if (!initialGroupMap[groupName]) {\n                        initialGroupMap[groupName] = {\n                            nodes: [],\n                            nodeIds: new Set(),\n                            x: 0,\n                            y: 0\n                        };\n                    }\n                    initialGroupMap[groupName].nodes.push(node);\n                    initialGroupMap[groupName].nodeIds.add(node.id);\n                });\n            } else {\n                if (!initialGroupMap[UNGROUPED_GROUP_NAME]) {\n                    initialGroupMap[UNGROUPED_GROUP_NAME] = {\n                        nodes: [],\n                        nodeIds: new Set(),\n                        x: 0,\n                        y: 0\n                    };\n                }\n                initialGroupMap[UNGROUPED_GROUP_NAME].nodes.push(node);\n                initialGroupMap[UNGROUPED_GROUP_NAME].nodeIds.add(node.id);\n            }\n        });\n\n        // Step 2: Identify groups with identical nodes\n        const groupSignatures = {};  // Signature -> groups with this signature\n\n        Object.entries(initialGroupMap).forEach(([groupName, groupData]) => {\n            if (groupName === UNGROUPED_GROUP_NAME) return;\n\n            // Create a unique signature based on node IDs\n            const signature = Array.from(groupData.nodeIds).sort().join(',');\n\n            if (!groupSignatures[signature]) {\n                groupSignatures[signature] = [];\n            }\n\n            groupSignatures[signature].push(groupName);\n        });\n\n        // Step 3: Create final group map\n        const finalGroupMap = {};\n\n        // Mapping from original groups to representative groups\n        // IMPORTANT: We store this as a global/class instance variable\n        this.groupMap = {};\n\n        // First add the ungrouped group if present\n        if (initialGroupMap[UNGROUPED_GROUP_NAME]) {\n            finalGroupMap[UNGROUPED_GROUP_NAME] = initialGroupMap[UNGROUPED_GROUP_NAME];\n        }\n\n        // Then the merged groups\n        Object.entries(groupSignatures).forEach(([signature, groups]) => {\n            // Use the first group as the representative group\n            const primaryGroup = groups[0];\n\n            // Add group to the final map\n            finalGroupMap[primaryGroup] = initialGroupMap[primaryGroup];\n\n            // Store all original groups as metadata\n            if (groups.length > 1) {\n                finalGroupMap[primaryGroup].allGroups = groups;\n                console.log(`Merged identical groups: ${groups.join(', ')} -> ${primaryGroup}`);\n\n                // Create bidirectional mapping\n                groups.forEach(originalGroup => {\n                    this.groupMap[originalGroup] = primaryGroup;\n                });\n            } else {\n                // Also create mapping for single groups\n                this.groupMap[primaryGroup] = primaryGroup;\n            }\n        });\n\n        // Step 4: Calculate initial positions\n        Object.entries(finalGroupMap).forEach(([groupName, group], index) => {\n            // Distribute positions evenly around the center\n            const angle = (index / Object.keys(finalGroupMap).length) * 2 * Math.PI;\n            const radius = Math.min(this.width, this.height) * 0.4;\n\n            group.x = this.width / 2 + radius * Math.cos(angle);\n            group.y = this.height / 2 + radius * Math.sin(angle);\n        });\n\n        return finalGroupMap;\n    }\n\n    /**\n     * Helper function to check if two arrays contain the same elements\n     * (Order is ignored)\n     */\n    arraysHaveSameElements(arr1, arr2) {\n        if (arr1.length !== arr2.length) return false;\n\n        const set1 = new Set(arr1);\n        for (const item of arr2) {\n            if (!set1.has(item)) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Helper function to extract all groups of a node\n     * Supports new groups arrays and legacy group fields\n     */\n    getNodeGroups(node) {\n        if (Array.isArray(node.groups) && node.groups.length > 0) {\n            return node.groups;\n        } else if (node.group && typeof node.group === 'string') {\n            return [node.group];\n        }\n        return [];\n    }\n\n    /**\n     * Calculates the centroid of a group of points\n     */\n    getCentroid(points) {\n        const n = points.length;\n        if (n === 0) return [0, 0];\n\n        const sumX = points.reduce((sum, p) => sum + p[0], 0);\n        const sumY = points.reduce((sum, p) => sum + p[1], 0);\n\n        return [sumX / n, sumY / n];\n    }\n\n    /**\n     * Calculates the maximum distance from the centroid to any point in the group\n     */\n    getMaxDistanceFromCentroid(points, centroid) {\n        if (points.length === 0) return 0;\n\n        return Math.max(...points.map(p =>\n            Math.sqrt(Math.pow(p[0] - centroid[0], 2) + Math.pow(p[1] - centroid[1], 2))\n        ));\n    }\n\n    /**\n     * Creates a path for the group hull\n     */\n    createHullPath(center, radius, segments) {\n        const angleStep = (2 * Math.PI) / segments;\n        let path = `M${center[0] + radius},${center[1]}`;\n\n        for (let i = 1; i <= segments; i++) {\n            const angle = i * angleStep;\n            const x = center[0] + radius * Math.cos(angle);\n            const y = center[1] + radius * Math.sin(angle);\n            path += ` L${x},${y}`;\n        }\n\n        return path + \"Z\";\n    }\n\n    /**\n     * Returns the node with the given ID from the current simulation\n     * @param {string} systemId - The ID of the system to find\n     * @returns {Object|null} The node object or null if not found\n     */\n    getNodeById(systemId) {\n        return this.simulationManager.getNodeById(systemId);\n    }\n\n    /**\n     * Checks if a node is fixed\n     * @param {string} systemId - The ID of the system to check\n     * @returns {boolean} True if the node is fixed, false otherwise or if not found\n     */\n    isNodeFixed(systemId) {\n        return this.simulationManager.isNodeFixed(systemId);\n    }\n\n    /**\n     * Toggles the fixed state of a node\n     * @param {string} systemId - The ID of the system to change\n     * @returns {boolean} The new fixed state or null if the node was not found\n     */\n    toggleNodeFixed(systemId) {\n        return this.simulationManager.toggleNodeFixed(systemId);\n    }\n\n    /**\n     * Helper function to determine the Bootstrap color for categories\n     */\n    getCategoryClass(category) {\n        switch (category) {\n            case 'core': return 'primary';\n            case 'legacy': return 'secondary';\n            case 'data': return 'success';\n            case 'service': return 'warning';\n            case 'external': return 'danger';\n            default: return 'info';\n        }\n    }\n\n    /**\n     * Handles window resize events\n     */\n    handleResize() {\n        const container = this.element;\n        if (container && this.svg) {\n            // Get new size\n            this.width = container.clientWidth;\n            this.height = container.clientHeight;\n\n            // Update SVG size\n            this.svg\n                .attr(\"width\", this.width)\n                .attr(\"height\", this.height);\n\n            // Inform simulation manager about new size\n            if (this.simulationManager) {\n                this.simulationManager.updateSize(this.width, this.height);\n            }\n        }\n    }\n\n    /**\n     * Applies filters to the visualization\n     */\n    applyFilters() {\n        // Clear selection for nodes that will be filtered out\n        const filteredNodeIds = new Set(this.getFilteredNodes().map(node => node.id));\n        const nodesToRemoveFromSelection = Array.from(this.selectedNodes)\n            .filter(nodeId => !filteredNodeIds.has(nodeId));\n\n        // Remove filtered nodes from selection\n        nodesToRemoveFromSelection.forEach(nodeId => {\n            this.removeFromSelection(nodeId, false);\n        });\n\n        // Emit selection change if nodes were removed\n        if (nodesToRemoveFromSelection.length > 0) {\n            this.emit('selectionChanged', {\n                selected: Array.from(this.selectedNodes),\n                added: [],\n                removed: nodesToRemoveFromSelection\n            });\n        }\n\n        if (this.svg) {\n            this.svg.remove();\n            this.createVisualization();\n            this.setupZoom();\n        }\n    }\n\n    /**\n     * Sets up keyboard shortcuts for multi-selection\n     */\n    setupKeyboardShortcuts() {\n        document.addEventListener('keydown', (event) => {\n            // Only handle shortcuts when visualization container is focused/active\n            const visualizationContainer = document.getElementById('visualization-container');\n            if (!visualizationContainer || !document.activeElement) return;\n\n            // Check if we're in an input field or modal\n            const activeTag = document.activeElement.tagName.toLowerCase();\n            if (['input', 'textarea', 'select'].includes(activeTag)) return;\n\n            switch (event.key) {\n                case 'Escape':\n                    if (this.getSelectionCount() > 0) {\n                        event.preventDefault();\n                        this.clearSelection();\n                    }\n                    break;\n\n                case 'a':\n                case 'A':\n                    if (event.ctrlKey || event.metaKey) {\n                        event.preventDefault();\n                        this.selectAll();\n                    }\n                    break;\n            }\n        });\n\n        // Handle clicks on empty space to clear selection\n        if (this.svg) {\n            this.svg.on('click', (event) => {\n                // Only clear if clicked on SVG background, not on nodes/links\n                if (event.target === event.currentTarget ||\n                    event.target.tagName === 'svg') {\n                    this.clearSelection();\n                }\n            });\n        }\n    }\n\n    /**\n     * Returns filtered nodes\n     */\n    getFilteredNodes() {\n        return this.data.systems.filter(system => {\n            // Category filter\n            if (!this.activeFilters.categories.includes(system.category)) {\n                return false;\n            }\n\n            // Status filter (known/unknown usage)\n            const usageType = system.knownUsage ? 'known' : 'unknown';\n            if (!this.activeFilters.knownUsage.includes(usageType)) {\n                return false;\n            }\n\n            return true;\n        }).map(system => ({ ...system }));\n    }\n\n    /**\n     * Saves the current viewport's zoom and pan state to localStorage.\n     * The state includes the x and y translation, as well as the zoom scale (k),\n     * and is stored under the key 'system_visualizer_transform'.\n     * Requires the presence of an SVG element and d3.zoomTransform.\n     */\n    saveViewportState() {\n        if (this.svg) {\n            const currentTransform = d3.zoomTransform(this.svg.node());\n            localStorage.setItem('system_visualizer_transform', JSON.stringify({\n                x: currentTransform.x,\n                y: currentTransform.y,\n                k: currentTransform.k\n            }));\n        }\n    }\n\n\n    /**\n     * Restores the viewport state of the SVG element by retrieving the last saved\n     * zoom and pan transform from localStorage and applying it using D3's zoom behavior.\n     * If the stored transform is not available or an error occurs, a warning is logged.\n     *\n     * @returns {void}\n     */\n    restoreViewportState() {\n        try {\n            const storedTransform = localStorage.getItem('system_visualizer_transform');\n            if (storedTransform && this.svg && this.zoom) {\n                const t = JSON.parse(storedTransform);\n                const transform = d3.zoomIdentity.translate(t.x, t.y).scale(t.k);\n                this.svg.call(this.zoom.transform, transform);\n            }\n        } catch (e) {\n            console.warn('Fehler beim Wiederherstellen des Viewports:', e);\n        }\n    }\n\n    /**\n     * Disables the drag functionality for nodes\n     */\n    disableDrag() {\n        if (this.nodeElements) {\n            this.nodeElements.on('.drag', null);\n        }\n        this.dragDisabled = true;\n    }\n\n    /**\n     * Enables the drag functionality for nodes again\n     */\n    enableDrag() {\n        if (this.nodeElements && this.simulationManager) {\n            this.nodeElements.call(this.simulationManager.createDragBehavior());\n        }\n        this.dragDisabled = false;\n    }\n\n    /**\n * Adds a node to the selection\n * @param {string} systemId - The ID of the system to add\n * @param {boolean} emit - Whether to emit selection events\n */\n    addToSelection(systemId, emit = true) {\n        if (!systemId || this.selectedNodes.has(systemId)) return;\n\n        this.selectedNodes.add(systemId);\n        this.lastSelectedNode = systemId;\n        this.updateNodeVisualSelection(systemId, true);\n\n        if (emit) {\n            this.emit('selectionChanged', {\n                selected: Array.from(this.selectedNodes),\n                added: [systemId],\n                removed: []\n            });\n        }\n    }\n\n    /**\n     * Removes a node from the selection\n     * @param {string} systemId - The ID of the system to remove\n     * @param {boolean} emit - Whether to emit selection events\n     */\n    removeFromSelection(systemId, emit = true) {\n        if (!systemId || !this.selectedNodes.has(systemId)) return;\n\n        this.selectedNodes.delete(systemId);\n        if (this.lastSelectedNode === systemId) {\n            this.lastSelectedNode = this.selectedNodes.size > 0 ?\n                Array.from(this.selectedNodes)[this.selectedNodes.size - 1] : null;\n        }\n        this.updateNodeVisualSelection(systemId, false);\n\n        if (emit) {\n            this.emit('selectionChanged', {\n                selected: Array.from(this.selectedNodes),\n                added: [],\n                removed: [systemId]\n            });\n        }\n    }\n\n    /**\n     * Toggles selection of a node\n     * @param {string} systemId - The ID of the system to toggle\n     * @param {boolean} emit - Whether to emit selection events\n     */\n    toggleSelection(systemId, emit = true) {\n        if (this.isNodeSelected(systemId)) {\n            this.removeFromSelection(systemId, emit);\n        } else {\n            this.addToSelection(systemId, emit);\n        }\n    }\n\n    /**\n     * Clears all selections\n     * @param {boolean} emit - Whether to emit selection events\n     */\n    clearSelection(emit = true) {\n        if (this.selectedNodes.size === 0) return;\n\n        const previousSelection = Array.from(this.selectedNodes);\n\n        // Update visual state for all selected nodes\n        this.selectedNodes.forEach(systemId => {\n            this.updateNodeVisualSelection(systemId, false);\n        });\n\n        this.selectedNodes.clear();\n        this.lastSelectedNode = null;\n\n        if (emit) {\n            this.emit('selectionChanged', {\n                selected: [],\n                added: [],\n                removed: previousSelection\n            });\n        }\n    }\n\n    /**\n     * Selects all visible nodes\n     * @param {boolean} emit - Whether to emit selection events\n     */\n    selectAll(emit = true) {\n        const allNodeIds = this.getFilteredNodes().map(node => node.id);\n        const previousSelection = Array.from(this.selectedNodes);\n\n        // Clear existing selection without emitting\n        this.clearSelection(false);\n\n        // Add all nodes to selection\n        allNodeIds.forEach(systemId => {\n            this.addToSelection(systemId, false);\n        });\n\n        if (emit) {\n            this.emit('selectionChanged', {\n                selected: allNodeIds,\n                added: allNodeIds.filter(id => !previousSelection.includes(id)),\n                removed: previousSelection.filter(id => !allNodeIds.includes(id))\n            });\n        }\n    }\n\n    /**\n     * Updates the visual selection state of a node\n     * @param {string} systemId - The ID of the system to update\n     * @param {boolean} isSelected - Whether the node should appear selected\n     */\n    updateNodeVisualSelection(systemId, isSelected) {\n        if (!this.nodeElements) return;\n\n        // Find the node element\n        const nodeElement = this.nodeElements.filter(d => d.id === systemId);\n\n        if (nodeElement.empty()) return;\n\n        // Update CSS class\n        nodeElement.classed('selected', isSelected);\n\n        // Optional: Update stroke for better visual feedback\n        nodeElement.select('circle')\n            .attr('stroke-width', isSelected ? 4 :\n                (this.getNodeGroups(nodeElement.datum()).length > 0 ? 3 : 2));\n    }\n\n    /**\n     * Updates visual selection for all nodes (useful after re-rendering)\n     */\n    updateAllNodeVisualSelections() {\n        if (!this.nodeElements) return;\n\n        this.nodeElements.each((d) => {\n            this.updateNodeVisualSelection(d.id, this.isNodeSelected(d.id));\n        });\n    }\n\n    /**\n     * Handles node click events with multi-selection support\n     * @param {Event} event - The click event\n     * @param {Object} nodeData - The data of the clicked node\n     */\n    handleNodeClick(event, nodeData) {\n        event.stopPropagation();\n\n        const systemId = nodeData.id;\n        const isShiftPressed = event.shiftKey;\n        const isCtrlPressed = event.ctrlKey || event.metaKey;\n\n        // Multi-select behavior\n        if (isShiftPressed || isCtrlPressed) {\n            this.toggleSelection(systemId);\n\n            // Emit event for multi-selection\n            if (this.getSelectionCount() > 1) {\n                this.emit('systemsSelected', {\n                    event,\n                    systems: this.getSelectedSystems(),\n                    primary: nodeData\n                });\n            } else {\n                // Single selection after toggle\n                this.emit('systemClicked', { event, system: nodeData });\n            }\n        } else {\n            // Normal click - clear other selections\n            const wasSelected = this.isNodeSelected(systemId);\n            this.clearSelection(false);\n\n            if (!wasSelected) {\n                this.addToSelection(systemId);\n            }\n\n            // Always emit single system click for normal clicks\n            this.emit('systemClicked', { event, system: nodeData });\n        }\n    }\n\n    /**\n     * Toggles fixed state for all selected nodes\n     * @returns {boolean} The new fixed state (true if any node became fixed)\n     */\n    toggleSelectedNodesFixed() {\n        const selectedIds = Array.from(this.selectedNodes);\n        if (selectedIds.length === 0) return false;\n\n        // Check current state - if any node is not fixed, fix all; otherwise unfix all\n        const hasUnfixedNodes = selectedIds.some(id => !this.isNodeFixed(id));\n        const newFixedState = hasUnfixedNodes;\n\n        // Apply to all selected nodes\n        selectedIds.forEach(systemId => {\n            this.simulationManager.setNodeFixed(systemId, newFixedState);\n        });\n\n        // Emit event for UI feedback\n        this.emit('selectedNodesFixedToggle', {\n            systems: this.getSelectedSystems(),\n            isFixed: newFixedState,\n            count: selectedIds.length\n        });\n\n        return newFixedState;\n    }\n\n    /**\n     * Centers the view on selected nodes\n     */\n    centerOnSelection() {\n        const selectedIds = Array.from(this.selectedNodes);\n        if (selectedIds.length === 0) return;\n\n        // Get positions of selected nodes\n        const nodes = selectedIds\n            .map(id => this.simulationManager.getNodeById(id))\n            .filter(node => node);\n\n        if (nodes.length === 0) return;\n\n        // Calculate bounding box\n        let minX = Infinity, maxX = -Infinity;\n        let minY = Infinity, maxY = -Infinity;\n\n        nodes.forEach(node => {\n            minX = Math.min(minX, node.x);\n            maxX = Math.max(maxX, node.x);\n            minY = Math.min(minY, node.y);\n            maxY = Math.max(maxY, node.y);\n        });\n\n        // Calculate center and scale\n        const centerX = (minX + maxX) / 2;\n        const centerY = (minY + maxY) / 2;\n        const width = maxX - minX + 200; // Add padding\n        const height = maxY - minY + 200;\n\n        // Calculate scale to fit selection\n        const scale = Math.min(\n            this.width / width,\n            this.height / height,\n            2 // Max zoom level\n        );\n\n        // Calculate translation\n        const translateX = this.width / 2 - centerX * scale;\n        const translateY = this.height / 2 - centerY * scale;\n\n        // Apply transform\n        if (this.svg && this.zoom) {\n            const transform = d3.zoomIdentity\n                .translate(translateX, translateY)\n                .scale(scale);\n\n            this.svg.transition()\n                .duration(750)\n                .call(this.zoom.transform, transform);\n        }\n    }\n\n    /**\n     * Groups selected nodes by their common properties\n     * @returns {Object} Object with grouped properties\n     */\n    getSelectedNodesGroupedProperties() {\n        const selectedSystems = this.getSelectedSystems();\n        if (selectedSystems.length === 0) return {};\n\n        const grouped = {\n            categories: {},\n            statuses: {},\n            groups: {},\n            knownUsage: { true: 0, false: 0 }\n        };\n\n        selectedSystems.forEach(system => {\n            // Count categories\n            grouped.categories[system.category] =\n                (grouped.categories[system.category] || 0) + 1;\n\n            // Count statuses\n            grouped.statuses[system.status] =\n                (grouped.statuses[system.status] || 0) + 1;\n\n            // Count known usage\n            grouped.knownUsage[system.knownUsage] += 1;\n\n            // Count groups\n            const systemGroups = this.getNodeGroups(system);\n            systemGroups.forEach(group => {\n                grouped.groups[group] = (grouped.groups[group] || 0) + 1;\n            });\n        });\n\n        return grouped;\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/components/visualizer.js?");

/***/ }),

/***/ "./src/ui/utils/node-cache.js":
/*!************************************!*\
  !*** ./src/ui/utils/node-cache.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NodeCache: () => (/* binding */ NodeCache)\n/* harmony export */ });\n/**\n * NodeCache - Manages the persistence of node positions in the diagram\n * Continuously stores positions and can load them from various sources\n */\nclass NodeCache {\n    constructor(options = {}) {\n        this.positions = new Map();\n        this.options = {\n            useLocalStorage: options.useLocalStorage || false,\n            localStorageKey: options.localStorageKey || 'system_visualizer_node_positions',\n            debounceTime: options.debounceTime || 500, // ms between local saves\n            persistGroups: options.persistGroups || true\n        };\n\n        // Debounce timer for LocalStorage updates\n        this.saveTimer = null;\n\n        // Load from LocalStorage on initialization\n        if (this.options.useLocalStorage) {\n            this.loadFromLocalStorage();\n        }\n    }\n\n    /**\n     * Stores the position of a node\n     * @param {string} id - The ID of the node\n     * @param {Object} position - The position {x, y, vx, vy} and optionally other properties\n     */\n    set(id, position) {\n        if (!id) return;\n\n        // Set current position\n        this.positions.set(id, {\n            x: position.x,\n            y: position.y,\n            vx: position.vx || 0,\n            vy: position.vy || 0,\n            // Optionally more metadata\n            lastUpdated: Date.now(),\n            isFixed: position.isFixed || false,\n        });\n\n        this.saveToLocalStorage();\n    }\n\n    /**\n     * Updates multiple nodes at once\n     * @param {Array} nodes - Array of nodes with id and position data\n     */\n    updateBatch(nodes) {\n        if (!Array.isArray(nodes)) return;\n\n        let updated = false;\n        nodes.forEach(node => {\n            if (node.id && (node.x !== undefined && node.y !== undefined)) {\n                this.positions.set(node.id, {\n                    x: node.x,\n                    y: node.y,\n                    vx: node.vx || 0,\n                    vy: node.vy || 0,\n                    lastUpdated: Date.now(),\n                    isFixed: node.isFixed || false,\n                });\n                updated = true;\n            }\n        });\n\n        if (updated) {\n            this.saveToLocalStorage();\n        }\n    }\n\n    /**\n     * Retrieves the stored position of a node\n     * @param {string} id - The ID of the node\n     * @returns {Object|null} The stored position or null\n     */\n    get(id) {\n        return this.positions.get(id) || null;\n    }\n\n    /**\n     * Checks if a position exists for a node\n     * @param {string} id - The ID of the node\n     * @returns {boolean} True if position exists\n     */\n    has(id) {\n        return this.positions.has(id);\n    }\n\n    /**\n     * Removes an entry from the cache\n     * @param {string} id - The ID of the node\n     */\n    remove(id) {\n        this.positions.delete(id);\n        this.saveToLocalStorage();\n    }\n\n    saveToLocalStorage() {\n        if (this.options.useLocalStorage) {\n            clearTimeout(this.saveTimer);\n            this.saveTimer = setTimeout(() => {\n                this.doSaveToLocalStorage();\n            }, this.options.debounceTime);\n        }\n    }\n\n    /**\n     * Save to LocalStorage\n     */\n    doSaveToLocalStorage() {\n        if (!this.options.useLocalStorage) return;\n\n        try {\n            // Convert the Map to an array of [id, data] pairs\n            const positionsArray = Array.from(this.positions);\n            localStorage.setItem(\n                this.options.localStorageKey,\n                JSON.stringify(positionsArray)\n            );\n        } catch (error) {\n            console.warn('Error saving positions:', error);\n        }\n    }\n\n    /**\n     * Load from LocalStorage\n     */\n    loadFromLocalStorage() {\n        if (!this.options.useLocalStorage) return;\n\n        try {\n            const stored = localStorage.getItem(this.options.localStorageKey);\n            if (stored) {\n                // Convert array of [id, data] pairs back to Map\n                const positionsArray = JSON.parse(stored);\n                this.positions = new Map(positionsArray);\n            }\n        } catch (error) {\n            console.warn('Error loading positions:', error);\n        }\n    }\n\n    /**\n     * Clear cache\n     * @param {boolean} alsoLocalStorage - If true, also clear LocalStorage\n     */\n    clear(alsoLocalStorage = false) {\n        this.positions.clear();\n\n        if (alsoLocalStorage && this.options.useLocalStorage) {\n            localStorage.removeItem(this.options.localStorageKey);\n        }\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/ui/utils/node-cache.js?");

/***/ }),

/***/ "./src/ui/utils/simulation.js":
/*!************************************!*\
  !*** ./src/ui/utils/simulation.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SimulationManager: () => (/* binding */ SimulationManager)\n/* harmony export */ });\n/* harmony import */ var _utils_event_emitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/event-emitter.js */ \"./src/utils/event-emitter.js\");\n\n\n/**\n * SimulationManager - Handles d3 force simulation logic separate from visualization\n */\nclass SimulationManager extends _utils_event_emitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    constructor(options = {}) {\n        super();\n        this.options = {\n            linkDistance: options.linkDistance || 150,\n            chargeStrength: options.chargeStrength || -300,\n            collisionRadius: options.collisionRadius || 60,\n            groupForceStrength: options.groupForceStrength || 0.5,\n            ...options\n        };\n\n        this.simulation = null;\n        this.nodeCache = options.nodeCache || null;\n        this.width = options.width || 800;\n        this.height = options.height || 600;\n\n        // For throttling cache updates\n        this.lastCacheUpdate = 0;\n        this.cacheUpdateInterval = options.cacheUpdateInterval || 300;\n\n        // Callbacks\n        this.onTick = options.onTick || (() => { });\n        this.onEnd = options.onEnd || (() => { });\n        this.onToggleFixed = options.onToggleFixed || (() => { });\n    }\n\n    /**\n     * Returns the node with the given ID from the current simulation\n     * @param {string} systemId - The ID of the system to find\n     * @returns {Object|null} The node object or null if not found\n     */\n    getNodeById(systemId) {\n        return this.simulation.nodes().find(node => node.id === systemId);\n    }\n\n    /**\n     * Checks if a node is fixed\n     * @param {string} systemId - The ID of the system to check\n     * @returns {boolean} True if the node is fixed, false otherwise or if not found\n     */\n    isNodeFixed(systemId, curNode = undefined) {\n        const node = curNode || this.getNodeById(systemId);\n        return node ? !!node.isFixed : false;\n    }\n\n    /**\n     * Toggles the fixed state of a node identified by systemId.\n     *\n     * @param {string|number} systemId - The unique identifier of the node to toggle.\n     * @param {Object} [curNode=undefined] - The current node object (optional). If not provided, the node will be retrieved by systemId.\n     * @returns {null|undefined} Returns null if the node is not found; otherwise, returns undefined.\n     */\n    toggleNodeFixed(systemId, curNode = undefined) {\n        const node = curNode || this.getNodeById(systemId);\n        if (!node) return null;\n        const isFixed = this.isNodeFixed(systemId, node);\n        const newState = !isFixed;\n        this.setNodeFixed(systemId, newState, node);\n    }\n\n    /**\n     * Sets or removes the fixed position of a node in the simulation.\n     *\n     * @param {string|number} systemId - The unique identifier of the node to fix or unfix.\n     * @param {boolean} state - If true, fixes the node at its current position; if false, releases the node.\n     * @param {Object} [curNode=undefined] - (Optional) The node object to operate on. If not provided, the node is retrieved by systemId.\n     * @returns {boolean|null} Returns the node's fixed state after the operation, or null if the node was not found.\n     */\n    setNodeFixed(systemId, state, curNode = undefined) {\n        const node = curNode || this.getNodeById(systemId);\n        if (!node) return null;\n\n        const stateBefore = node.isFixed;\n        if (!state) {\n            // Remove fixation\n            node.isFixed = false;\n            node.fx = null;\n            node.fy = null;\n        } else {\n            // Fix node at current position\n            node.isFixed = true;\n            node.fx = node.x;\n            node.fy = node.y;\n        }\n\n        // Update cache\n        if (this.nodeCache && node.id) {\n            this.nodeCache.set(node.id, {\n                x: node.x,\n                y: node.y,\n                vx: node.vx || 0,\n                vy: node.vy || 0,\n                isFixed: node.isFixed\n            });\n        }\n\n        // Slightly restart simulation\n        this.restart(0.1);\n\n        this.onToggleFixed && state != stateBefore && this.onToggleFixed(systemId, state);\n\n        return node.isFixed;\n    }\n\n    /**\n     * Initialize simulation with nodes and links\n     */\n    initialize(nodes, links, groups) {\n        // Apply cached positions before simulation starts\n        if (this.nodeCache) {\n            this.applyNodePositionsFromCache(nodes);\n        }\n\n        // Calculate initial positions for nodes without cache positions\n        this.applyInitialPositions(nodes);\n\n        // Create simulation\n        this.simulation = d3.forceSimulation(nodes)\n            .force(\"link\", d3.forceLink(links)\n                .id(d => d.id)\n                .distance(this.options.linkDistance))\n            .force(\"charge\", d3.forceManyBody()\n                .strength(this.options.chargeStrength))\n            .force(\"center\", d3.forceCenter(this.width / 2, this.height / 2))\n            .force(\"collision\", d3.forceCollide()\n                .radius(this.options.collisionRadius));\n\n        // Add group force if groups are provided\n        if (groups && Object.keys(groups).length > 0) {\n            this.simulation.force(\"group\", d3.forceClusterMultiGroup()\n                .centers(groups)\n                .strength(this.options.groupForceStrength));\n        }\n\n        // Add containment force to keep nodes within bounds\n        this.simulation.force(\"containment\", this.createContainmentForce());\n\n        // Register tick handler\n        this.simulation.on(\"tick\", () => {\n            // Update node cache periodically during simulation\n            this.throttledUpdateNodeCache();\n\n            // Call external tick handler\n            this.onTick();\n        });\n\n        // Register end handler\n        this.simulation.on(\"end\", () => {\n            // Save final positions to cache\n            if (this.nodeCache) {\n                this.nodeCache.updateBatch(this.simulation.nodes());\n            }\n\n            // Call external end handler\n            this.onEnd();\n        });\n\n        return this.simulation;\n    }\n\n    /**\n     * Retrieves the groups associated with a node.\n     *\n     * If the node has a non-empty `groups` array, it returns that array.\n     * If the node has a `group` property as a string, it returns an array containing that string.\n     * Otherwise, it returns an empty array.\n     *\n     * @param {Object} node - The node object to extract groups from.\n     * @param {Array<string>} [node.groups] - An optional array of group names.\n     * @param {string} [node.group] - An optional single group name.\n     * @returns {Array<string>} An array of group names associated with the node.\n     */\n    getNodeGroups(node) {\n        if (Array.isArray(node.groups) && node.groups.length > 0) {\n            return node.groups;\n        } else if (node.group && typeof node.group === 'string') {\n            return [node.group];\n        }\n        return [];\n    }\n\n    /**\n     * Create a force that keeps nodes within the container bounds\n     */\n    createContainmentForce() {\n        // Add padding to prevent nodes from touching the edge\n        const padding = 50;\n\n        return () => {\n            for (let node of this.simulation.nodes()) {\n                // Gradually increase force as node approaches boundaries\n                if (node.x < padding) {\n                    node.vx += (padding - node.x) * 0.1;\n                } else if (node.x > this.width - padding) {\n                    node.vx -= (node.x - (this.width - padding)) * 0.1;\n                }\n\n                if (node.y < padding) {\n                    node.vy += (padding - node.y) * 0.1;\n                } else if (node.y > this.height - padding) {\n                    node.vy -= (node.y - (this.height - padding)) * 0.1;\n                }\n\n                // Dampen velocity for stable movement\n                node.vx *= 0.9;\n                node.vy *= 0.9;\n            }\n        };\n    }\n\n    /**\n     * Applies cached positions and velocities to a list of nodes.\n     * \n     * For each node with a matching entry in the node cache, updates its position (`x`, `y`),\n     * velocity (`vx`, `vy`), and temporarily fixes its position (`fx`, `fy`) for visual stability.\n     * If the node is not marked as fixed, releases the fixed position after a short delay.\n     * \n     * @param {Array<Object>} nodes - Array of node objects to update. Each node should have an `id` property.\n     * @returns {number} The number of nodes that had their positions updated from the cache.\n     */\n    applyNodePositionsFromCache(nodes) {\n        if (!nodes || !this.nodeCache) return 0;\n\n        let cacheHits = 0;\n        nodes.forEach(node => {\n            if (node.id) {\n                const cachedPosition = this.nodeCache.get(node.id);\n                if (cachedPosition) {\n                    // Position from cache\n                    node.x = cachedPosition.x;\n                    node.y = cachedPosition.y;\n\n                    // Reduced velocity for smoother transitions\n                    node.vx = (cachedPosition.vx || 0) * 0.3;\n                    node.vy = (cachedPosition.vy || 0) * 0.3;\n\n                    // Briefly fix position for visual stability\n                    node.fx = cachedPosition.x;\n                    node.fy = cachedPosition.y;\n\n                    // Schedule release of fixed position\n                    node.isFixed = !!cachedPosition.isFixed;\n                    if(!node.isFixed) {\n                        setTimeout(() => {\n                            node.fx = null;\n                            node.fy = null;\n                        }, 500);\n                    }\n\n                    cacheHits++;\n                }\n            }\n        });\n\n        return cacheHits;\n    }\n\n    /**\n     * Assigns initial positions and velocities to nodes that lack position data.\n     * \n     * For each node without a position, this method:\n     * - Attempts to find reference nodes in the same group(s) (if any), or falls back to all positioned nodes.\n     * - Calculates a target position near the center of the reference nodes, with a random offset.\n     * - Places the node at a random angle and distance from the target position.\n     * - Sets an initial velocity pointing gently toward the target position.\n     * \n     * @param {Array<Object>} nodes - Array of node objects. Each node may have `x`, `y`, `vx`, `vy` properties and group information.\n     */\n    applyInitialPositions(nodes) {\n        // Find nodes without position\n        const nodesWithoutPosition = nodes.filter(node =>\n            node.x === undefined || node.y === undefined);\n\n        if (nodesWithoutPosition.length === 0) return;\n\n        // Get positioned nodes\n        const positionedNodes = nodes.filter(node =>\n            node.x !== undefined && node.y !== undefined);\n\n        // For each new node\n        nodesWithoutPosition.forEach(node => {\n            let referenceNodes = [];\n            let targetPosition;\n\n            // Reference nodes based on groups or all nodes\n            const nodeGroups = this.getNodeGroups(node);\n\n            if (nodeGroups.length > 0) {\n                // Collect all reference nodes for all groups of the node\n                nodeGroups.forEach(group => {\n                    const groupNodes = positionedNodes.filter(n => {\n                        const nGroups = this.getNodeGroups(n);\n                        return nGroups.includes(group);\n                    });\n\n                    referenceNodes = [...referenceNodes, ...groupNodes];\n                });\n\n                // Remove duplicates\n                referenceNodes = Array.from(new Set(referenceNodes));\n            }\n\n            if (referenceNodes.length === 0) {\n                referenceNodes = positionedNodes;\n            }\n\n            // Calculate target position (between all group centers)\n            if (referenceNodes.length > 0) {\n                let sumX = 0, sumY = 0;\n                referenceNodes.forEach(refNode => {\n                    sumX += refNode.x;\n                    sumY += refNode.y;\n                });\n\n                // Group center with offset\n                const isGroupCentered = referenceNodes !== positionedNodes;\n                const offset = isGroupCentered ? 50 : 150;\n\n                targetPosition = {\n                    x: (sumX / referenceNodes.length) + (Math.random() - 0.5) * offset,\n                    y: (sumY / referenceNodes.length) + (Math.random() - 0.5) * offset\n                };\n            } else {\n                // If no references, use screen center\n                targetPosition = {\n                    x: this.width / 2 + (Math.random() - 0.5) * 200,\n                    y: this.height / 2 + (Math.random() - 0.5) * 200\n                };\n            }\n\n            // Starting position at group center edge\n            const distanceFromCenter = referenceNodes.length > 0 ? 100 : 200;\n            const angle = Math.random() * Math.PI * 2;  // Random angle\n\n            node.x = targetPosition.x + Math.cos(angle) * distanceFromCenter;\n            node.y = targetPosition.y + Math.sin(angle) * distanceFromCenter;\n\n            // Initial velocity toward target position\n            const dx = targetPosition.x - node.x;\n            const dy = targetPosition.y - node.y;\n\n            // Gentle movement toward center\n            const speedFactor = 0.01;  // Very low for gentle movement\n            node.vx = dx * speedFactor;\n            node.vy = dy * speedFactor;\n        });\n    }\n\n    /**\n     * Update node cache throttled\n     */\n    throttledUpdateNodeCache() {\n        const now = Date.now();\n        if (this.nodeCache && now - this.lastCacheUpdate > this.cacheUpdateInterval) {\n            this.lastCacheUpdate = now;\n            this.nodeCache.updateBatch(this.simulation.nodes());\n        }\n    }\n\n    /**\n     * Restart simulation with alpha\n     */\n    restart(alpha = 0.3) {\n        if (this.simulation) {\n            this.simulation.alpha(alpha).restart();\n        }\n    }\n\n    /**\n     * Stop simulation\n     */\n    stop() {\n        if (this.simulation) {\n            this.simulation.stop();\n        }\n    }\n\n    /**\n     * Update simulation size\n     */\n    updateSize(width, height) {\n        this.width = width;\n        this.height = height;\n\n        if (this.simulation) {\n            this.simulation.force(\"center\", d3.forceCenter(width / 2, height / 2));\n            // Restart with low alpha to adjust positions\n            this.restart(0.1);\n        }\n    }\n\n    /**\n     * Create drag behavior\n     */\n    createDragBehavior() {\n        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n        return d3.drag()\n            .on(\"start\", (event, d) => {\n                if (isTouchDevice && event.sourceEvent) {\n                    event.sourceEvent.preventDefault();\n                }\n                this.dragstarted(event, d);\n            })\n            .on(\"start\", (event, d) => this.dragstarted(event, d))\n            .on(\"drag\", (event, d) => this.dragged(event, d))\n            .on(\"end\", (event, d) => this.dragended(event, d))\n            .touchable(true)\n            .filter(function(event) {\n                if (isTouchDevice) return true;\n                return !event.ctrlKey && !event.button;\n            });\n    }\n\n    /**\n     * Handle drag start\n     */\n    dragstarted(event, d) {\n        if (!event.active) this.simulation.alphaTarget(0.3).restart();\n        d.fx = d.x;\n        d.fy = d.y;\n        this.setNodeFixed(d.id, true, d);\n    }\n\n    /**\n     * Handle dragging\n     */\n    dragged(event, d) {\n        d.fx = event.x;\n        d.fy = event.y;\n    }\n\n    /**\n     * Handle drag end\n     */\n    dragended(event, d) {\n        if (!event.active) this.simulation.alphaTarget(0);\n\n        // Only persist position in cache if dragged\n        if (this.nodeCache && d.id) {\n            this.nodeCache.set(d.id, {\n                x: d.x,\n                y: d.y,\n                vx: 0,\n                vy: 0,\n                isFixed: d.isFixed || false\n            });\n        }\n    }\n}\n\nd3.forceClusterMultiGroup = function () {\n    let strength = 0.1;\n    let centers = {};\n    let nodes = [];\n\n    // Weight for each group (1/number of groups of a node)\n    // So that nodes with fewer groups are more strongly attracted to their groups\n    function getGroupWeight(node) {\n        const nodeGroups = getNodeGroups(node);\n        return nodeGroups.length > 0 ? 1 / nodeGroups.length : 0;\n    }\n\n    // Helper function to extract all groups of a node\n    function getNodeGroups(node) {\n        if (Array.isArray(node.groups) && node.groups.length > 0) {\n            return node.groups;\n        } else if (node.group && typeof node.group === 'string') {\n            return [node.group];\n        }\n        return [];\n    }\n\n    function force(alpha) {\n        // For each node\n        nodes.forEach(d => {\n            const nodeGroups = getNodeGroups(d);\n            if (nodeGroups.length === 0) return; // Skip if no group\n\n            // Vector for the total force on the node\n            let totalForceX = 0;\n            let totalForceY = 0;\n            let totalWeight = 0;\n\n            // Calculate force from each group\n            nodeGroups.forEach(groupName => {\n                const groupCenter = centers[groupName];\n                if (!groupCenter) return;\n\n                // Weight for this group\n                const weight = getGroupWeight(d);\n                totalWeight += weight;\n\n                // Adjust force depending on the number of groups the node is in\n                const k = strength * alpha * weight;\n\n                // Force towards the group center\n                totalForceX += (groupCenter.x - d.x) * k;\n                totalForceY += (groupCenter.y - d.y) * k;\n            });\n\n            // Apply total force to the node\n            if (totalWeight > 0) {\n                d.vx += totalForceX;\n                d.vy += totalForceY;\n            }\n        });\n    }\n\n    force.initialize = function (_) {\n        nodes = _;\n    };\n\n    force.centers = function (_) {\n        return arguments.length ? (centers = _, force) : centers;\n    };\n\n    force.strength = function (_) {\n        return arguments.length ? (strength = _, force) : strength;\n    };\n\n    return force;\n};\n\n//# sourceURL=webpack://infravis/./src/ui/utils/simulation.js?");

/***/ }),

/***/ "./src/utils/completion.js":
/*!*********************************!*\
  !*** ./src/utils/completion.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGenerator: () => (/* binding */ createGenerator),\n/* harmony export */   handleSse: () => (/* binding */ handleSse)\n/* harmony export */ });\nclass PromptTemplate {\n    constructor(template) {\n        this.template = template;\n    }\n\n    // Methode 1: Template Literals (moderne ES6+ Syntax)\n    formatWithTemplateString(variables) {\n        return new Function(...Object.keys(variables), `return \\`${this.template}\\`;`)(...Object.values(variables));\n    }\n\n    // Methode 2: Named Parameters mit {{name}}\n    formatWithNamedParams(variables) {\n        return this.template.replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => variables[key] || \"\");\n    }\n}\n\nclass AbstractLlmApi {\n    async generate() {\n        throw new Error(\"Not implemented\");\n    }\n\n    setSystemPrompt(systemPrompt) {\n        this.systemPrompt = systemPrompt; \n    }\n\n    getSystemPrompt() {\n        return this.systemPrompt;\n    }\n\n    attachMessage(role, content) {\n        if(!this.messages) {\n            this.reset();\n        }\n        this.messages.push({ role, content });\n    }\n\n    attachMessageAsAssistant(content) {\n        this.attachMessage(this.getAssistantRole(), content);\n    }\n\n    attachMessageAsUser(content) {\n        this.attachMessage(this.getUserRole(), content);\n    }\n\n    reset() {\n        this.messages = [];\n    }\n\n    extractMessages(line) {\n        throw new Error(\"Not implemented\");\n    }\n\n    getAssistantRole() {\n        return \"assistant\";\n    }\n    getUserRole() {\n        return \"user\";\n    }\n    getDetails() {\n        return {\"type\": \"unknown\"};\n    }\n}\n\nclass ClaudeApi extends AbstractLlmApi {\n    constructor(apiKey, model) {\n        super();\n        this.apiKey = apiKey;\n        this.model = model;\n    }\n\n    getDetails() {\n        return {\"type\": \"claude\", \"model\": this.model};\n    }\n\n    async generate() {\n        try {\n            const body = JSON.stringify({\n                model: this.model || \"claude-3-5-sonnet-20241022\",\n                max_tokens: 4096,\n                stream: true,\n                system: [{\n                    type: \"text\",\n                    cache_control: {\"type\": \"ephemeral\"},\n                    text: this.systemPrompt\n                }],\n                messages: this.messages\n            });\n\n            const response = await fetch('https://api.anthropic.com/v1/messages', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'x-api-key': this.apiKey,\n                    'anthropic-version': '2023-06-01',\n                    'anthropic-dangerous-direct-browser-access': 'true'\n                },\n                body\n            });\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(`API error: ${response.status} ${response.statusText}\\nDetails: ${errorText}`);\n            }\n\n            return response.body;\n        } catch (error) {\n            throw new Error(`Failed to generate alternative: ${error.message}`);\n        }\n    }\n\n    extractMessages(line) {\n        if (!line || line.trim() === '') {\n            return '';\n        }\n        //console.log(`Message: ${line}`);\n        const parsedData = JSON.parse(line);\n\n        // We got a valid JSON message, but it might be an error\n        if (parsedData.type === \"error\") {\n            const error = new Error(`Stream error: ${parsedData.error?.type} - ${parsedData.error?.message}`);\n            error.isStreamError = true;\n            error.errorData = parsedData.error;\n            throw error;\n        }\n\n        // We got a valid JSON message and it looks like a delta\n        if (parsedData.delta && parsedData.delta.text) {\n            return parsedData.delta.text;\n        }\n        \n        return '';\n    }\n}\n\nclass OpenAiApi extends AbstractLlmApi {\n    constructor(apiKey, model) {\n        super();\n        this.apiKey = apiKey;\n        this.model = model;\n    }\n\n    getDetails() {\n        return {\"type\": \"openai\", \"model\": this.model};\n    }\n\n    reset() {\n        this.messages = [];\n        if (this.systemPrompt) {\n            this.attachMessage(\"system\", this.systemPrompt);\n        }\n    }\n\n    async generate() {\n        try {\n            const body = JSON.stringify({\n                model: this.model || \"gpt-4-turbo-preview\",\n                messages: this.messages,\n                max_tokens: 4096,\n                temperature: 0.7,\n                stream: true\n            });\n\n            const response = await fetch('https://api.openai.com/v1/chat/completions', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${this.apiKey}`\n                },\n                body\n            });\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(`API error: ${response.status} ${response.statusText}\\nDetails: ${errorText}`);\n            }\n\n            return response.body;\n        } catch (error) {\n            throw new Error(`Failed to generate alternative: ${error.message}`);\n        }\n    }\n\n    extractMessages(line) {\n        const parsedData = JSON.parse(line);\n        const token = parsedData.choices[0].delta.content || '';\n        return token;\n    }\n}\n\nclass CustomBasedOnOpenAiApi extends AbstractLlmApi {\n    constructor(apiKey, model, url) {\n        super();\n        this.apiKey = apiKey;\n        this.model = model;\n        this.url = url.endsWith('/') ? url.slice(0, -1) : url;\n    }\n\n    getDetails() {\n        return {\"type\": \"custom\", \"model\": this.model, \"url\": this.url};\n    }\n\n    reset() {\n        this.messages = [];\n        if (this.systemPrompt) {\n            this.attachMessage(\"system\", this.systemPrompt);\n        }\n    }\n\n    async generate() {\n        const body = JSON.stringify({\n            model: this.model || \"\",\n            messages: this.messages,\n            max_tokens: 1024,\n            temperature: 0.7,\n            stream: true\n        });\n\n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        if (this.apiKey) {\n            headers['Authorization'] = `Bearer ${this.apiKey}`;\n        }\n        let response;\n        const url = `${this.url}/v1/chat/completions`;\n        try {\n            response = await fetch(url, {\n                method: 'POST',\n                headers,\n                body\n            });\n\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(`API error: ${response.status} ${response.statusText}\\nDetails: ${errorText}`);\n            }\n\n            return response.body;\n        } catch (error) {\n            throw new Error(`Failed to generate alternative: ${error.message}\\nRequest Details: ${JSON.stringify({ url, body, headers, response }, null, 2)}`);\n        }\n    }\n\n    extractMessages(line) {\n        const parsedData = JSON.parse(line);\n        const token = parsedData.choices[0].delta.content || '';\n        return token;\n    }\n}\n\nclass Generator {\n    constructor(api, systemPrompt, promptPrefix, variables) {\n        this.api = api;\n        this.systemPrompt = systemPrompt;\n        this.promptPrefix = promptPrefix;\n        this.variables = variables;\n\n        this.reset();\n    }\n\n    getApiDetails() {\n        return this.api.getDetails();\n    }\n\n    reset() {\n        // Create prompt templates to replace them with information from variables\n        const systemPromptTemplate = new PromptTemplate(this.systemPrompt);\n\n        // Set current system prompt\n        this.api.setSystemPrompt(systemPromptTemplate.formatWithNamedParams(this.variables));\n\n        // Reset message history, some providers might require to add this to the message list\n        this.api.reset();\n    }\n\n    attachMessageAsAssistant(text) {\n        this.api.attachMessageAsAssistant(text);\n    }\n\n    attachMessageAsUser(text) {\n        this.api.attachMessageAsUser(text);\n    }\n\n    attachMessageAsUserUsingPrefix(variables) {\n        const codePromptTemplate = new PromptTemplate(this.promptPrefix);\n        this.api.attachMessageAsUser(codePromptTemplate.formatWithNamedParams(variables));\n    }\n\n    async generate() {\n        return await this.api.generate();\n    }\n\n    extractMessages(line) {\n        return this.api.extractMessages(line);\n    }\n\n    getMessages() {\n        return this.api.messages.map(el => {\n            let role = el.role;\n            if(el.role === this.api.getUserRole()) {\n                role = \"user\";\n            } else if(el.role === this.api.getAssistantRole()) {\n                role = \"assistant\";\n            }\n            return {\n                role,\n                content: el.content\n            }\n        });\n    }\n\n    restoreMessages(messages) {\n        this.api.messages = messages.map(el => {\n            let role = el.role;\n            if (el.role === \"user\") {\n                role = this.api.getUserRole();\n            } else if (el.role === \"assistant\") {\n                role = this.api.getAssistantRole();\n            }\n            return {\n                role,\n                content: el.content\n            };\n        });\n    }\n\n    getSystemPrompt() {\n        return this.api.getSystemPrompt();\n    }\n}\n\nfunction createGenerator(variables, systemPrompt = \"\", promptPrefix = \"\", options = {}) {\n    const llmType = options.llmType;\n    const llmModel = options.llmModel;\n    const llmApiKey = options.llmApiKey;\n\n    let api;\n    if (llmType === 'claude') {\n        api = new ClaudeApi(llmApiKey, llmModel);\n    } else if (llmType === 'openai') {\n        api = new OpenAiApi(llmApiKey, llmModel);\n    } else if (llmType === 'custom') {\n        const llmUrl = options.llmUrl;\n        api = new CustomBasedOnOpenAiApi(llmApiKey, llmModel, llmUrl);\n    } else {\n        throw new Error(`Unknown LLM type: ${llmType}`);\n    }\n\n    return new Generator(api, systemPrompt, promptPrefix, variables);\n}\n\nasync function handleSse(generator, callback) {\n    const stream = await generator.generate();\n    const reader = stream.getReader();\n    const decoder = new TextDecoder();\n\n    let result = '';\n    let buffer = '';\n    \n    try {\n        reading: while (true) {\n            const { done, value } = await reader.read();\n\n            if (done) {\n                break;\n            }\n\n            // Decodiere den Chunk und füge ihn zum Buffer hinzu\n            buffer += decoder.decode(value, { stream: true });\n\n            let pos;\n            while ((pos = buffer.indexOf('\\n\\n')) >= 0) {\n                const event = buffer.substring(0, pos);\n                buffer = buffer.substring(pos + 2);\n\n                const lines = event.split('\\n');\n                let data = '';\n                \n                for (const line of lines) {\n                    if (line.startsWith('data:')) {\n                        data += line.substring(5).trim();\n                    }\n                }\n\n                if (data === '[DONE]') {\n                    break reading;\n                }\n\n                if (data) {\n                    try {\n                        const token = generator.extractMessages(data);\n                        result += token;\n                        if (callback) {\n                            callback(undefined, token);\n                        }\n                    } catch (error) {\n                        if (error.isStreamError) {\n                            console.error(`Stream error: ${error.message}`);\n                            if (callback) {\n                                callback(JSON.stringify({\n                                    error: true,\n                                    type: error.errorData?.type,\n                                    message: error.errorData?.message\n                                }));\n                            }\n                            break reading;\n                        }\n                        console.error('Failed to parse JSON:', error);\n                    }\n                }\n            }\n        }\n    } catch (error) {\n        console.error('Stream processing error:', error);\n    }\n    \n    return result;\n}\n\n//# sourceURL=webpack://infravis/./src/utils/completion.js?");

/***/ }),

/***/ "./src/utils/data-loader.js":
/*!**********************************!*\
  !*** ./src/utils/data-loader.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   downloadSystemData: () => (/* binding */ downloadSystemData),\n/* harmony export */   downloadVisualizationAsPNG: () => (/* binding */ downloadVisualizationAsPNG),\n/* harmony export */   downloadVisualizationAsSVG: () => (/* binding */ downloadVisualizationAsSVG),\n/* harmony export */   uploadSystemData: () => (/* binding */ uploadSystemData),\n/* harmony export */   validateSystemData: () => (/* binding */ validateSystemData)\n/* harmony export */ });\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities.js */ \"./src/utils/utilities.js\");\n\n\n\n/**\n * Opens a file dialog for the user to upload a YAML file containing system data.\n * Parses and validates the selected YAML file, updates the DataManager with the new data,\n * refreshes the visualization, and displays notifications based on the outcome.\n *\n * Utilizes a hidden file input element to trigger the file selection dialog.\n * Supports files with .yaml or .yml extensions.\n *\n * @function\n * @returns {void}\n */\nfunction uploadSystemData(dataManager) {\n    // Create a hidden file input element\n    const fileInput = document.createElement('input');\n    fileInput.type = 'file';\n    fileInput.accept = '.yaml,.yml';\n    fileInput.style.display = 'none';\n    document.body.appendChild(fileInput);\n    \n    // Simulate a click on the hidden input element\n    fileInput.click();\n    \n    // Event listener for file selection\n    fileInput.addEventListener('change', function(event) {\n        const file = event.target.files[0];\n        if (!file) return;\n        \n        const reader = new FileReader();\n        reader.onload = async function(e) {\n            try {\n                const yamlContent = e.target.result;\n                const parsedData = jsyaml.load(yamlContent);\n                \n                // Validate the data structure\n                if (!validateSystemData(parsedData)) {\n                    (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Invalid data format', 'danger');\n                    return;\n                }\n                \n                // Update data in DataManager\n                dataManager.setData(parsedData);\n                \n                (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Data loaded successfully', 'success');\n            } catch (error) {\n                console.error('Error parsing the YAML file:', error);\n                (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Invalid YAML format', 'danger');\n            }\n        };\n        \n        reader.readAsText(file);\n        \n        // Remove the temporary input element\n        document.body.removeChild(fileInput);\n    });\n}\n\n/**\n * Validates the uploaded data structure\n * @param {Object} data - The data structure to validate\n * @returns {boolean} True if the data is valid\n */\nfunction validateSystemData(data) {\n    // Check if the basic structure exists\n    if (!data || !Array.isArray(data.systems) || !Array.isArray(data.dependencies)) {\n        return false;\n    }\n    \n    // Check if all systems have an ID\n    const allSystemsHaveId = data.systems.every(system => !!system.id);\n    if (!allSystemsHaveId) {\n        return false;\n    }\n    \n    // Check if all dependencies have valid source and target\n    const allDependenciesValid = data.dependencies.every(dep => \n        !!dep.source && !!dep.target && \n        data.systems.some(sys => sys.id === dep.source) && \n        data.systems.some(sys => sys.id === dep.target)\n    );\n    \n    return allDependenciesValid;\n}\n\n/**\n * Downloads the current system data as a YAML file\n */\nfunction downloadSystemData(dataManager) {\n    const currentData = dataManager.getData();\n    \n    if (!currentData || !currentData.systems || currentData.systems.length === 0) {\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('No data available for download', 'warning');\n        return;\n    }\n    \n    try {\n        // Convert the JS object to YAML\n        const yamlString = jsyaml.dump(currentData);\n        \n        // Create a Blob and a download link\n        const blob = new Blob([yamlString], { type: 'application/x-yaml' });\n        const url = URL.createObjectURL(blob);\n        \n        const a = document.createElement('a');\n        a.href = url;\n        a.download = 'systems.yaml';\n        document.body.appendChild(a);\n        a.click();\n        \n        // Clean up\n        setTimeout(() => {\n            document.body.removeChild(a);\n            URL.revokeObjectURL(url);\n        }, 100);\n        \n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Data downloaded successfully', 'success');\n    } catch (error) {\n        console.error('Error downloading the data:', error);\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Error during download', 'danger');\n    }\n}\n/**\n * Exports the current visualization as an SVG file\n */\nfunction downloadVisualizationAsSVG() {\n    // Find the SVG element\n    const svgElement = document.querySelector('#visualization-container svg');\n    if (!svgElement) {\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('No visualization found to download', 'warning');\n        return;\n    }\n\n    try {\n        // Clone the SVG to not modify the original\n        const clonedSvg = svgElement.cloneNode(true);\n        \n        // Add CSS styles inline for the exported SVG\n        const styles = document.createElement('style');\n        for (const sheet of document.styleSheets) {\n            try {\n                if (sheet.href && sheet.href.includes('styles.css')) {\n                    // Add only relevant CSS styles\n                    for (const rule of sheet.cssRules) {\n                        if (rule.selectorText && (\n                            rule.selectorText.includes('.node') || \n                            rule.selectorText.includes('.link') || \n                            rule.selectorText.includes('.group') ||\n                            rule.selectorText.includes('svg') ||\n                            rule.selectorText.includes('circle') ||\n                            rule.selectorText.includes('text') ||\n                            rule.selectorText.includes('path')\n                        )) {\n                            styles.textContent += rule.cssText + '\\n';\n                        }\n                    }\n                }\n            } catch (err) {\n                // Some stylesheets may not be accessible due to CORS\n                console.warn('Could not access stylesheet:', err);\n            }\n        }\n        \n        // Add the styles to the SVG\n        clonedSvg.insertBefore(styles, clonedSvg.firstChild);\n        \n        // Set width and height attributes\n        const width = svgElement.clientWidth || 1200;\n        const height = svgElement.clientHeight || 800;\n        clonedSvg.setAttribute('width', width);\n        clonedSvg.setAttribute('height', height);\n        \n        // Add viewBox if it doesn't exist\n        if (!clonedSvg.getAttribute('viewBox')) {\n            clonedSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n        }\n        \n        // Convert SVG to XML string\n        const serializer = new XMLSerializer();\n        let svgString = serializer.serializeToString(clonedSvg);\n        \n        // Add XML declaration and DOCTYPE\n        svgString = '<?xml version=\"1.0\" standalone=\"no\"?>\\n' + svgString;\n        \n        // Create a blob and download link\n        const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });\n        const url = URL.createObjectURL(blob);\n        const link = document.createElement('a');\n        \n        // Set download attributes\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n        link.href = url;\n        link.download = `infrastructure-map-${timestamp}.svg`;\n        \n        // Trigger download\n        document.body.appendChild(link);\n        link.click();\n        \n        // Clean up\n        setTimeout(() => {\n            document.body.removeChild(link);\n            URL.revokeObjectURL(url);\n        }, 100);\n        \n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Visualization downloaded successfully', 'success');\n    } catch (error) {\n        console.error('Error downloading the SVG file:', error);\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Error during download', 'danger');\n    }\n}\n\n/**\n * Exports the current visualization as a PNG file\n */\nfunction downloadVisualizationAsPNG() {\n    // Find the SVG element\n    const svgElement = document.querySelector('#visualization-container svg');\n    if (!svgElement) {\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('No visualization found to download', 'warning');\n        return;\n    }\n\n    try {\n        // Clone the SVG to not modify the original\n        const clonedSvg = svgElement.cloneNode(true);\n\n        // Ensure that all link paths have no fill\n        const linkPaths = clonedSvg.querySelectorAll('.link');\n        linkPaths.forEach(path => {\n            // Set basic properties for all links\n            path.setAttribute('fill', 'none');\n            path.setAttribute('stroke-width', '1.5px');\n            path.setAttribute('stroke-opacity', '0.6');\n            \n            // Set color depending on connection type\n            const linkType = path.getAttribute('data-type');\n            switch(linkType) {\n                case 'data':\n                    path.setAttribute('stroke', '#0d6efd');\n                    break;\n                case 'integration':\n                    path.setAttribute('stroke', '#198754');\n                    break;\n                case 'authentication':\n                    path.setAttribute('stroke', '#dc3545');\n                    break;\n                case 'monitoring':\n                    path.setAttribute('stroke', '#6c757d');\n                    break;\n                default:\n                    path.setAttribute('stroke', '#999');\n            }\n        });\n        \n        // Set width and height attributes\n        const width = svgElement.clientWidth || 1200;\n        const height = svgElement.clientHeight || 800;\n        clonedSvg.setAttribute('width', width);\n        clonedSvg.setAttribute('height', height);\n        \n        // Add viewBox if it doesn't exist\n        if (!clonedSvg.getAttribute('viewBox')) {\n            clonedSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n        }\n        \n        // Convert SVG to XML string with inline styles\n        const serializer = new XMLSerializer();\n        let svgString = serializer.serializeToString(clonedSvg);\n        \n        // Create an Image object\n        const img = new Image();\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        const ctx = canvas.getContext('2d');\n        \n        // Set SVG as image source (as Data URL)\n        img.onload = function() {\n            // Fill background with white (SVG might have transparent background)\n            ctx.fillStyle = '#ffffff';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            \n            // Draw SVG image on canvas\n            ctx.drawImage(img, 0, 0);\n            \n            // Convert canvas to PNG and trigger download\n            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n            const pngUrl = canvas.toDataURL('image/png');\n            \n            const link = document.createElement('a');\n            link.href = pngUrl;\n            link.download = `infrastructure-map-${timestamp}.png`;\n            \n            document.body.appendChild(link);\n            link.click();\n            \n            // Clean up\n            setTimeout(() => {\n                document.body.removeChild(link);\n            }, 100);\n            \n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Visualization successfully downloaded as PNG', 'success');\n        };\n        \n        // Handle error\n        img.onerror = function() {\n            console.error('Error loading SVG into Image object');\n            (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Error converting to PNG', 'danger');\n        };\n        \n        // Create a Blob containing the SVG and convert to Data URL\n        const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });\n        const reader = new FileReader();\n        reader.onload = function(e) {\n            img.src = e.target.result;\n        };\n        reader.readAsDataURL(blob);\n    } catch (error) {\n        console.error('Error downloading as PNG:', error);\n        (0,_utilities_js__WEBPACK_IMPORTED_MODULE_0__.showNotification)('Error during download', 'danger');\n    }\n}\n\n\n//# sourceURL=webpack://infravis/./src/utils/data-loader.js?");

/***/ }),

/***/ "./src/utils/event-emitter.js":
/*!************************************!*\
  !*** ./src/utils/event-emitter.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter)\n/* harmony export */ });\n/**\n * A simple EventEmitter class for managing custom events.\n *\n * @class\n * @example\n * const emitter = new EventEmitter();\n * emitter.on('event', data => console.log(data));\n * emitter.emit('event', { foo: 'bar' });\n */\nclass EventEmitter {\n    /**\n     * Initializes the EventEmitter instance.\n     * @constructor\n     */\n    constructor() {\n        this.events = {};\n    }\n\n    /**\n     * Registers a callback for the specified event.\n     * @param {string} eventName - The name of the event.\n     * @param {Function} callback - The callback function to register.\n     * @returns {EventEmitter} The instance for chaining.\n     */\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = [];\n        }\n        this.events[eventName].push(callback);\n        return this; // for chaining\n    }\n\n    /**\n     * Removes a callback for the specified event.\n     * If no callback is provided, removes all callbacks for the event.\n     * @param {string} eventName - The name of the event.\n     * @param {Function} [callback] - The callback function to remove.\n     * @returns {EventEmitter} The instance for chaining.\n     */\n    off(eventName, callback) {\n        if (!this.events[eventName]) return this;\n\n        if (callback) {\n            this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);\n        } else {\n            delete this.events[eventName];\n        }\n        return this;\n    }\n\n    /**\n     * Emits an event, calling all registered callbacks with the provided arguments.\n     * @param {string} eventName - The name of the event.\n     * @param {...any} args - Arguments to pass to the callbacks.\n     * @returns {boolean} True if the event had listeners, false otherwise.\n     */\n    emit(eventName, ...args) {\n        if (!this.events[eventName]) return false;\n\n        this.events[eventName].forEach(callback => {\n            callback(...args);\n        });\n        return true;\n    }\n\n    /**\n     * Registers a callback that is called at most once for the specified event.\n     * @param {string} eventName - The name of the event.\n     * @param {Function} callback - The callback function to register.\n     * @returns {EventEmitter} The instance for chaining.\n     */\n    once(eventName, callback) {\n        const onceCallback = (...args) => {\n            this.off(eventName, onceCallback);\n            callback(...args);\n        };\n\n        return this.on(eventName, onceCallback);\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/utils/event-emitter.js?");

/***/ }),

/***/ "./src/utils/utilities.js":
/*!********************************!*\
  !*** ./src/utils/utilities.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encryptAndStore: () => (/* binding */ encryptAndStore),\n/* harmony export */   retrieveAndDecrypt: () => (/* binding */ retrieveAndDecrypt),\n/* harmony export */   showNotification: () => (/* binding */ showNotification)\n/* harmony export */ });\n/**\n * Displays a notification at the top of the screen\n * @param {string} message - The message to display\n * @param {string} type - The Bootstrap type (success, danger, warning, info)\n */\nfunction showNotification(message, type = 'info') {\n    // Check if a notification container exists\n    let notificationContainer = document.getElementById('notification-container');\n    \n    if (!notificationContainer) {\n        // Create a new container if none exists\n        notificationContainer = document.createElement('div');\n        notificationContainer.id = 'notification-container';\n        notificationContainer.style.position = 'fixed';\n        notificationContainer.style.top = '10px';\n        notificationContainer.style.left = '50%';\n        notificationContainer.style.transform = 'translateX(-50%)';\n        notificationContainer.style.zIndex = '9999';\n        document.body.appendChild(notificationContainer);\n    }\n    \n    // Create the notification\n    const notification = document.createElement('div');\n    notification.className = `alert alert-${type} alert-dismissible fade show`;\n    notification.role = 'alert';\n    notification.innerHTML = `\n        ${message}\n        <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\" aria-label=\"Close\"></button>\n    `;\n    \n    // Add the notification to the container\n    notificationContainer.appendChild(notification);\n    \n    // Remove the notification after 5 seconds\n    setTimeout(() => {\n        notification.classList.remove('show');\n        setTimeout(() => {\n            if (notificationContainer.contains(notification)) {\n                notificationContainer.removeChild(notification);\n            }\n        }, 300);\n    }, 5000);\n}\n\n/**\n * Initialisiert einen client-spezifischen Verschlüsselungsschlüssel\n * Falls noch nicht vorhanden, wird ein neuer generiert und gespeichert\n * @returns {string} Verschlüsselungsschlüssel für diesen Client\n */\nfunction getOrCreateClientKey(recreate = false) {\n  // Prüfen, ob bereits ein Client-Key existiert\n  let clientKey = localStorage.getItem('_client_encryption_salt');\n  \n  // Falls nicht, einen neuen erstellen und speichern\n  if (!clientKey || recreate) {\n    // 32 zufällige Bytes generieren und als Hex-String speichern\n    const randomBytes = crypto.getRandomValues(new Uint8Array(32));\n    clientKey = Array.from(randomBytes)\n      .map(b => b.toString(16).padStart(2, '0'))\n      .join('');\n    \n    localStorage.setItem('_client_encryption_salt', clientKey);\n  }\n  \n  // Kombination aus dem gespeicherten Salt und einigen browserspezifischen Daten\n  const browserFingerprint = navigator.userAgent + navigator.language + screen.colorDepth;\n  \n  // Einfache (nicht kryptografische) Kombination der Werte\n  return clientKey + '_' + browserFingerprint.split('').reduce((hash, char) => {\n    return ((hash << 5) - hash) + char.charCodeAt(0);\n  }, 0);\n}\n\n/**\n * Stores a value encrypted in localStorage\n * @param {string} storageKey - Key for localStorage \n * @param {string} value - Value to store (e.g. API Key)\n * @param {string} password - Password for encryption\n * @returns {Promise<void>}\n */\nasync function encryptAndStore(storageKey, value) {\n    try {\n        const password = getOrCreateClientKey();\n        // Salt and IV for more security\n        const salt = crypto.getRandomValues(new Uint8Array(16));\n        const iv = crypto.getRandomValues(new Uint8Array(12));\n        \n        // Derive a cryptographic key from the password\n        const passwordKey = await crypto.subtle.importKey(\n            'raw', \n            new TextEncoder().encode(password),\n            { name: 'PBKDF2' },\n            false, \n            ['deriveBits', 'deriveKey']\n        );\n        \n        const aesKey = await crypto.subtle.deriveKey(\n            {\n                name: 'PBKDF2',\n                salt: salt,\n                iterations: 100000,\n                hash: 'SHA-256'\n            },\n            passwordKey,\n            { name: 'AES-GCM', length: 256 },\n            false,\n            ['encrypt']\n        );\n        \n        // Encrypt value\n        const encrypted = await crypto.subtle.encrypt(\n            { name: 'AES-GCM', iv: iv },\n            aesKey,\n            new TextEncoder().encode(value)\n        );\n        \n        // Combine everything into an object and store as JSON in localStorage\n        const encryptedObj = {\n            salt: Array.from(salt).map(b => b.toString(16).padStart(2, '0')).join(''),\n            iv: Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join(''),\n            data: Array.from(new Uint8Array(encrypted)).map(b => b.toString(16).padStart(2, '0')).join('')\n        };\n        \n        const jsonString = JSON.stringify(encryptedObj);\n        const jsonStringBase64 = btoa(encodeURIComponent(jsonString).replace(/%([0-9A-F]{2})/g, (_, p1) => String.fromCharCode('0x' + p1)));\n        localStorage.setItem(storageKey, jsonStringBase64);\n    } catch (error) {\n        console.error('Encryption error:', error);\n    }\n}\n\n/**\n * Reads an encrypted value from localStorage and decrypts it\n * @param {string} storageKey - Key for localStorage\n * @param {string} password - Password for decryption\n * @returns {Promise<string|null>} - Decrypted value or null on error\n */\nasync function retrieveAndDecrypt(storageKey) {\n    try {\n        const password = getOrCreateClientKey();\n        // Get encrypted data from localStorage\n        const storedData = localStorage.getItem(storageKey);\n        if (!storedData) return null;\n        // Decode base64 to JSON string\n        const jsonString = decodeURIComponent(Array.prototype.map.call(atob(storedData), c => \n            '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)\n        ).join(''));\n        const encryptedObj = JSON.parse(jsonString);\n        if (!encryptedObj) return null;\n        \n        // Convert hex strings back to Uint8Arrays\n        const salt = new Uint8Array(encryptedObj.salt.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n        const iv = new Uint8Array(encryptedObj.iv.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n        const encryptedData = new Uint8Array(encryptedObj.data.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n        \n        // Derive a cryptographic key from the password (same process as when storing)\n        const passwordKey = await crypto.subtle.importKey(\n            'raw', \n            new TextEncoder().encode(password),\n            { name: 'PBKDF2' },\n            false, \n            ['deriveBits', 'deriveKey']\n        );\n        \n        const aesKey = await crypto.subtle.deriveKey(\n            {\n                name: 'PBKDF2',\n                salt: salt,\n                iterations: 100000,\n                hash: 'SHA-256'\n            },\n            passwordKey,\n            { name: 'AES-GCM', length: 256 },\n            false,\n            ['decrypt']\n        );\n        \n        // Decrypt\n        const decrypted = await crypto.subtle.decrypt(\n            { name: 'AES-GCM', iv: iv },\n            aesKey,\n            encryptedData\n        );\n        \n        // Return as string\n        return new TextDecoder().decode(decrypted);\n    } catch (error) {\n        console.error('Decryption error:', error);\n        return null;\n    }\n}\n\n//# sourceURL=webpack://infravis/./src/utils/utilities.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;